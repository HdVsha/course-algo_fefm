Практика: Черепаха
##################

:date: 2019-02-04 09:00
:summary: Практика: Черепаха. Введение в основы Питона.
:status: published 

.. default-role:: code

:lecture_link: https://youtu.be/KdZ4HF1SrFs







Введение
========

Данный курс будет посвящен изучению программирования с использованием языка **Python**. Python — это современный язык
программирования, работающий на всех распространённых операционных системах.

В настоящее время Python широко используется для прикладных вычислений в математике, физике, биологии и экономике. 
Существуют отдельные курсы для освоения Python для научных вычислений, например https://ru.wikiversity.org/wiki/Программирование_и_научные_вычисления_на_языке_Python . 
К таким курсам есть хорошие шпаргалки, например http://www.inp.nsk.su/~grozin/python/ . 

И даже есть целые миникурсы-шпаргалки: 
https://nbviewer.jupyter.org/github/ischurov/odebook/blob/master/mathandpython.ipynb .

Пример статьи о преимущества Python в научном программировании https://habr.com/ru/post/349624/ .

Помимо вычислений, Python имеет и много других областей применения - машинное обучение, написание сайтов, анализ данных (https://proglib.io/p/data-science-basics/ )... 

В этом учебном курсе мы будем изучать алгоритмы и структуры данных на Python, что активно используется, например, в задачах
хемоинформатики и биоинформатики. 

В настоящее время существует две версии языка Python: более старая, но пока ещё более распространённая версия 2 и
современная версия 3. Мы будем использовать версию 3 данного языка. Именно её необходимо установить дома, скачав данную
версию с сайта `www.python.org`_.

.. _www.python.org: http://www.python.org

Запустить интерпретатор python можно из командной строки:

.. code-block:: bash

   python3

Будьте внимательны — команда `python` запустит интерпретатор версии 2, с которым мы работать не будем. В системе
Windows можно использовать пункт меню «Python (command line)».

Интерактивный режим
-------------------

Откройте командную строку и напишите команду python3.

Вы увидите примерно следующее приглашение командной строки:

.. code-block:: pycon

   Python 3.1.2 (r312:79147, Jun 12 2010, 15:29:06)
   [GCC 4.4.3 20100316 (ALT Linux 4.4.3-alt2)] on linux2
   Type "help", "copyright", "credits" or "license" for more information.
   >>>

Вводите команды и наслаждайтесь результатом. А что можно вводить? Несколько примеров:

.. code-block:: pycon

   >>> 2 + 2
   4
   >>> 2 ** 100
   1267650600228229401496703205376
   >>> 'Hello' + 'World'
   'HelloWorld'
   >>> 'ABC' * 10
   'ABCABCABCABCABCABCABCABCABCABC'

Первая команда вычисляет сумму двух чисел, вторая команда вычисляет 2 в степени 100, третья команда выполняет операцию
**конкатенации** для строк, а четвертая команда печатает строку `'ABC'`, повторенную 10 раз.

Хотите закончить работу с питоном? Введите команду `exit()` (именно так, со скобочками, так как это — **функция**)
или нажмите ``Ctrl+D``.

Программируемый режим
---------------------

В предыдущей главе мы использовали Python для простых разовых вычислений, используя интерактивный режим.
Теперь создадим программу и выполним её целиком.

.. code-block:: python

   a = 179
   b = 197
   c = (a ** 2 + b ** 2) ** 0.5
   print (c)

Здесь мы используем  **переменные** — объекты, в которых можно сохранять различные (числовые, строковые и прочие)
значения. В первой строке переменной `a` присваивается значение `179`, затем переменной `b` присваивается значение
`971`, затем переменной `c` присваивается значение арифметического выражения, равного длине гипотенузы. После этого
значение переменной `c` выводится на экран.

Упражнение №1: первая программа
-------------------------------

Откройте произвольный текстовый редактор, например, `gedit`. Скопируйте туда текст программы, написанной выше.
Сохраните текст в файле с именем `hypot.py`. 

Запустите *терминал*, перейдите в каталог, где лежит файл `hypot.py` и выполните эту программу:

.. code-block:: bash

   python3 hypot.py

Интерпретатор языка Python вместо интерактивного режима выполнит последовательность команд из файла.


При этом значения вычисленных выражений не выводятся на экран (в
отличии от интерактивного режима), поэтому для того, чтобы вывести результат работы программы, то есть значение
переменной `c`, нужна функция `print()`.

Базовый синтаксис языка Python 3
================================


Типы данных
-----------

Итак, мы видим, что Python умеет работать как минимум с двумя видами данных — числами и строками. Числа записываются
последовательностью цифр, также перед числом может стоять знак минус, а строки записываются в одинарных кавычках. `2`
и `'2'` — это разные объекты, первый объект — число, а второй — строка. Операция ``+`` для целых чисел и для строк
работает по-разному: для чисел это сложение, а для строк — конкатенация.

Кроме целых чисел есть и другой класс чисел: действительные (вещественные числа), представляемые в виде десятичных
дробей. Они записываются с использованием десятичной точки, например, `2.0`.

Очень удобно также то, что в Python встроены даже комплексные числа. Они записываются с помощью символа j. Например, `2 + 1j`.
Питон умеет выполнять все операции над ними, возводить в комплексную степень и даже извлекать корень из минус единицы. 

Определить тип объекта можно при помощи функции `type`:

.. code-block:: pycon

   >>> type(2)
   <class 'int'>
   >>> type('2')
   <class 'str'>
   >>> type(2.0)
   <class 'float'>
   >>> type(1+1j)
   <class 'complex'>
   >>> (1+1j)**1j
   (0.4288290062943679+0.1548717524642468j)
   >>> type( (-1)**0.5)
   <class 'complex'>
   >>> (-1)**0.25
   (0.7071067811865476+0.7071067811865475j)
   

Обратите внимание — `type` является функцией, аргументы функции указываются в скобках после ее имени.


Операции с числами
------------------

В Python целые числа зачастую удобнее вещественных и комплексных, потому что только они поддерживают встроенную в Python длинную арифметику. Чтобы сохранить её преимущества для вещественных чисел, нередко используют те или иные модули, в которых реализованы, например, рациональные числа на основе целых чисел Python, и, таким образом, используются возможности длинной арифметики. 


Над целыми числами можно производить битовые операции:

x | y	Побитовое или

x ^ y	Побитовое исключающее или

x & y	Побитовое и

x << n	Битовый сдвиг влево

x >> y	Битовый сдвиг вправо

~x	Инверсия битов


Также к ним применимы особые методы для целых чисел.

int.bit_length() - количество бит, необходимых для представления числа в двоичном виде, без учёта знака и лидирующих нулей.

int.to_bytes(length, byteorder, \*, signed=False) - возвращает строку байтов, представляющих это число.

classmethod int.from_bytes(bytes, byteorder, \*, signed=False) - возвращает число из данной строки байтов.

Примеры:

.. code-block:: pycon

   >>> n = -37
   >>> n.bit_length()
   6
   >>> (1024).to_bytes(2, byteorder='big')
   b'\x04\x00'
   >>> (1024).to_bytes(10, byteorder='big')
   b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
   >>> (-1024).to_bytes(10, byteorder='big', signed=True)
   b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
   >>> x = 1000
   >>> x.to_bytes((x.bit_length() // 8) + 1, byteorder='little')
   b'\xe8\x03'
   >>> int.from_bytes(b'\x00\x10', byteorder='big')
   16
   >>> int.from_bytes(b'\x00\x10', byteorder='little')
   4096
   >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
   -1024
   >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
   64512
   >>> int.from_bytes([255, 0, 0], byteorder='big')
   16711680


Для целых чисел предусмотрены функции для перевода их в другие системы счисления:

int([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.

bin(x) - преобразование целого числа в двоичную строку.

hex(х) - преобразование целого числа в шестнадцатеричную строку.

oct(х) - преобразование целого числа в восьмеричную строку.

Для целых и вещественных чисел определена целочисленная арифметика: 

- `A//B` — целая часть от деления А на В;
- `A % B` — остаток от деления А на В;


При делении на дробные и отрицательные числа возможно, соответственно, возникновение дробного и отрицательного остатка от деления.


Вот список основных операций для любых чисел (целых, вещественных, комплексных):

- `A+B` — сумма;
- `A-B` — разность;
- `A*B` — произведение;
- `A/B` — частное;
- `A**B` — возведение в степень.

Полезно помнить, что квадратный корень из числа ``x`` — это `x**0.5`, а корень степени ``n`` — это `x**(1/n)`.

Есть также унарный вариант операции ``-``, то есть операция с одним аргументом. Она возвращает число, противоположное
данному. Например: `-A`.

Для всех видов чисел определена функция abs() - взятие модуля. Для комплексных чисел она берёт модуль комплексного числа. 

В выражении может встречаться много операций подряд. Как в этом случае определяется порядок действий? Например, чему
будет равно `1+2*3**1+1`? В данном случае ответ будет 8, так как сначала выполняется возведение в степень, затем —
умножение, затем —  сложение.

Более общие правила определения приоритетов операций такие:

#. Выполняются возведения в степень  **справа налево**, то есть `3**3**3` это 3²⁷.
#. Выполняются унарные минусы (отрицания).
#. Выполняются умножения и деления слева направо. Операции умножения и деления имеют одинаковый приоритет.
#. Выполняются сложения и вычитания слева направо. Операции сложения и вычитания имеют одинаковый приоритет.


Примеры специфических операций для комплексных чисел:

.. code-block:: pycon

   >>> x = complex(1, 2)
   >>> print(x)
   (1+2j)
   >>> print(x.conjugate())  # Сопряжённое число
   (1-2j)
   >>> print(x.imag)  # Мнимая часть
   2.0
   >>> print(x.real)  # Действительная часть
   1.0
   >>> print(x > y)  # Комплексные числа нельзя сравнить
   Traceback (most recent call last):
   File "", line 1, in
   TypeError: unorderable types: complex() > complex()
   >>> print(x == y)  # Но можно проверить на равенство
   False
   >>> abs(3 + 4j)  # Модуль комплексного числа
   5.0
   >>> pow(3 + 4j, 2)  # Возведение в степень
   (-7+24j)


Гораздо больше функций для работы с ними есть в модуле cmath, который используется в Python. 


Операции над строками
---------------------

- `A+B` — конкатенация;
- `A*n` — повторение ``n`` раз, значение ``n`` должно быть целого типа.




Ветвление
---------

Ветвление (или условная инструкция) в Python имеет следующий синтаксис:

.. code-block:: python

   if Условие:
       Блок_инструкций_1
   else:
       Блок_инструкций_2

`Блок_инструкций_1` будет выполнен, если `Условие` истинно.  Если `Условие` ложно, будет выполнен `Блок_инструкций_2`.

В условной инструкции может отсутствовать слово `else` и последующий блок. Такая инструкция называется неполным
ветвлением.  Например, если дано число `x` и мы хотим заменить его на абсолютную величину `x`, то это можно сделать
следующим образом:

.. code-block:: python

   if x < 0:
       x = -x
   print(x)

В этом примере переменной `x` будет присвоено значение `-x`, но только в том случае, когда `x<0`. А вот инструкция
`print(x)` будет выполнена всегда, независимо от проверяемого условия.

Для выделения блока инструкций, относящихся к инструкции `if` или `else` в  языке Python используются отступы. Все
инструкции, которые относятся к одному блоку, должны иметь равную величину отступа, то есть одинаковое число пробелов в
начале строки. Рекомендуется использовать *отступ в 4 пробела*.


Вложенные условные инструкции
-----------------------------

Внутри условных инструкций можно использовать любые инструкции языка Python, в том числе и условную инструкцию. Вложенное ветвление — после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (например, 8 пробелов).

Примере программы, которая по данным ненулевым
числам x и y определяет, в какой из четвертей координатной плоскости находится точка (x,y):

.. code-block:: python

   x = int(input())
   y = int(input())
   if x > 0:
       if y > 0:               # x>0, y>0
           print("Первая четверть")
       else:                   # x>0, y<0
           print("Четвертая четверть")
   else:
       if y > 0:               # x<0, y>0
           print("Вторая четверть")
       else:                   # x<0, y<0
           print("Третья четверть")

В этом примере мы использовали *комментарии* – текст, который интерпретатор игнорирует.  Комментариями в Pythonе
является символ `#` и весь текст после этого символа до конца строки.


Операторы сравнения
-------------------

Как правило, в качестве проверяемого условия используется результат вычисления одного из следующих операторов сравнения:

+----------+---------------------------------------------------------------------------------+
| Оператор | Значение                                                                        |
+==========+=================================================================================+
| `<`      | Меньше — условие верно, если первый операнд меньше второго.                     |
+----------+---------------------------------------------------------------------------------+
| `>`      | Больше — условие верно, если первый операнд больше второго.                     |
+----------+---------------------------------------------------------------------------------+
| `<=`     | Меньше или равно — условие верно, если первый операнд меньше или равен второму. |
+----------+---------------------------------------------------------------------------------+
| `>=`     | Больше или равно — условие верно, если первый операнд больше или равен второму. |
+----------+---------------------------------------------------------------------------------+
| `==`     | Равенство. Условие верно, если два операнда равны.                              |
+----------+---------------------------------------------------------------------------------+

Например, условие `(x * x < 1000)` означает «значение `x * x` меньше 1000», а условие `(2 * x != y)` означает «удвоенное
значение переменной `x` не равно значению переменной `y`».


Операторы сравнения в можно объединять в цепочки, например, `a == b == c` или `1 <= x <= 10`.

Тип данных bool
---------------

Операторы сравнения возвращают значения специального логического типа `bool`. Значения логического типа могут принимать
одно из двух значений: `True` (истина) или `False` (ложь). Если преобразовать логическое `True` к типу `int`, то
получится 1, а преобразование `False` даст 0. При обратном преобразовании число 0 преобразуется в `False`, а любое
ненулевое число в `True`. При преобразовании `str` в `bool` пустая строка преобразовывается в `False`, а любая непустая
строка в `True`.


Каскадные условные инструкции
-----------------------------


Пример программы, определяющий четверть координатной плоскости, можно переписать используя «каскадную«
последовательность операцией `if... elif... else`:

.. code-block:: python

   x = int(input())
   y = int(input())
   if x > 0 and y > 0:
       print("Первая четверть")
   elif x > 0 and y < 0:
       print("Четвертая четверть")
   elif y > 0:
       print("Вторая четверть")
   else:
       print("Третья четверть")

В такой конструкции условия `if`, ..., `elif` проверяются по очереди, выполняется блок, соответствующий первому из
истинных условий. Если все проверяемые условия ложны, то выполняется блок `else`, если он присутствует.

Цикл while
----------


Цикл `while` («пока») позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно.
Условие записывается до тела цикла и проверяется до выполнения тела цикла. Как правило, цикл `while` используется, когда
невозможно определить точное значение количества проходов исполнения цикла.

Синтаксис цикла `while` в простейшем случае выглядит так:

.. code-block:: python

   while Условие:
       Блок_инструкций

При выполнении цикла `while` сначала проверяется условие. Если оно ложно, то  выполнение цикла прекращается и управление
передается на следующую инструкцию после тела цикла `while`. Если условие истинно, то выполняется инструкция, после чего
условие проверяется снова и снова выполняется инструкция. Так продолжается до тех пор, пока условие будет истинно. Как
только условие станет ложно, работа цикла завершится и управление передастся следующей инструкции после цикла.

Например, следующий фрагмент программы напечатает на экран всех целые числа, не превосходящие n:

.. code-block:: python

   a = 1
   while a <= n:
       print(a)
       a += 1

Общая схема цикла `while` в данном случае для перебора всех подходящих значений такая:

.. code-block:: python

   a = начальное_значение
   while а_является_подходящим_числом:
       обработать_a
       перейти_к_следующему_a

Выводем все степени двойки, не превосходящие числа n:

.. code-block:: python

   a = 1
   while a <= n:
       print(a)
       a *= 2

Цикл for
--------

Цикл `for` может быть использован как более краткая альтернатива циклу `while`.

Для последовательного перебора целых чисел из диапазона `[0; n)` можно использовать цикл `for`:

.. code-block:: python

   for i in range(10):
      print(i)

Этот код по выполняемым действиям полностью соответствуют циклу `while`:

.. code-block:: python

   i = 0
   while i < 10:
     print(i)
     i += 1

Можно задавать начальные и конечные значения для переменной цикла, а также шаг:

.. code-block:: python

   for i in range(20, 10, -2):
     print(i)

Аналогичный цикл `while`

.. code-block:: python

   i = 20
   while i > 10:
     print(i)
     i -= 2


Черепаха
========

Стандартная библиотека Python содержит модуль `turtle`, предназначенный для обучения программированию. Этот модуль
содержит набор_ функций, позволяющих управлять черепахой. Черепаха умеет выполнять небольшой набор команд, а именно:

.. _набор: https://docs.python.org/3/library/turtle.html#methods-of-rawturtle-turtle-and-corresponding-functions

+-------------+--------------------------------------------+
| Команда     | Значение                                   |
+=============+============================================+
| forward(X)  | Пройти вперёд X пикселей                   |
+-------------+--------------------------------------------+
| backward(X) | Пройти назад X пикселей                    |
+-------------+--------------------------------------------+
| left(X)     | Повернуться налево на X градусов           |
+-------------+--------------------------------------------+
| right(X)    | Повернуться направо на X градусов          |
+-------------+--------------------------------------------+
| penup()     | Не оставлять след при движении             |
+-------------+--------------------------------------------+
| pendown()   | Оставлять след при движении                |
+-------------+--------------------------------------------+
| shape(X)    | Изменить значок черепахи (“arrow”,         |
|             | “turtle”, “circle”, “square”, “triangle”,  |
|             | “classic”)                                 |
+-------------+--------------------------------------------+
|stamp()      | Нарисовать копию черепахи в текущем месте  |
+-------------+--------------------------------------------+
|color()      | Установить цвет                            |
+-------------+--------------------------------------------+
|begin_fill() | Необходимо вызвать перед рисованием фигуры,|
|             | которую надо закрасить                     |
+-------------+--------------------------------------------+
|end_fill()   | Вызвать после окончания рисования фигуры   |
+-------------+--------------------------------------------+
|width()      | Установить толщину линии                   |
+-------------+--------------------------------------------+
|goto(x, y)   | Переместить черепашку в точку (x, y)       |
+-------------+--------------------------------------------+

Например, следующая программа рисует букву `S`:

.. code-block:: python

   import turtle

   turtle.shape('turtle')
   turtle.forward(50)
   turtle.left(90)
   turtle.forward(50)
   turtle.left(90)
   turtle.forward(50)
   turtle.right(90)
   turtle.forward(50)
   turtle.right(90)
   turtle.forward(50)

.. image:: {filename}/images/lab17/example.gif

Упражнение №2: буква S
----------------------

Сохраните и выполните предыдущую программу. Убедитесь в том, что черепаха работает.

Упражнение №3: квадрат
----------------------

Нарисуйте квадрат. Пример:

.. image:: {filename}/images/lab17/rectangle.gif

Упражнение №4: окружность
-------------------------

Нарисуйте окружность. Воспользуйтесь тем фактом, что правильный многоугольник с большим числом сторон  будет выглядеть
как окружность. Пример:

.. image:: {filename}/images/lab17/circle.gif

Упражнение №5: больше квадратов
-------------------------------

Нарисуйте 10 вложенных квадратов.

.. image:: {filename}/images/lab17/nested_rectangles.gif

Упражнение №6: паук
-------------------

Нарисуйте паука с n лапами. Пример n = 12:

.. image:: {filename}/images/lab17/spider.gif

Упражнение №7: спираль
----------------------

Нарисуйте спираль. См. теорию_. Пример:

.. _теорию: https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D0%BC%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0_%D1%81%D0%BF%D0%B8%D1%80%D0%B0%D0%BB%D1%8C

.. image:: {filename}/images/lab17/spiral.gif

Упражнение №8: квадратная «спираль»
-----------------------------------

Нарисуйте «квадратную» спираль. Пример:

.. image:: {filename}/images/lab17/rect_spiral.gif

Написание функций
-----------------


Как было сказано раньше, функции — это своего рода готовые кирпичики, из которых строится программа. До этого момента мы
*использовали* стандартные функции (`print`, `input`, функции модуля `turtle`), теперь настало время *написать* функцию:

.. code-block:: pycon

   >>> def hello(name):
   ...     print('Hello, ', name, '!')
   ...
   >>> hello('world')
   Hello,  world!

Это простейший пример функции, которая принимает в качестве **параметра** имя, а затем выводит на экран сообщение
`Hello, <имя>`. Как видно из примера, функции в языке Python описываются при помощи ключевого слова `def`:

.. code-block:: python

   def Имя_функции(параметр_1, параметр_2, ...):
       Блок_операций

Так же, как и в случае циклов и условных операторов, **тело** функции выделяется при помощи отступов.

Вызов функции осуществляется по имени с указанием параметров:

.. code-block:: python

    hello('world')

Внутри функции можно использовать те же синтаксические конструкции, что и вне её — циклы, ветвления, можно даже
описывать новые функции. Естественно, внутри функции можно работать и с переменными.

Написанная ранее функция имеет особенность — она просто просто выводит текст на экран и не возвращает никакого
результата. Многие функции, напротив, занимаются вычислением какого-либо значения, а затем **возвращают** его тому, кто
эту функцию **вызвал**. В качестве примера можно рассмотреть функцию для сложения двух чисел:

.. code-block:: pycon

   >>> def sum(a, b):
   ...     return a + b
   ...
   >>> sum(1, 2)
   3
   >>> sum(5, -7)
   -2

Для возврата значения из функции используется оператор `return`: в качестве параметра указывается значение, которое
требуется вернуть.


Упражнение №9: правильные многоугольники
----------------------------------------

Нарисуйте 10 вложенных правильных многоугольников. Используйте функцию, рисующую правильный n-угольник. Формулы_ для
нахождения радиуса описанной окружности. Пример:

.. _Формулы: https://www.fxyz.ru/%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D1%8B_%D0%BF%D0%BE_%D0%B3%D0%B5%D0%BE%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B8/%D0%BF%D0%BB%D0%BE%D1%81%D0%BA%D0%B8%D0%B5_%D1%84%D0%B8%D0%B3%D1%83%D1%80%D1%8B/%D0%B2%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B8_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA%D0%B8/%D1%80%D0%B0%D0%B4%D0%B8%D1%83%D1%81_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%BD%D0%BE%D0%B9_%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8/%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA%D0%B0/

.. image:: {filename}/images/lab17/regular_polygon.gif

Упражнение №10: «цветок»
------------------------

Нарисуйте «цветок» из окружностей. Используйте функцию, рисующую окружность. Пример:

.. image:: {filename}/images/lab17/flower.gif


Упражнение №11: «бабочка»
-------------------------

Нарисуйте «бабочку» из окружностей. Используйте функцию, рисующую окружность. Пример:

.. image:: {filename}/images/lab17/butterfly.gif

Упражнение №12: пружина
-----------------------

Нарисуйте пружину. Используйте функцию, рисующую дугу. Пример:

.. image:: {filename}/images/lab17/spring.gif


Упражнение №13: смайлик
-----------------------

Нарисуйте смайлик с помощью написанных функций рисования круга и дуги. Пример:

.. image:: {filename}/images/lab17/smile.gif

Упражнение №14: звезды
----------------------

Нарисуйте две звезды: одну с 5 вершинами, другую — с 11. Используйте функцию, рисующую звезду с n вершинами. Пример:

.. image:: {filename}/images/lab17/star5.gif
.. image:: {filename}/images/lab17/star11.gif


Упражнение №15: алканы
----------------------

Нарисуйте функции, рисующие две буквы: букву С и букву Н. Используйте эти функции, чтобы нарисовать схематично органические молекулы - метан, пропан, бутан и все прочие из класса алканов, для любого n (n атомов углерода, 2n+2 атомов водорода). Сделайте эту программу в виде одной функции alkan(n).  Нарисуйте с помощью неё триэтилпропилметан.



Упражнение №16: перечисление изомеров
-------------------------------------

Венгерский математик Пойя прославился в том числе тем, что вывел рекуррентные формулы для вычисления числа изомеров алканов fn и
алкановых спиртов gn ( http://sci-hub.se/10.1007/BF02546665 страница 246). Напишите функции, которые вычисляют количество изомеров по этим формулам. Попробуйте fn для числа n = 167 - должно получиться число больше, чем количество элементарных частиц в нашей вселенной. Длинная арифметика Python позволяет посчитать его.
В этих формулах все индексы принимают целые неотрицательные значения, а f0 = 1, g0 = 1. Подробный вывод есть в статье Пойа Д. Комбинаторные вычисления для групп, графов и химических соединений (выше была ссылка на оригинальную научную статью). 

.. image:: {filename}/images/lab17/Numbers_alkans.jpg




Красивый код на Python
===============================================

Важная мысль создателя языка Python,  `Гвидо ван Россума`: **код читается намного больше раз, чем пишется**.

.. _`Гвидо ван Россума`: https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D1%81%D1%81%D1%83%D0%BC,_%D0%93%D0%B2%D0%B8%D0%B4%D0%BE_%D0%B2%D0%B0%D0%BD

Поэтому существуют рекомендации о стиле кодирования PEP8. Они направлены на то, чтобы улучшить читаемость и сделать его согласованным между большим числом проектов. В идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть.

На русском можно прочитать про PEP8 тут_, на английском — здесь_.

.. _тут: http://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html
.. _здесь: https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/
