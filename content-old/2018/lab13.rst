Динамичеcкое программирование. 
##############################





:date: 2018-11-26 07:00
:summary: Динамичеcкое программирование и порождение комбинаторных объектов.
:status: published 

.. default-role:: code



Основные понятия динамического программирования.
================================================

Динамическое программирование  — способ решения сложных задач путём разбиения их на более простые подзадачи. 
Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной.
В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, 
требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение.
Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу
только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся
подзадач экспоненциально велико.

Метод динамического программирования сверху — это простое запоминание результатов решения тех подзадач, которые могут
повторно встретиться в дальнейшем. Динамическое программирование снизу включает в себя переформулирование сложной 
задачи в виде рекурсивной последовательности более простых подзадач.

Словосочетание «динамическое программирование» впервые было использовано в 1940-х годах Р. Беллманом для описания 
процесса нахождения решения задачи, где ответ на одну задачу может быть получен только после решения задачи, «предшествующей» ей.

Динамическое программирование пользуется следующими свойствами задачи:

•	перекрывающиеся подзадачи;

•	оптимальная подструктура;

•	возможность запоминания решения часто встречающихся подзадач.

Динамическое программирование обычно придерживается двух подходов к решению задач:

•	нисходящее динамическое программирование: задача разбивается на подзадачи меньшего размера, они решаются и затем комбинируются для решения исходной задачи. Используется запоминание для решений часто встречающихся подзадач.

•	восходящее динамическое программирование: все подзадачи, которые впоследствии понадобятся для решения исходной задачи просчитываются заранее и затем используются для построения решения исходной задачи. Этот способ лучше нисходящего программирования в смысле размера необходимого стека и количества вызова функций, но иногда бывает нелегко заранее выяснить, решение каких подзадач нам потребуется в дальнейшем.


Оптимальная подструктура в динамическом программировании означает, что оптимальное решение подзадач меньшего размера
может быть использовано для решения исходной задачи. Подзадачи решаются делением их на подзадачи ещё меньшего размера и т. д., 
пока не приходят к тривиальному случаю задачи, решаемой за константное время (ответ можно сказать сразу). К примеру, 
если нам нужно найти n!, то тривиальной задачей будет 1! = 1 (или 0! = 1).

Перекрывающиеся подзадачи в динамическом программировании означают подзадачи, которые используются для решения некоторого
количества задач (не одной) большего размера (то есть мы несколько раз проделываем одно и то же).

Чтобы избежать такого хода событий мы будем сохранять решения подзадач, которые мы уже решали, и когда нам снова 
потребуется решение подзадачи, мы вместо того, чтобы вычислять его заново, просто достанем его из памяти. 
Этот подход называется мемоизацией (сохранение результатов выполнения функций для предотвращения повторных вычислений).


Классические задачи динамического программирования.
===================================================

•	Задача о наибольшей общей подпоследовательности: даны две последовательности, требуется найти самую длинную общую подпоследовательность.

•	Задача поиска наибольшей увеличивающейся подпоследовательности: дана последовательность, требуется найти самую длинную возрастающую подпоследовательность.

•	Задача о редакционном расстоянии (расстояние Левенштейна): даны две строки, требуется найти минимальное количество стираний, замен и добавлений символов, преобразующих одну строку в другую.

•	Задача о вычислении чисел Фибоначчи.

•	Задача о порядке перемножения матриц: даны матрицы,  требуется минимизировать количество скалярных операций для их перемножения.

•	Задача о выборе траектории.

•	Задача последовательного принятия решения.

•	Задача об использовании рабочей силы.

•	Задача управления запасами.

•	Задача о ранце: из неограниченного множества предметов со свойствами «стоимость» и «вес» требуется отобрать некое число предметов таким образом, чтобы получить максимальную суммарную стоимость при ограниченном суммарном весе.

•	Алгоритм Флойда — Уоршелла: найти кратчайшие расстояния между всеми вершинами взвешенного ориентированного графа.

•	Алгоритм Беллмана — Форда: найти кратчайший путь во взвешенном графе между двумя заданными вершинами.

•	Максимальное независимое множество вершин в дереве: дано дерево, найти максимальное множество вершин, никакие две из которых не связаны ребром.


Числа Фибоначчи.
================


Вычислить N чисел в последовательности Фибоначчи, — 1, 1, 2, 3, 5, 8, … — в которой первые два члена равны единице, 
а все остальные представляют собой сумму двух предыдущих. N меньше 100. Самый очевидный способ 'решения' задачи
состоит в написании рекурсивной функции примерно следующего вида:

.. code-block:: c

 int F(int n) {
     if (n < 2) return 1;
     else return F(n - 1) + F(n - 2);
     }





При этом на шестом-седьмом десятке программа 'подвесит' самый быстрый компьютер. Попробуем разобраться, почему так происходит?

Для вычисления F(40) мы сперва вычисляем F(39) и F(38). Причем F(38) мы считаем “по новой”, “забывая”, что уже вычислили его,
когда считали F(39).

То есть наша основная ошибка в том, что значение функции при одном и том же значении аргумента считается много (слишком много!) раз.
Если исключить повторный счет, то функция станет заметно эффективней. Для этого приходится завести массив, в котором хранятся
значения нашей функции.

Срабатывает золотой закон программирования — выигрывая в скорости, проигрываем в памяти. Сперва массив заполняется значениями,
которые заведомо не могут быть значениями нашей функции (чаще всего, это 'минус единица', но в нашей задачке вполне годится для
этих целей 'ноль'). При попытке вычислить какое-то значение, программа смотрит, не вычислялось ли оно ранее, и если да, то берет
готовый результат.

Функция принимает следующий вид (не верьте, пожалуйста, книгам, утверждающим, что искать числа Фибоначчи рекурсивно нельзя 
в принципе — можно, если отсечение делать с умом):

.. code-block:: c

 int F(int n) {
    if (A[n] != -1) return A[n];
    if (n < 2) return 1;
    else {
         A[n] = F(n - 1) + F(n - 2);
         return A[n];
         }
    }



Этот подход динамического программирования называется подходом 'сверху вниз'. Он запоминает решенные задачи, но очередность 
решения задач все равно контролирует рекурсия.

На этом уже можно остановиться, но можно еще более упростить решение, убрав рекурсию вообще. Для этого необходимо сменить 
нисходящую логику рассуждения (от того, что надо найти к тривиальному) на восходящую (соответственно наоборот). В этой задаче
такой переход очевиден и описывается простым циклом:

.. code-block:: c

  F[0] = 1;
  F[1] = 1;
  for (i = 2; i < n; i++) F[i] = F[i - 1] + F[i - 2];


Здесь использован подход 'снизу вверх'. Чаще всего такой способ в разы быстрее. Однако, в ряде случаев такой метод 
приводит к необходимости решать большее количество подзадач, нежели при рекурсии.

Очень часто для его написания приходится использовать как промежуточный результат нисходящую форму, а иногда 
безрекурсивная (итеративная) форма оказывается чрезвычайно сложной и малопонятной.

Общий совет таков: ишите и тестируйте рекурсивную форму, а переделыванием занимайтесь, если ваша программа превышает 
отведенное ей время на 'больших' тестах.



Порождение и перебор комбинаторных объектов.
============================================



Во многих прикладных задачах требуется найти оптимальное решение среди очень большого (но конечного!) числа вариантов. 
Иногда удается построить это решение сразу, но в большинстве случаев единственный способ его отыскать состоит в 
переборе всех возможных вариантов и сравнении их между собой. Поэтому так важно для нас научиться строить алгоритмы
перебора различных комбинаторных объектов - последовательностей, перестановок, подмножеств и т.д.

Схема перебора всегда будет одинакова:

- во-первых, надо установить порядок на элементах, подлежащих перечислению (в частности, определить, какой из них будет первым, а какой последним);


- во-вторых, научиться переходить от произвольного элемента к непосредственно следующему за ним (т.е. для заданного элемента x1 строить такой элемент x2, что x1<x2 и между x1 и x2 нет других элементов).

Hаиболее естественным способом упорядочения составных объектов является лексикографический порядок, принятый в любом словаре
(сначала сравниваются первые буквы слов, потом вторые и т.д.) - именно его чаще всего используют. 
А вот процедуру получения следующего элемента придется каждый раз изобретать заново. 

Пока запишем схему перебора в таком виде:

.. code-block:: c

  X=First;
	while (X!=Last) Next(X);




Задание 1. 
==========

Посчитать число последовательностей нулей и единиц длины n, в которых не встречаются две идущие подряд единицы.


Задание 2. 
==========

Hапечатать все последовательности длины N из чисел 1,2,...,M.
First = (1,1,...,1) Last = (M,M,...,M)
Всего таких последовательностей будет M^N 

Указание:

Чтобы понять. как должна действовать процедура Next, начнем с примеров. Пусть N=4,M=3. Тогда:
Next(1,1,1,1) -> (1,1,1,2) Next(1,1,1,3) -> (1,1,2,1) Next(3,1,3,3) -> (3,2,1,1)


Задание 3. 
==========

Hапечатать все перестановки чисел 1..N (то есть последовательности длины N, в которые каждое из чисел 1..N входит
ровно по одному разу).

First = (1,2,...,N) Last = (N,N-1,...,1)

Всего таких перестановок будет N!

Указание:

Для составления алгоритма Next зададимся вопросом: в каком случае i-ый член перестановки можно увеличить,
не меняя предыдущих? Ответ: если он меньше какого-либо из следующих членов (членов с номерами больше i).

Мы должны найти наибольшее i, при котором это так, т.е. такое i, что X[i]<X[i+1]>...>X[N] 
(если такого i нет, то перестановка последняя). После этого X[i] нужно увеличить минимально возможным способом,
т.е. найти среди X[i+1],...,X[N] наименьшее число, большее его. Поменяв X[i] с ним, остается расположить числа с
номерами i+1,...,N так, чтобы перестановка была наименьшей, то есть в возрастающем порядке. Это облегчается тем,
что они уже расположены в убывающем порядке.

Задание 4. 
==========

Перечислить все разбиения целого положительного числа N на целые положительные слагаемые
(разбиения, отличающиеся лишь порядком слагаемых, считаются за одно).

Пример: N=4, разбиения: 1+1+1+1, 2+1+1, 2+2, 3+1, 4.

First = (1,1,...,1) - N единиц Last = (N)

Указание:

Чтобы разбиения не повторялись, договоримся перечислять слагаемые в невозрастающем порядке. Сказать, сколько их
будет всего, не так-то просто (см.следующий пункт). Для составления алгоритма Next зададимся тем же вопросом: 
в каком случае i-ый член разбиения можно увеличить, не меняя предыдущих?

Во-первых, должно быть X[i-1]>X[i] или i=1. Во-вторых, i должно быть не последним элементом (увеличение i надо
компенсировать уменьшением следующих). Если такого i нет, то данное разбиение последнее. Увеличив i, все следующие 
элементы надо взять минимально возможными, т.е. равными единице.


Перебор с отходом назад.
========================

Как вы уже поняли, перебор комбинаторных объектов - задача весьма трудоемкая даже для компьютера.
Hапример, перестановок из восьми чисел будет 8! = 40320 - число немаленькое.
Поэтому в любой переборной задаче главная цель состоитв сокращении перебора, т.е. в исключении тех объектов, 
которые заведомо не могут стать решением задачи. 
Предположим, что нам требуется рассмотреть только те перестановки, для которых модуль  (X[i]-i) равен 8.
Понятно, что их будет гораздо меньше: например, все перестановки, начинающиеся на 8,7,... рассматривать не нужно!
Как можно модифицировать наш переборный алгоритм в этом случае? Если на каком-то этапе сумма

abs(X[1]-1) + abs(X[2]-2) + ... + abs(X[k]-k)

уже больше 8, то рассматривать все перестановки, начинающиеся на X[1],...,X[k] уже не нужно - следует вернуться к X[k] и
изменить его значение ("отойти назад" - отсюда название метода).

Для такой ситуации мы рассмотрим один общий метод, который почти всегда позволяет значительно сократить перебор.
Пусть искомое решение находится среди последовательностей вида

X[1],...,X[N],

где каждое X[i] выбирается из некоторого множества вариантов A[i]. Предположим мы уже построили начало этой
последовательности X[1],...,X[k] (k<N) и хотим продолжить его до решения.

Предположим также, что у нас есть некоторый простой метод P(X[1],...,X[k]), который позволяет получить ответ на вопрос: 
можно продолжить X[1],...,X[k] до решения (true) или нет (false). Заметим, что значение true еще HЕ ГАРАHТИРУЕТ 
существование такого продолжения, но зато значение false ГАРАHТИРУЕТ непродолжаемость ("не стоит дальше и пробовать").
Получаем простую рекурсивную процедуру перебора с отходом назад.

Классической задачей, которая решается методом  считается задача о восьми ферзях: требуется перечислить все 
способы расстановки 8-ми ферзей на шахматной доске 8 на 8, при которых они не бьют друг друга. 
Эту задачу решил больше 200 лет тому назад великий математик Леонард Эйлер. Заметьте, что у него не было компьютера,
но тем не менее он абсолютно верно нашел все 92 таких расстановки!

Задание 5. 
========== 

Решите задачу о 8 ферзях методом перебора назад. 


Задание 6. 
==========

Дано прямоугольное поле размером n×m клеток. Можно совершать шаги длиной в одну клетку вправо или вниз.
Посчитать, сколькими способами можно попасть из левой верхней клетки в правую нижнюю.


Задание 7. 
==========

Дано прямоугольное поле размером n×m клеток. Можно совершать шаги длиной в одну клетку вправо, вниз
или по диагонали вправо-вниз. В каждой клетке записано некоторое натуральное число. Необходимо попасть
из верхней левой клетки в правую нижнюю. Вес маршрута вычисляется как сумма чисел со всех посещенных клеток. 
Необходимо найти маршрут с минимальным весом.

Задание 8. 
==========

Дана последовательность целых чисел. Необходимо найти ее самую длинную строго возрастающую подпоследовательность.

Задание 9. 
==========

Указание:

Начнем решать задачу с начала — будем искать ответ, начиная с первых членов данной последовательности. 
Для каждого номера i будем искать наибольшую возрастающую подпоследовательность, оканчивающуюся элементом в позиции i.
Пусть исходная последовательность хранится в массиве A. В массиве L будем записывать длины максимальных 
подпоследовательностей, оканчивающихся текущим элементом. Пусть мы нашли все L[i] для 1 <= i <= k – 1. 
Теперь можно найти L[k] следующим образом. Просматриваем все элементы A[i] для 1 <= i < k – 1. Если A[i] < A[k],
то k-ый элемент может стать продолжением подпоследовательности, окончившейся элементом A[i]. 

Длина полученной подпоследовательности будет на 1 больше L[i]. Чтобы найти L[k], необходимо перебрать все i от 1 до k – 1: 
L[k] = max(L[i]) + 1, где максимум берется по всем i таким, что A[i] < A[k] и 1 <= i < k.


Здесь максимум из пустого множества будем считать равным 0. В этом случае текущий элемент станет единственным
в выбранной последовательности, а не будет продолжением одной из предыдущих. После заполнения массива L длина
наибольшей возрастающей подпоследовательности будет равна максимальному элементу L.


Чтобы восстановить саму подпоследовательность, можно для каждого элемента также сохранять номер предыдущего
выбранного элемента, например, в массив N.

Задание 10. 
===========

Дана строка из заглавных букв латинского алфавита. Необходимо найти длину наибольшего палиндрома, который
можно получить вычеркиванием некоторых букв из данной строки.

Указание:

Обозначим данную строку через S, а ее символы — через S[i], 1 <= i <= n. Будем рассматривать
возможные подстроки данной строки с i-го по j-ый символ, обозначим их через S(i, j). Длины максимальных
палиндромов для подстрок будем записывать в квадратный массив L: L[i][j] — длина максимального палиндрома, 
который можно получить из подстроки S(i, j).


Начнем решать задачу с самых простых подстрок. Для строки из одного символа (то есть подстроки вида
S(i, i)) ответ очевиден — ничего вычеркивать не надо, такая строка будет палиндромом. Для строки из
двух символов S(i, i + 1) возможны два варианта: если символы равны, то мы имеем палиндром, ничего 
вычеркивать не надо. Если же символы не равны, то вычеркиваем любой.


Пусть теперь нам дана подстрока S(i, j). Если первый (S[i]) и последний (S[j]) символы подстроки 
не совпадают, то один из них точно нужно вычеркнуть. Тогда у нас останется подстрока S(i, j – 1) 
или S(i + 1, j) — то есть мы сведем задачу к подзадаче: L[i][j] = max(L[i][j – 1], L[i + 1][j]). 
Если же первый и последний символы равны, то мы можем оставить оба, но необходимо знать решение 
задачи S(i + 1, j – 1): 

L[i][j] = L[i + 1][j – 1] + 2.


Рассмотрим решение на примере строки ABACCBA. Первым делом заполняем диагональ массива единицами,
они будут соответствовать подстрокам S(i, i) из одного символа. Затем начинаем рассматривать подстроки 
длины два. Во всех подстроках, кроме S(4, 5), символы различны, поэтому в соответствующие ячейки запишем 1, а в L[4][5] — 2.


Получается, что мы будем заполнять массив по диагоналям, начиная с главной диагонали, ведущей из левого верхнего угла в правый нижний. Для подстрок длины 3 получаются следующие значения: в подстроке ABA первая и последняя буквы равны, поэтому 
L[1][3] = L[2][2] + 2. В остальных подстроках первая и последняя буквы различны.


BAC: L[2][4] = max(L[2][3], L[3][4]) = 1.

ACC: L[3][5] = max(L[3][4], L[4][5]) = 2.

CCB: L[4][6] = max(L[4][5], L[5][6]) = 2.

CBA: L[5][7] = max(L[5][6], L[6][7]) = 1.


Продолжая далее аналогичные рассуждения, заполним все ячейки под диагональю и в ячейке L[1][7] = 6 получим ответ.

Если же в задаче необходимо вывести не длину, а сам палиндром, то дополнительно к массиву длин мы должны построить
массив переходов — для каждой ячейки запомнить, какой из случаев был реализован .

Метод ветвей и границ. 
======================

В основе метода ветвей и границ лежит идея последовательного разбиения множества допустимых решений на подмножества 
(стратегия “разделяй и властвуй”). На каждом шаге метода элементы разбиения подвергаются проверке для выяснения, 
содержит данное подмножество оптимальное решение или нет. Проверка осуществляется посредством вычисления оценки 
снизу для целевой функции на данном подмножестве. Если оценка снизу не меньше рекорда — наилучшего из найденных 
решений, то подмножество может быть отброшено. Проверяемое подмножество может быть отброшено еще и в том случае, 
когда в нем удается найти наилучшее решение. Если значение целевой функции на найденном решении меньше рекорда, 
то происходит смена рекорда. По окончанию работы алгоритма рекорд является результатом его работы.

Если удается отбросить все элементы разбиения, то рекорд — оптимальное решение задачи. В противном случае, 
из неотброшенных подмножеств выбирается наиболее перспективное (например, с наименьшим значением нижней оценки),
и оно подвергается разбиению. Новые подмножества вновь подвергаются проверке и т.д.

Задача о назначениях – это распределительная задача, в которой для выполнения каждой работы требуется один и
только один ресурс (один человек, одна автомашина и т.д.), а каждый ресурс может быть использован на одной и
только одной работе. То есть ресурсы не делимы между работами, а работы не делимы между ресурсами.

Исходные параметры модели задачи о назначениях

1.n – количество ресурсов, m – количество работ.

2.ai = 1 – единичное количество ресурса Ai (i =1,n), например: один работник; одно транспортное средство; одна научная тема и т.д.

3.bj = 1 – единичное количество работы Bj (j =1,m), например: одна должность; один маршрут; одна лаборатория.

4. cij – характеристика качества выполнения работы Bj с помощью ресурса Аi. Например, компетентность i-го работника
при работе на j-й должности; время, за которое i-е транспортное средство перевезет груз по j-му маршруту; степень 
квалификации i-й лаборатории при работе над j- й научной темой.

Задача о ранце (рюкзаке) — название получила от максимизационной задачи укладки как можно большего числа нужных 
вещей в рюкзак при условии, что общий объём (или вес) всех предметов, способных поместиться в рюкзак, ограничен.
В общем виде задачу можно сформулировать так: из заданного множества предметов со свойствами «стоимость» и «вес»,
требуется отобрать некое число предметов таким образом, чтобы получить максимальную суммарную стоимость при
одновременном соблюдении ограничения на суммарный вес.

Задание 11. 
===========

Решите задачу о рюкзаке. 

Задание 12. 
===========


Решите задачу коммивояжера.


Коммивояжер (бродячий торговец) должен выйти из первого города, посетить по одному разу в неизвестном порядке
города 2,3,4..n и вернуться в первый город. Расстояния между городами известны. В каком порядке следует обходить
города, чтобы замкнутый путь (тур) коммивояжера был кратчайшим?






