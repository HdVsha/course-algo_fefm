Анализ числовых последовательностей С++
#######################################

:date: 2018-09-30 09:00
:summary: Анализ числовых последовательностей С++.
:status: published 

.. default-role:: code

Получение параметров командной строки через аргументы main()
============================================================

Программа должна иметь глобальную функцию main — точку старта программы. 


.. code-block:: c

  #include <iostream>
  int  main(int argc, char* argv[]) // параметры функции main()

Эта строка — заголовок главной функции `main()`, в скобочках объявлены параметры `argс` и `argv`. 
При запуске программы через командную строку возможна передача информации через аргументы, для этого и существуют
параметры `argc` и `argv[]` . Параметр argc имеет тип данных `int`, и содержит количество параметров, 
передаваемых в функцию `main`. Причем argc всегда не меньше 1, даже когда мы не передаем никакой информации, 
так как `argv[0]` — это команда, с помощью которой вызывается программа, `argv[1]` — это первый аргумент командной 
строки и так далее до `argv[argc]`, который всегда имеет значение NULL. 

Через командную строку  можно передать только данные строкового типа.
Разработаем программу, которую будем запускать через командную строку, и передавать ей некоторую информацию.

.. code-block:: c

  #include <iostream>
  using namespace std;
  int main(int argc, char* argv[])
  {
    if (argc > 1)// если передаем аргументы, то argc будет больше 1
    {
      for (int i = 0; i < argc; i++) { cout << "Argument " << i << " : " << argv[i] << endl; } 
    }
    else
    {
      cout << "Not arguments" << endl;
    }
    return 0;
  }


Для получения числовых данных из входных параметров, можно использовать функции atoi и atof библиотеки <cstdlib>

.. code-block:: c
  
  int atoi(const char *str);
  float atof(const char *str);


Упражнение 1
============

Создайте программу, которая будет обрабатывать параметры функции main:

1)      Если параметров нет, то выводит "No arguments";

2)      Если параметр один, то выводит его;

3)      Если параметров 2 , то выводит среднее арифметическое (числа);

4)      Если параметров > 2, то выводит максимальный из них.

Запустите эту программу из терминала для каждого из 4 случаев.



Следующая программа показывает, как передавать аргументы командной строки:


.. code-block:: c

   #include <iostream> 
   using namespace std; 
   int main( int argc,      // Количество элементов в массиве argv
          char *argv[],   // Массив аргументов командной строки 
          char *envp[] )  // Массив переменных окружнения 
   { 
      // Показать аргументы командной строки
    cout << "\nCommand-line arguments:\n"; 
    for(int i = 0; i < argc; i++ ) 
         cout << "  argv[" << i << "]   " 
                << argv[i] << "\n"; 
    } 


где char \*envp[] – это массив указателей на значения переменных окружения. С помощью него можно их вывести. Запустите код:

.. code-block:: c
   
   #include <iostream> 
   using namespace std;
   main(int argc, char** argv, char** env)
    {      int i = 0;
    while(env[i] != 0)
    {
       cout << "\n" << env[i++];
    }
    return 0;
    }


Функция `main()`` возвращает целое значение, которое является кодом возврата (return code). По умолчанию она возвращает 0 при правильной работе программы (в противном случае возвращается код ошибки), но лучше явно писать return 0 в программе, так как без этой строчки программа не всегда может корректно работать.


Чтение из файла через ifstream и запись в файл через ofstream
=============================================================

Существуют два основных типа файлов: текстовые и двоичные. Текстовыми называются файлы, состоящие из любых печатных символов. Они организуются по строкам, каждая из которых заканчивается символом «конца строки» ("\\n").


Конец самого файла обозначается индикатором конца файла EOF. Для указания терминалу в UNIX и Linux «EOF» следует воспользоваться комбинацией клавиш Ctrl+D. В Windows — Ctrl+Z. При записи информации в текстовый файл, просмотреть который можно с помощью любого текстового редактора, все данные преобразуются к символьному типу. В двоичных файлах информация считывается и записывается в виде блоков определенного размера, в которых могут храниться данные любого вида и структуры.


Для работы с файлами используются специальные типы данных, называемые потоками. Поток ifstream служит для работы с файлами в режиме чтения, а ofstream в режиме записи. Для работы с файлами в режиме как записи, так и чтения служит поток fstream.  В программах на C++ при работе с текстовыми файлами необходимо подключать библиотеки iostream и fstream.
Для того, чтобы записывать данные в текстовый файл, необходимо:


1.     описать переменную типа ofstream.


2.     открыть файл с помощью функции open.


3.     вывести информацию в файл.


4.     обязательно закрыть файл.


Для считывания данных из текстового файла, необходимо:


1.     описать переменную типа ifstream.


2.     открыть файл с помощью функции open.


3.     считать информацию из файла, при считывании каждой порции данных необходимо проверять, достигнут ли конец файла.


4.     закрыть файл.


`ios::out` является режимом по умолчанию для потока ofstream:

ofstream F;  F.open(«/home/student/noobs.txt»);

или: 

ofstream F («/home/student/noobs.txt», ios::out);

fstream предоставляет функционал для считывания данных из файла и для записи в файл. В целом он очень похож на `iostream`, который работает с консолью. Наиболее часто используются:

1.     Операторы перенаправления ввода\\вывода – << и >>

2.     Методы записи и чтения строк getline() и get() c put()

3.     Потоковая запись и чтение методами write() и read()

4.     Методы открытия\\создания и закрытия файлов open() и close()

5.     Методы проверки открыт ли файл is_open() и достигнут ли конец файла eof()

6.     Настройка форматированного вывода для >> с помощью width() и precision()

7.     Операции позиционирования tellg(), tellp() и seekg(), seekp()


Это не все возможности, которые предоставляет библиотека fstream. Рассматривать все сейчас мы не будем, поскольку их круг применения достаточно узок.
Так же как и в `iostream` считывание можно организовать оператором >>, который указывает, в какую переменную будет произведено считывание. Этот оператор достаточно удобен, если стоит задача разделить файл на слова или числа:


.. code-block:: c
   
   #include <fstream>
   using namespace std;

   int main(int argc, char* argv[])
   {
        ofstream fout("hello.txt");
        fout << "Hello world";
        fout.close();
	ifstream fin("hello.txt");
	char s;
	for(fin >> s; !fin.eof(); fin >> s) cout << s << endl;
	fin.close();
        return 0;
   }


Метод `read()`. Используется для чтения из файла.

Метод `close()`. Открытые файлы следует закрывать:  file.close().

Метод `eof()`. Проверяет, не достигнут ли конец файла. Т.е. можно ли из него продолжать чтение.

Метод `write()`. Используется для записи в файл.

Метод `is_open()`. Метод `is_open()`` вернет 1, если файл найден и успешно открыт. Иначе вернет 0.

Метод `seekg()`. Функция `seekg()` используется с потоками ввода. Она смещает указатель "get" для текущего потока на offset байтов, или располагает указатель "get" в позицию `position`.

`seekg( pos_type position );`   `seekg( off_type offset, ios::seekdir origin)`

Например: `infile.seekg (0);` – перемещает указатель в начало файла.

Метод `tellg()`. Функция `tellg()` используется с потоками ввода. Она возвращает текущую позицию указателя ввода "get" в потоке – этот указатель обычно называют курсором. При обычном открытии файла курсор на позиции 0 (начало файла).


Примеры использования методов:

.. code-block:: c
   
   ofstream ofs("test.txt"); //создать
   ofs.close(); 
   std::remove("test.txt"); //удалить


.. code-block:: c

   #include <iostream>
   #include <fstream> // std::ifstream, std::ofstream

   using namespace std;

   int main () {
   
   // создаём файл для считывания из него
   
   ofstream out0file ("test.txt",ofstream::binary);
   out0file.write ("hello", 5);
   out0file.close();

   ifstream infile ("test.txt",ifstream::binary);
   ofstream outfile ("new.txt",ofstream::binary);

   // определяем размер файла входных данных

  infile.seekg (0, infile.end);
  long size = infile.tellg();
  infile.seekg (0);

  // создаём массив из символов нужного размера
  char buffer [size];

  // читаем файл
  infile.read (buffer,size);

  // записываем в другой файл
  outfile.write (buffer,size);

  //закрываем файлы
  outfile.close();
  infile.close();
  return 0;
   }


Второй пример нежелательно использовать для файлов серьёзного размера, так как может привести к нехватке оперативной памяти.


Если надо считать всю строку целиком или даже все строки из файла, то лучше использовать встроенную функцию `getline()`, которая принимает поток для чтения и переменную, в которую надо считать текст:

.. code-block:: c
   
   #include <iostream>
   #include <fstream>
   #include <string>
   int main()
   {
    std::string line;
    std::ifstream in("./hello.txt"); // окрываем файл для чтения
    if (in.is_open())
    {
        while (getline(in, line))
        {
            std::cout << line << std::endl;
        }
    }
    in.close();     // закрываем файл
    std::cout << "End of program" << std::endl;
    return 0;
   }

В следующем примере показан цикл считывания строк из файла `test.txt` и их отображения на консоли. 


.. code-block:: c
   
   #include <iostream>
   #include <fstream>
   using namespace std;

   int main() {
   ifstream file;            // создать поточный объект file
   file.open("test.txt");    // открыть файл на чтение
   if (!file) return 1;      // возврат по ошибке отрытия
   char str[80];             // статический буфер строки
   // Считывать и отображать строки в цикле, пока не eof
   while (!file.getline(str, sizeof(str)).eof())
   cout << str << endl;     // вывод прочитанной строки на экран
   return 0;
   }


Добавление данных в текстовый файл с последующим чтением всего файла

.. code-block:: c
   
   #include <iostream>
   #include <fstream>
   using namespace std;
 
   int main() {
   ofstream file;
   file.open("test.txt",ios::out|ios::app);
   if (!file) {
    cout << "File error - can't open to write data!";
    return 1;
    }
    for (int i=0; i<10; i++) file << i << endl;
   file.close();

   ifstream file2;
   file2.open("test.txt", ios::in);
   if (!file2) {
    cout << "File error - can't open to read data!";
    return 2;
   }
   int a,k=0;
   while (1) {
    file2 >> a;
    if (file2.eof()) break;
    cout << a << " ";
    k++;
    }
   cout << endl << "K=" << k << endl;
   file2.close();

   return 0;
   }


Генератор случайных чисел
=========================

Случайные числа в программировании реализуются с помощью сложных функций, значения которых можно для практических нужд считать случайными последовательностями, хотя на самом деле они не случайные. Такие последовательности и числа называют псевдослучайными.

Функция rand генерирует псевдослучайные числа, возвращая псевдослучайное целое число в диапазоне от 0 до `RAND_MAX`. Это число генерируется алгоритмом, который возвращает последовательность псевдослучайных чисел. Этот алгоритм использует своего рода «семя» — число, для создания серий псевдослучайных чисел. 


Функция  `srand` выполняет инициализацию генератора псевдослучайных чисел rand. Генератор псевдослучайных чисел инициализируется с помощью аргумента `seed`, который играет роль «семени». `RAND_MAX` это константа, определенная в `<cstdlib>`. По умолчанию seed равен 1. Если seed установлен в 1, генератор производит одни и те же значения.


Для того, чтобы генерировать псевдослучайные числа, функция srand обычно инициализируется различными значениями, например, такие значения генерируются функцией `time` (эта функция возвращает текущее время). Значение, возвращенное функцией `time` (объявлена в <ctime>) отличается каждую секунду, что дает возможность получать совершенно псевдослучайные последовательности чисел, при каждом новом вызове функции `rand`. 


.. code-block:: c
   
   #include <iostream>
   #include <cstdlib>
   #include <ctime>
   int main ()
   {
   std::cout << "Первое число: "          << (rand() % 100) << "\n";
   srand ( time(NULL) ); // инициализация функции rand значением функции time
   std::cout << "Случайное число: "     << (rand() % 100) << "\n";
   srand ( 1 );  // инициализация функции rand значением 1
   std::cout << "Снова первое число: " << (rand() % 100) << "\n";
   return 0;
    }


<cmath> 
=======

Библиотека cmath определяет набор функций для выполнения общих математических операций и преобразований – тригонометрические, показательные, логарифмические, гиперболические функции, функции округления, возведения в степень.

Функция `pow` возводит число в степень:  pow(2,4) – 2 в степени 4.


Упражнение 2
============

В текстовый файл numbers.txt записать случайное количество (от 20 до 40) случайных целых чисел (величиной от 1 до 100), закрыть файл. Затем открыть файл для чтения, считать их, вывести их на экран и вычислить их среднее геометрическое.
После этого методом is_open() попробуйте открыть файл otput.txt. Если он существует, то следует стереть его, а потом создать заново и записать в него ответ. Если его не существует, то следует создать этот файл.  


Упражнение 3
============

В текстовый файл stream.txt записать заданное количество N случайных целых чисел (величиной от 1 до 1000), закрыть файл. Затем открыть файл для чтения, считать их.

1)     Вывести на экран все числа из файла, которые делятся на 12;

2)     Найти число 15 в последовательности (какое по счёту, вывести самое первое);

3)     Найти максимальное и минимальное число в последовательности;

4)     Вывести все простые числа в последовательности;

5)     Вывести максимальное простое в последовательности;

6)     Вывести все простые делители максимального числа последовательности;


Приложение – краткая справка по некоторым основам языка
=======================================================


Основные типы данных в C++
--------------------------


•	int — целочисленный тип данных.

•	float — тип данных с плавающей запятой.

•	double — тип данных с плавающей запятой двойной точности.

•	char — символьный тип данных.

•	bool — логический тип данных.


Инициализация переменных C++
----------------------------

Тип переменная ;  Например :

  
.. code-block:: c

   char sym;
   int N;
   float p;




Условия С++
-----------

.. code-block:: c

	if (Условие)    {
    Тело – выполняемые действия; 
  } else {
   другие действия;
  }


Можно вкладывать друг в друга, например:

.. code-block:: c 

   if (num < 10) { 
   cout << "Это число меньше 10." << endl; 
                 } 
   else if (num == 10) { 
   cout << "Это число равно 10." << endl; 
                  } 
   else { 
   cout << "Это число больше 10." << endl; 
        }


Циклы C++
---------

.. code-block:: c 

   for (действие до начала цикла; условие продолжения цикла; действия в конце каждой итерации цикла) { 
        инструкция цикла; 
	инструкция цикла 2; 
	...
	инструкция цикла N;
	}

    while (Условие) { 
    Тело цикла;
                    }
   do { 
   Тело цикла; 
   } 
   while (Условие);
   
   
Дополнительные задачи
=====================

1. Во входном файле in.txt записана последовательность из 10 различных целых чисел. Определите, сколько треугольников можно построить со сторонами, длины которых равны трём разным числам последовательности.


2. С клавиатуры вводится последовательность целых чисел, заканчивающаяся нулём. Определите, можно ли построить замкнутую линию из отрезков, длины которых равны этим числам.


3. Дан набор точек на плоскости. Необходимо вывести точки, лежащие на осях, в том же порядке, в котором они задаются, а для остальных подсчитать и вывести количество точек, лежащих в каждой координатной четверти. В первой строке входного файла points.txt  записано количество точек. Каждая следующая строка состоит из двух целых чисел — координат точки. Сначала нужно вывести точки, лежащие на осях, по одной на строке. Координаты выводятся в круглых скобках через запятую (и пробел). В последней строке выводятся подсчитанные значения: количество точек в каждой четверти по порядку через двоеточие (и пробел) после номера четверти, обозначенного римской цифрой. Значения перечисляются через запятую (и пробел), а в конце перечисления ставится точка. Пример:


Ввод
====


5

1 2

-1 2

0 0

0 -5

5 -6


Вывод
=====


(0, 0)

(0, -5)

I: 1, II: 1, III: 0, IV: 1.


