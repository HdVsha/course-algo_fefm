Массивы
############################################

:date: 2020-10-12 09:00
:summary: Массивы. Контест на массивы.
:status: published

.. default-role:: code
.. contents:: Содержание



Массив как структура данных
==============================

Массив (*англ.* array) - структура данных, хранящая набор значений. Каждое значение из набора *индексируется*, т.е. значения имеют номера (индексы).

Простейший массив имеет следующий интерфейс

1. `создать(A, N) -> массив A длины N` - создание массива `A` размера `N`.
2. `записать(A, i, x)` - записывает значение `x` в `i`-ый элемент массива `A`.
3. `считать(A, i) -> элемент массива A с индексом i` - взятие элемента по индексу (чтение).
4. `удалить(A)` - удаление массива `А`.

Обычно индексами массива являются целые положительные числа, причём в непрерывном диапазоне. Например, `0, 1, 2,... N-2, N-1`, где N - размер массива. В таком случае массив *упорядочен* по индексу и можно говорить, что массив также является *последовательностью*.

Для массива операции чтения и записи выполняются за `O(1)`, т.е. не время этих операций не зависит от количества элементов в массиве.

Массив в Python
================

Массив в Python

упорядоченная изменяемая последовательность...
  массив хранит множество элементов, которые образуют последовательность. При этом можно изменять как сами элементы массива, так и сам массив: пополнять массив новыми элементами или удалять их.

\...объектов произвольных типов
  элементами массива являются Python-объекты. При этом допускается, чтобы в одном массиве хранились объекты разных типов.

**Массивы в Python** также называют списками или листами (*англ.* list).
Терминология в других языках программирования, а также в теории алгоритмов может быть другая.

Список Python является гибким в использовании объектом.
Как инструмент, программист может использовать списки, например, для создания элементов линейной алгебры: точек, векторов, матриц, тензоров.
Или, например, для таблицы с некоторыми данными.

Важно заметить, что `<class 'list'>`, питоновский список, является универсальной структурой данных. В том числе, ей можно пользоваться как массивом (что мы и будем делать)! То есть, у этого объекта есть интерфейс, описанный в предыдущем разделе, причём с теми же асимптотиками, хотя возможности выходят гораздо за пределы простейшего массива.


Создание массива
================

Литерал массива
---------------

Массив можно создать при помощи литералов. Литерал - это код, который используется для создания объекта "вручную" (задания константы). Например, некоторые литералы уже изученных ранее объектов:

- `int`: `5`, `-23`
- `float`: `5.`, `5.0`, `-10.81`, `-1.081e1`
- `str`: `'ABCdef'`, `"ABCdef"`

В случае массива литералом являются квадратные скобки `[]`, внутри которых через запятую `,` перечисляются элементы массива:

.. code-block:: pycon

  >>> []
  []
  >>> [0, 1, 2, 3, 4]
  [0, 1, 2, 3, 4]
  >>> ['sapere', 'aude']
  ['sapere', 'aude']
  >>> ['Gravitational acceleration', 9.80665, 'm s^-2']
  ['Gravitational acceleration', 9.80665, 'm s^-2']
  >>> type([0, 1, 2, 3, 4])
  <class 'list'>


Создание массива заданной длины, склеивание массивов
-----------------------------------------------------

Чтобы создать массив наперёд заданной длины, нужно задать инициализируещее значение и длину. Ниже создаётся массив, содержащий 10 нулей.

.. code-block:: pycon

  >>> A = [0] * 10
  >>> A
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  >>> type(A)
  <class 'list'>

С похожим синтаксисом мы сталкивались при работе со строками. Массивы в Python можно "склеивать" с помощью знака сложения:

.. code-block:: pycon

  >>> A = [0] * 3  # [0, 0, 0]
  >>> B = [1] * 3  # [1, 1, 1]
  >>> C = [2] * 3  # [2, 2, 2]
  >>> D = A + B + C
  >>> D
  [0, 0, 0, 1, 1, 1, 2, 2, 2]

На самом деле, умножение массива на целое число `M` это создание нового массива путём `M` "склеиваний" исходного массива с самим собой:

.. code-block:: pycon

  >>> [0, 1] * 3
  [0, 1, 0, 1, 0, 1]
  >>> [0, 1] + [0, 1] + [0, 1]
  [0, 1, 0, 1, 0, 1]


Элементы массива: доступ и изменение
====================================

Выше мы убедились, что массив это множество объектов различных типов, теперь убедимся, что это упорядоченная последовательность изменяемых объектов.

Доступ по индексу
-----------------

Для доступа к элементам массива используется операция *взятия элемента по индексу*.
Для этого рядом с литералом или переменной массива необходимо подписать *индекс* элемента в квадратных скобках:

.. code-block:: pycon

  >>> ['Gravitational acceleration', 9.80665, 'm s^-2'][0]
  'Gravitational acceleration'
  >>> ['Gravitational acceleration', 9.80665, 'm s^-2'][1]
  9.80665
  >>> ['Gravitational acceleration', 9.80665, 'm s^-2'][2]
  'm s^-2'
  >>> l = [10, 20, 30]
  >>> l[0]
  10
  >>> l[1]
  20
  >>> l[2]
  30

Нумерация элементов массива начинается с **нуля**.

При запросе элемента по несуществующему индексу, Python вызовет ошибку ``IndexError``:

.. code-block:: pycon

  >>> l
  [10, 20, 30]
  >>> l[3]
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  IndexError: list index out of range

Поэтому всегда нужно быть уверенным, что индексация не выходит за пределы *длины массива*.
Получить её можно с помощью функции `len()`:

.. code-block:: pycon

  >>> l
  [10, 20, 30]
  >>> len(l)
  3
  >>> l[len(l) - 1]
  30


Последняя конструкция встречается нередко, поэтому в Python существует возможность взять элемент по отрицательному индексу:

.. code-block:: pycon

  >>> l
  [10, 20, 30]
  >>> l[-1]
  30
  >>> l[-2]
  20
  >>> l[-3]
  10
  >>> l[-4]
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  IndexError: list index out of range

Таким образом для индекса ``n ≥ 0``, `l[-n]` эвивалентно `l[len(l) - n]`.

Изменение элементов
-------------------

Изменение элементов осуществляется с помощью присваивания:

.. code-block:: pycon

  >>> l = [10, 20, 30]
  >>> l
  [10, 20, 30]
  >>> l[0] = 0
  >>> l
  [0, 20, 30]
  >>> l[2] = 55
  >>> l
  [0, 20, 55]


Доступ в цикле ``while``
------------------------

.. code-block:: pycon

  >>> l
  [0, 20, 55]
  >>> i = 0
  >>> while i < len(l):
  ...     print(i, l[i])
  ...     i += 1
  ...
  0 0
  1 20
  2 55
  >>>

Доступ в цикле ``for``
----------------------
Наиболее универсальный способ это использование генератора ``range``:

.. code-block:: pycon

  >>> l
  [0, 20, 55]
  >>> for i in range(len(l)):
  ...     print(i, l[i])
  ...
  0 0
  1 20
  2 55

Печать массива
=================================

Чтобы распечатать элементы массива в столбец, воспользуйтесь циклом `for`, как в разделе выше.

Если нужно распечатать массив в строку, то воспользуйтесь функцией `print`:

.. code-block:: pycon

  >>> A = [0, 1, 2, 3]
  >>> print(*A)
  0 1 2 3

Здесь знак `*` это операция развёртывания коллекции по аргументам функции. Функция `print` принимает на вход сколько угодно аргументов и действие выше эквиваленто следующему:

.. code-block:: pycon

  >>> print(A[0], A[1], A[2], A[3])
  0 1 2 3

Ремарка о строках
=================

На самом деле, мы уже ранее сталкивались с массивами в предудыщих лабораторных, когда использовали строковый метод `str.split`:

.. code-block:: python

  >>> s = "ab cd ef1 2 301"
  >>> s.split()
  ['ab', 'cd', 'ef1', '2', '301']

Т.е. `str.split`, по умолчанию, разбивает строку по символам пустого пространства (пробел, табуляция) и создаёт массив из получившихся "слов".

Загляните в `help(str.split)`, чтобы узнать, как изменить такое поведение, и разбивать строку, например, по запятым, что является стандартом для представления таблиц в файлах `csv` (comma separated values).

Методом, являющимся обратным к операции `str.split` является `str.join`.
Он "собирает" строку из массива строк:

.. code-block:: python

  >>> s
  'ab cd ef1 2 301'
  >>> l = s.split()
  >>> l
  ['ab', 'cd', 'ef1', '2', '301']
  >>> l[-1] = '430'
  >>> l
  ['ab', 'cd', 'ef1', '2', '430']
  >>> ','.join(l)
  'ab,cd,ef1,2,430'
  >>> ' -- '.join(l)
  'ab -- cd -- ef1 -- 2 -- 430'

Работа с двумерными массивами
=============================

Как вам рассказали, в массиве мы можем хранить различные данные.
В том числе в ячейке массива можем хранить другой массив. Давайте предположим, что
в каждой ячейке массива размера `N` у нас будет храниться другой массив размера `M`.
Таким образом мы можем построить таблицу или матрицу размера `N x M`.

Создание двумерного массива (матрицы) размера `N x M` в питоне:

.. code-block:: python

  a = []
  for _ in range(n):
    a.append([0] * m)

или

.. code-block:: python

  a = [[0] * m for _ in range(n)]

Обращение к элементами двумерного массива:

.. code-block:: python

  a[i][j] = 5

Контест №5
==========

Ссылки на контесты

- `Начинающие (участвовать) <http://judge2.vdi.mipt.ru/cgi-bin/new-client?contest_id=94209>`_
- `Основные (участвовать) <http://judge2.vdi.mipt.ru/cgi-bin/new-client?contest_id=94210>`_
- `Продвинутые (участвовать) <http://judge2.vdi.mipt.ru/cgi-bin/new-client?contest_id=94211>`_
