Словари и множества в Python
############################

:date: 2019-03-12 08:00
:status: published
:summary: Работа с множествами и словарями.

.. default-role:: code


Хэширование
===========

Хэширование - это процесс, в котором на вход некоторого хэширующего алгоритма подаются достаточно большие по объёму данные, и на выходе получается относительно короткая (размером порядка 16-64 байта), но при этом достаточно уникальная строка, которая позволяет отличить входные данные от каких-то других данных. Эта строка называется "хэш".

Хэш используется для того, чтобы быстрее отличать одни данные от других без необходимости сравнивать каждый байт этих данных. Достаточно обработать данные один раз (вычислить их хэши) и можно сравнивать только их, а это гораздо быстрее. Если хэши различаются, значит, это совершенно точно разные данные. Если хэши одинаковы, значит, с большой вероятностью это одинаковые данные. Хотя всегда существует маленький шанс, что данные всё-таки разные, несмотря на одинаковые хэши.

Хэширующий алгоритм (хэш-функция) должен стремиться как можно лучше выполнять следующие требования:

1. Одни и те же данные должны давать всегда один и тот же хэш. Это обязательное условие.

2. Разные данные "почти всегда" должны давать разный хэш. Ситуация, когда разным значениям входных данных соотвествует одно и тоже значение хэш функции, называется коллизией. Коллизии существуют для большинства хеш-функций, но для самых хороших из них количество коллизий близко к теоретическому минимуму.

Хорошая хэш-функция ведёт себя следующим образом:

1. Весь доступный диапазон хэшей используется по максимуму. То есть, если на хэш отведено 32 байта, то разные данные дают максимально разнообразный хэш, который может являться совершенно любой комбинацией битов. То есть, диапазон хэшей не "простаивает".

2. Даже небольшое изменение входных данных (даже изменение 1 бита входных данных) должно давать другой хэш. Не должно быть такого, что небольшие изменения дают тот же самый хэш. Тот же самый хэш должен возникать в результате какого-то совершенно другого набора данных, чтобы вероятность случайного присутствия двух таких данных (дающих одинаковый хэш) была минимальной.

Одно из применений хэширования - ускорение сравнения больших обьектов. Допустим, есть массив из миллиона разных строк. В каждой строке миллион символов. И поставлена задача добавить строку в массив, но только в том случае, если такой строки там ещё нет.

В итоге, задача превращается в посимвольное сравнение миллиона символов в миллионах строк. Очень хорошо, если начала строк разные и можно быстро отсеивать неподходящие строки. Но если все строки содержат примерно одинаковый текст, то количество сравнений будет очень большим.

Но если перед записью вычислить хэши хранящихся строк, то задача превращается в сравнение 32 символов вместо миллиона символов (32 мегабайта данных на весь массив). Если в списке есть точно такой же хэш, то для полной надёжности, можно сравнить посимвольно только эту строку. В итоге получается гораздо меньше затрат, чем сравнивать все строки целиком. (На самом деле, даже 32 мегабайта хэшей проверять не потребуется, поскольку по теории вероятностей, лишь 1-2 первых символа хэшей будут совпадать, да и то очень редко, а 3 одинаковых символа подряд, возможно, не найдутся во всём миллионе хэшей. И это при том, что изначальные данные могли быть очень похожими).

Хэш также может использоваться для проверки целостности данных при передаче. Вы передали гигабайт данных, а затем 32-байтный хэш. Получатель на своей стороне захешировал этот гигабайт тем же способом (той же хэш-функцией) и получил тот же самый хэш. Теперь он уверен, что он имеет точно те же данные, что и отправитель (вероятность случайной ошибки примерно около 1e-70, поэтому ей можно пренебречь; на самом деле, вероятность, скорее всего, ещё меньше, потому что хорошая хэш-функция не даст такой же хэш на похожих данных).

Существуют различные алгоритмы хэширования — MD5, SHA-1, SHA-2, CRC32 и т.д. Достоинства и недостатки каждого из них можно найти в соотвествующей литературе. Некоторые из них реализованы в виде консольных утилит.

Пример
------

Создадим файл `hello.txt` с содержимым "Hello World" и посчитаем значения различных хэш функций:

.. code-block:: bash

	>> crc32 ./hello.txt
	>> b095e5e3
	>> md5 ./hello.txt
	>> MD5 (./hello.txt) = e59ff97941044f85df5297e1c302d260

Изменим последнюю букву на "e", чтобы содержимое файла стало  "Hello Worle":

.. code-block:: bash

	>> crc32 ./hello.txt
	>> a98ed4a2
	>> md5 ./hello.txt
	>> MD5 (./hello.txt) = b634c3bbd31ee882edbdec4dc6e5b53e

Как мы видим, изменение всего одного символа очень сильно изменило значение хэш функции.

Пример
------

В Python есть встроенная функция hash(obj)  -> int . Возвращает целое, являющееся хешем объекта.

Хеш используется, в частности, для быстрого сравнения ключей при поиске по словарям. Равные числовые значения имеют одинаковый хеш, 
даже если значения принадлежат разным типам (например, 1 и 1.0).

Пользовательские типы могут переопределять метод __hash__(), результат которого будет использован при вызове hash(). Однако, следует помнить, что функция hash() обрезает значение в соответствии с битностью хоста.


.. code-block:: python

	n = hash("Hello world")
	print(n)
	n = hash("Helloworld")
	print(n)

Как мы видим, изменение всего одного символа очень сильно изменило значение хэш функции.

Для хеширования существует встроенная библиотека hashlib (её не надо устанавливать отдельно).  Кучу примеров применения разных функций можно найти, например, по ссылке  https://www.pythoncentral.io/hashing-strings-with-python/ 


Множество
=========

Множество в языке Python — это структура данных, эквивалентная множествам в математике.
Элементы могут быть различных типов. Порядок элементов не определён.

Действия, которые можно выполнять с множеством:

1. добавлять и удалять элементы,
2. проверять принадлежность элемента множеству,
3. перебирать его элементы,
4. выполнять операции над множествами (объединение, пересечение, разность).

Операция “проверить принадлежность элемента” выполняется в множестве *намного* быстрее, чем в списке.

Элементами множества может быть любой *неизменяемый* тип данных: числа, строки, кортежи.

Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом множества список (вместо этого используйте *неизменяемый* кортеж) или другое множество. Требование неизменяемости элементов множества накладывается особенностями представления множества в памяти компьютера.


Задание множеств
----------------

Множество задается перечислением в фигурных скобках. Например:

.. code-block:: python

	A = {1, 2, 3}

Исключением является пустое множество:

.. code-block:: python

	A = set()       # A -- множество
	D = {}          # D -- не пустое множество, а пустой словарь!

Если функции set передать в качестве параметра список, строку или кортеж, то она вернет множество, составленное из элементов списка, строки, кортежа. Например:

.. code-block:: python

	>>> A = set('qwerty')
	>>> print(A)
	{'e', 'q', 'r', 't', 'w', 'y'}.

Каждый элемент может входить в множество только один раз.

.. code-block:: python

	>>> A = {1, 2, 3}
	>>> B = {3, 2, 3, 1}
	>>> print(A == B) # A и B — равные множества.
	True
	>>> set('Hello')
	{'H', 'e', 'l', 'o'}

Работа с элементами множеств
----------------------------

+----------------+----------------------------------------------------------------------------+
| Операция       | Значение                                                                   |
+================+============================================================================+
| `x in A`       | принадлежит ли элемент `x` множеству `A` (возвращают значение типа `bool`) |
+----------------+----------------------------------------------------------------------------+
| `x not in A`   | то же, что `not x in A`                                                    |
+----------------+----------------------------------------------------------------------------+
| `A.add(x)`     | добавить элемент `x` в множество `A`                                       |
+----------------+----------------------------------------------------------------------------+
| `A.discard(x)` | удалить элемент `x` из множества `A`                                       |
+----------------+----------------------------------------------------------------------------+
| `A.remove(x)`  | удалить элемент `x` из множества `A`                                       |
+----------------+----------------------------------------------------------------------------+
| `A.pop()`      | удаляет из множества один случайный элемент и возвращает его               |
+----------------+----------------------------------------------------------------------------+

Поведение `discard` и `remove` различается тогда, когда удаляемый элемент *отсутствует* в множестве:
`discard` не делает ничего, а метод remove генерирует исключение `KeyError`.
Метод `pop` также генерирует исключение `KeyError`, если множество пусто.

При помощи цикла for можно перебрать все элементы множества:

.. code-block:: python

	Primes = {2, 3, 5, 7, 11}
	for num im Primes:
	    print(num)

Из множества можно сделать список при помощи функции `list`:

.. code-block:: python

	>>> A = {1, 2, 3, 4, 5}
	>>> B = list(A)
	[1, 2, 3, 4, 5]




Упражнение №1
+++++++++++++

Вывести на экран все элементы множества A, которых нет в множестве B.

.. code-block:: python

	A = set('bqlpzlkwehrlulsdhfliuywemrlkjhsdlfjhlzxcovt')
	B = set('zmxcvnboaiyerjhbziuxdytvasenbriutsdvinjhgik')
	for x in A:
	    ...


Операции с множествами, обычные для математики
----------------------------------------------

+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| Операция                             | Значение                                                                                                             |
+======================================+======================================================================================================================+
|                                      |                                                                                                                      |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A | B`                            |                                                                                                                      |
| | `A.union(B)`                       | Возвращает множество, являющееся объединением множеств A и B.                                                        |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A | = B`                          |                                                                                                                      |
| | `A.update(B)`                      | Записывает в A объединение множеств A и B.                                                                           |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A & B`                            |                                                                                                                      |
| | `A.intersection(B)`                | Возвращает множество, являющееся пересечением множеств A и B.                                                        |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A &= B`                           |                                                                                                                      |
| | `A.intersection_update(B)`         | Записывает в A пересечение множеств A и B.                                                                           |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A - B`                            |                                                                                                                      |
| | `A.difference(B)`                  | Возвращает разность множеств A и B (элементы, входящие в A, но не входящие в B).                                     |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A -= B`                           |                                                                                                                      |
| | `A.difference_update(B)`           | Записывает в A разность множеств A и B.                                                                              |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A ^ B`                            |                                                                                                                      |
| | `A.symmetric_difference(B)`        | Возвращает симметрическую разность множеств A и B (элементы, входящие в A или в B, но не в оба из них одновременно). |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A ^= B`                           |                                                                                                                      |
| | `A.symmetric_difference_update(B)` | Записывает в A симметрическую разность множеств A и B.                                                               |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A <= B`                           |                                                                                                                      |
| | `A.issubset(B)`                    | Возвращает true, если A является подмножеством B.                                                                    |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A >= B`                           |                                                                                                                      |
| | `A.issuperset(B)`                  | Возвращает true, если B является подмножеством A.                                                                    |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A < B`                            | Эквивалентно A <= B and A != B                                                                                       |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+
| | `A > B`                            | Эквивалентно A >= B and A != B                                                                                       |
+--------------------------------------+----------------------------------------------------------------------------------------------------------------------+

Упражнение №2
+++++++++++++

Даны четыре множества:

.. code-block:: python

	A = set('0123456789')
	B = set('02468')
	C = set('12345')
	D = set('56789')

Найти элементы, принадлежащие множеству `E`:

.. image:: /algo/images/lab22/ex2_formula.png

..	E = ((A setminus B) intersection (C setminus D )) union ((D setminus A) intersection (B setminus C ))
	LibreOffice Math formula


Словарь (ассоциативный массив)
==============================

В массиве или в списке индекс - это целое число.
Традиционной является следующая ситуация:

.. code-block:: python

	>>> Days = ['Sunday', 'Monday', 'Tuesday', 'Wednessday', 'Thursday', 'Friday', 'Saturday']
	>>> Days[0]
	'Sunday'
	>>> Days[1]
	'Monday'

А как реализовать обратное соответствие?

.. code-block:: python

	>>> Days['Sunday']
	0
	>>> Days['Monday']
	1

При помощи списка или массива это сделать невозможно, нужно использовать **ассоциативный массив** или **словарь**.

В словаре индекс может быть *любого неизменяемого типа*! Индексы, как и сами хранимые значения, задаются явно:

.. code-block:: python

	Days = {
	    'Sunday': 0,
	    'Monday': 1,
	    'Tuesday': 2,
	    'Wednessday': 3,
	    'Thursday': 4,
	    'Friday': 5,
	    'Saturday': 6
	}
	>>> Days['Sunday']
	0
	>>> Days['Monday']
	1
	>>> Days['Yesterday']
	Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	KeyError: 'Yesterday'

При попытке обратиться к несуществующему элементу ассоциативного массива мы получаем исключение `KeyError`.

Особенностью ассоциативного массива является его динамичность: в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие элементы.

.. code-block:: python

	>>> Days['Yesterday'] = -1
	>>> print(Days['Yesterday'])
	-1

При этом размер используемой памяти пропорционален размеру ассоциативного массива. Доступ к элементам ассоциативного массива выполняется хоть и медленнее, чем к обычным массивам, но в целом довольно быстро.

Значения ключей `уникальны`, двух одинаковых ключей в словаре быть не может. А вот значения могут быть одинаковыми.

.. code-block:: python

	>>> Days['Tomorrow'] = -1
	>>> Days['Yesterday'] == Days['Tomorrow']
	True

Ключом может быть произвольный *неизменяемый* тип данных: целые и действительные числа, строки, кортежи. Ключом в словаре не может быть множество, но может быть элемент типа frozenset: специальный тип данных, являющийся аналогом типа set, который нельзя изменять после создания. Значением элемента словаря может быть *любой* тип данных, в том числе и изменяемый.

Создание словаря
----------------

Пустой словарь можно создать при помощи функции `dict()` или пустой пары фигурных скобок `{}` (вот почему фигурные скобки нельзя использовать для создания пустого множества).

Для создания словаря с некоторым набором начальных значений можно использовать следующие конструкции:

.. code-block:: python

	Capitals = {'Russia': 'Moscow', 'Ukraine': 'Kiev', 'USA': 'Washington'}
	Capitals = dict(Russia = 'Moscow', Ukraine = 'Kiev', USA = 'Washington')
	Capitals = dict([("Russia", "Moscow"), ("Ukraine", "Kiev"), ("USA", "Washington")])
	Capitals = dict(zip(["Russia", "Ukraine", "USA"], ["Moscow", "Kiev", "Washington"]))

Также можно использовать генерацию словаря через Dict comprehensions:

.. code-block:: python

	Cities = ["Moscow", "Kiev", "Washington"]
	States = ["Russia", "Ukraine", "USA"]
	CapitalsOfState = {state: city for city, state in zip(Cities, States)}

Это особенно полезно, когда нужно "вывернуть" словарь наизнанку:

.. code-block:: python

	StateByCapital = {CapitalsOfState[state]: state for state in CapitalsOfState}

Операции с элементами словарей
------------------------------

+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| Операция                              | Значение                                                                                                        |
+=======================================+=================================================================================================================+
|   `value = A[key]`                    | Получение элемента по ключу. Если элемента с заданным ключом в словаре нет, то возникает исключение `KeyError`. |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `value = A.get(key)`                | Получение элемента по ключу. Если элемента в словаре нет, то `get` возвращает `None`.                           |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `value = A.get(key, default_value)` | То же, но вместо `None` метод `get` возвращает `default_value`.                                                 |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `key in A`                          | Проверить принадлежность *ключа* словарю.                                                                       |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `key not in A`                      | То же, что not key in A.                                                                                        |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `A[key] = value`                    | Добавление нового элемента в словарь.                                                                           |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `del A[key]`                        | Удаление пары ключ-значение с ключом key. Возбуждает исключение KeyError, если такого ключа нет.                |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| | `if key in A:`                      | Удаление пары ключ-значение с предварительной проверкой наличия ключа.                                          |
| |     `del A[key]`                    |                                                                                                                 |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| | `try:`                              | Удаление пары ключ-значение с перехватыванием и обработкой исключения.                                          |
| |     `del A[key]`                    |                                                                                                                 |
| | `except KeyError:`                  |                                                                                                                 |
| |     `pass`                          |                                                                                                                 |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| | `value = A.pop(key)`                | | Удаление пары ключ-значение с ключом `key` и возврат значения удаляемого элемента.                            |
|                                       | | Если такого ключа нет, то возбуждается `KeyError`.                                                            |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `value = A.pop(key, default_value)` | То же, но вместо генерации исключения возвращается `default_value`.                                             |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `A.pop(key, None)`                  | Это позволяет проще всего организовать безопасное удаление элемента из словаря.                                 |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|   `len(A)`                            | Возвращает количество пар *ключ-значение*, хранящихся в словаре.                                                |
+---------------------------------------+-----------------------------------------------------------------------------------------------------------------+

Перебор элементов словаря по ключу
----------------------------------

.. code-block:: python

	for key in A:
	    print(key, A[key])


Представления элементов словаря
-------------------------------

Представления во многом похожи на списки, но они остаются связанными со своим исходным словарём и изменяются, если менять значения элементов словаря.

* Метод `keys` возвращает представление ключей всех элементов.
* Метод `values` возвращает представление всех значений.
* Метод `items` возвращает представление всех пар (кортежей) из ключей и значений. 

.. code-block:: python

	>>> A = dict(a='a', b='b', c='c')
	>>> k = A.keys()
	>>> v = A.values()
	>>> k, v
	(dict_keys(['c', 'b', 'a']), dict_values(['c', 'b', 'a']))
	>>> A['d'] = 'a'
	>>> k, v
	(dict_keys(['d', 'c', 'b', 'a']), dict_values(['a', 'c', 'b', 'a']))

Учтите, что итерироваться по представлениям изменяя словарь нельзя

.. code-block:: python

	>>> for key in A.keys():
	...     del A[key]
	...
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	RuntimeError: dictionary changed size during iteration

Можно, если в начале скопировать представление в список

.. code-block:: python

        >>> for key in list(A.keys()):
        ...     del A[key]
        ...
        >>> A
        {}

Пример использования словаря
----------------------------

.. code-block:: python

	# Создадим пустой словать Capitals
	Capitals = dict()

	# Заполним его несколькими значениями
	Capitals['Russia'] = 'Moscow'
	Capitals['Ukraine'] = 'Kiev'
	Capitals['USA'] = 'Washington'

	# Считаем название страны
	print('В какой стране вы живете?')
	country = input()

	# Проверим, есть ли такая страна в словаре Capitals
	if country in Capitals:
	    # Если есть - выведем ее столицу
	    print('Столица вашей страны', Capitals[country])
	else:
	    # Запросим название столицы и добавим его в словарь
	    print('Как называется столица вашей страны?')
	    city = input()
	    Capitals[country] = city

Когда нужно использовать словари
--------------------------------

Словари нужно использовать в следующих случаях:

* Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключами являются объекты, а значениями — их количество.
* Хранение каких-либо данных, связанных с объектом. Ключи — объекты, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря `Num['January'] = 1; Num['February'] = 2; ...`
* Установка соответствия между объектами (например, “родитель—потомок”). Ключ — объект, значение — соответствующий ему объект.
* Если нужен обычный массив, но при этом масимальное значение индекса элемента очень велико, но при этом будут использоваться не все возможные индексы (так называемый “разреженный массив”), то можно использовать ассоциативный массив для экономии памяти. 

Практическая работа по использованию словарей
=============================================

Упражнение №3. Подсчет слов
---------------------------

Дан текст на некотором языке. Требуется подсчитать, сколько раз каждое слово входит в этот текст, и вывести десять
самых часто употребяемых слов в этом тексте и количество их употреблений.

В качестве примера возьмите файл с текстом лицензионного соглашения Python `/usr/share/licenses/python/LICENSE`.

Подсказка №1: Используйте словарь, в котором ключ -- слово, а знчение -- количество таких слов.

Подсказка №2: Точки, запятые, вопросы и восклицательные знаки перед обработкой замените пробелами(используйте `punctuation <https://docs.python.org/2/library/string.html#string.punctuation>`_ из модуля string).

Подсказка №3: Все слова приводите к нижнему регистру при помощи метода строки `lower()`.

Подсказка №4: По окончании сбора статистики нужно пробежать по всем ключам из словаря и найти ключ с максимальным значением.

Упражнение №4. Перевод текста
-----------------------------

Дан словарь `task4/en-ru.txt`_ с однозначным соответствием английских и русских слов в таком формате:

	cat	-	кошка

	dog	-	собака

	mouse	-	мышь

	house	-	дом

	eats	-	ест

	in	-	в

	too	-	тоже

.. _`task4/en-ru.txt`: /algo/extra/lab22/task4/en-ru.txt

Здесь английское и русское слово разделены двумя табуляциями и минусом: `'\t-\t'`.

В файле `task4/input.txt`_ дан текст для перевода, например:

|    Mouse in house. Cat in house.
|    Cat eats mouse in dog house.
|    Dog eats mouse too.

Требуется сделать подстрочный перевод с помощью имеющегося словаря и вывести результат в `output.txt`.
Незнакомые словарю слова нужно оставлять в исходном виде.

.. _`task4/input.txt`: /algo/extra/lab22/task4/input.txt

Упражнение №5. Страны и Языки
-----------------------------

Дан список стран и языков на которых говорят в этой стране в формате `<Название Страны> : <язык1> <язык2> <язык3> ...` в файле `task5/input.txt`_. На ввод задается N - длина списка и список языков. Для каждого языка укажите, в каких странах на нем говорят.

+-----------------+-----------------+
| Ввод            | Вывод           |
+=================+=================+
| 3               |                 |
+-----------------+-----------------+
| азербайджанский | Азербайджан     |
+-----------------+-----------------+
| греческий       | Кипр Греция     |
+-----------------+-----------------+
| китайский       | Китай Сингапур  |
+-----------------+-----------------+

.. _`task5/input.txt`: /algo/extra/lab22/task5/input.txt

Упражнение №6. Сделать русско-английский словарь
------------------------------------------------
В файле `task6/en-ru.txt`_ находятся строки англо-русского словаря в таком формате:

|    cat	-	кошка
|    dog	-	собака
|    home	-	домашняя папка, дом
|    mouse	-	мышь, манипулятор мышь
|    to do	-	делать, изготавливать
|    to make	-	изготавливать

Здесь английское слово (выражение) и список русских слов (выражений) разделены двумя табуляциями и минусом: `'\t-\t'`.

Требуется создать русско-английский словарь и вывести его в файл `ru-en.txt` в таком формате:

|    делать	-	to do
|    дом 	-	home
|    домашняя папка	-	home
|    изготавливать	-	to do, to make
|    кошка	-	cat
|    манипулятор мышь	-	mouse
|    мышь	-	mouse
|    собака	-	dog

Порядок строк в выходном файле должен быть словарным с *человеческой* точки зрения (так называемый *лексикографический* порядок слов). То есть выходные строки нужно отсортировать.

.. _`task6/en-ru.txt`: /algo/extra/lab22/task6/en-ru.txt

Упражнение №7. Синхронизация словарей
-------------------------------------

Даны два файла словарей: `task7/en-ru.txt`_ и `task7/ru-en.txt`_ (в формате, описанном в упражнении №6).

en-ru.txt:

|    home	-	домашняя папка
|    mouse	-	манипулятор мышь

ru-en.txt:

|    дом 	-	home
|    мышь	-	mouse

Требуется синхронизировать и актуализировать их содержимое. 

en-ru.txt:

|    home	-	домашняя папка, дом
|    mouse	-	манипулятор мышь, мышь

ru-en.txt:

|    дом 	-	home
|    домашняя папка 	-	home
|    манипулятор мышь	-	mouse
|    мышь	-	mouse

.. _`task7/en-ru.txt`: /algo/extra/lab22/task7/en-ru.txt
.. _`task7/ru-en.txt`: /algo/extra/lab22/task7/ru-en.txt

Упражнение №8. Добродушные соседи
---------------------------------

В одном очень дружном доме, где живет Фёдор, многие жильцы оставляют ключи от квартиры соседям по дому, например на случай пожара или потопа, да и просто чтобы покормили животных или полили цветы.

Вернувшись домой после долгих странствий, Фёдор обнаруживает, что потерял свои ключи и соседей дома нет. Но вдруг у домофона он находит чужие ключи. Помогите Федору найти ключи от своей квартиры в квартирах соседей.

На ввод подается файл `task8/input.txt`_, в котором в первой строке записано три числа через пробел N - номер квартиры Фёдора, M - номер квартиры от которой Федор нашел ключи, K - ключ от этой квартиры. Далее i-я строка хранит описание ключей запертых в i-й квартире в формате `<m_i0 - номер квартиры> <k_i0 - ключ>,<m_i1 - номер квартиры> <k_i1 - ключ>,...` , причем реальные номера квартир "зашифрованы" ключем от i-й квартиры(Ki) и находятся по формуле m_ij' = m_ij - Ki. Номера квартир начинаются с 0 (к примеру вторая строка файла соответствует 0-й квартире).

Нужно вывести ключ от квартиры Федора или None, если его найти не получилось. Например:

+-----------------+-------+
| Ввод            | Вывод |
+=================+=======+
| 4 0 1           | 1     |
+-----------------+-------+
| 1 1,2 0,3 1,4 0 |       |
+-----------------+-------+
| 3 0             |       |
+-----------------+-------+
| 5 1,6 0         |       |
+-----------------+-------+
| 1 1             |       |
+-----------------+-------+
| 2 1             |       |
+-----------------+-------+

Подсказка: используйте словарь для хранения ключей от еще не открытых комнат и множество для уже проверенных комнат.

.. _`task8/input.txt`: /algo/extra/lab22/task8/input.txt
