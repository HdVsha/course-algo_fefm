Скрипты командной строки Linux
##############################

:date: 2018-09-16 09:00
:summary: Скрипты командной строки Linux.


.. default-role:: code

Переменные окружения
====================

Переменные окружения в Linux набор пар ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ, которые могут использоваться программами во время выполнения. Удобно, когда программа "угадывает" имя пользователя или домашний каталог пользователя. Чаще всего такая информация "добывается" из переменных окружения USER и HOME соответственно.
Переменные могут определяться системой и пользователем. Системные переменные окружения Linux определяются системой и используются программами системного уровня. Пользовательские переменные окружения устанавливаются пользователем, для текущей оболочки, временно или постоянно. Переменные окружения могут формироваться как из заглавных, так и из строчных символов, однако исторически сложилось именовать их в верхнем регистре. Значение каждой переменной окружения изначально представляет собой строковую константу (строку). 

Командные оболочки, такие как bash, располагают собственным набором пар ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ - это переменные оболочки. Набор таких переменных называют окружением (или средой) оболочки. Эти переменные чем-то напоминают локальные переменные в языке C. Они недоступны для других программ и используются в основном в сценариях оболочки. Чтобы задать переменную оболочки, достаточно написать в командной строке ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ.

Для того, чтобы посмотреть список переменных, определенных в текущей оболочке запустите в терминале команду `set`:

 .. code-block:: bash

	[user@comp ~]$ set | less
	BASH=/bin/bash
	BASH_ALIASES=()
	BASH_ARGC=()
	BASH_ARGV=()
	BASH_CMDS=()
	BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
	BASH_LINENO=()
	BASH_REMATCH=()
	BASH_SOURCE=()
	BASH_VERSINFO=([0]="4" [1]="3" [2]="48" [3]="1" [4]="release" [5]="i686-pc-linux-gnu")
	BASH_VERSION='4.3.48(1)-release'
	CLUTTER_IM_MODULE=xim
	COLUMNS=168
	COMP_WORDBREAKS=$' \t\n"\'><;|&(:'
	DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-ieTFEcTTRm
	DEFAULTS_PATH=/usr/share/gconf/gnome.default.path
	DERBY_HOME=/usr/lib/jvm/java-8-oracle/db
	DESKTOP_SESSION=gnome
	DIRSTACK=()
	DISPLAY=:0
	EUID=1000
	GDMSESSION=gnome
	GDM_LANG=en
	GJS_DEBUG_OUTPUT=stderr
	GJS_DEBUG_TOPICS='JS ERROR;JS LOG'
	GNOME_DESKTOP_SESSION_ID=this-is-deprecated
	GNOME_KEYRING_CONTROL=
	...............
	[user@comp ~]$


Чтобы посмотреть список переменных, доступных другим программам, запустим `env`: 

.. code-block:: bash

	[user@comp ~]$ env | less
	XDG_VTNR=7
	XDG_SESSION_ID=c2
	CLUTTER_IM_MODULE=xim
	XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/user
	COMP_WORDBREAKS=        
	"'><;|&(:
	SESSION=gnome
	GPG_AGENT_INFO=/home/user/.gnupg/S.gpg-agent:0:1
	SHELL=/bin/bash
	TERM=xterm-256color
	XDG_MENU_PREFIX=gnome-
	VTE_VERSION=4205
	DERBY_HOME=/usr/lib/jvm/java-8-oracle/db
	QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1
	GJS_DEBUG_OUTPUT=stderr
	WINDOWID=46137354
	[user@comp ~]$

Другими словами отличие команды `env` от команды `set` заключается в том, что команда `set` выводит список всех переменных окружения, включая те переменные, которые не экспортируются в дочерние командные оболочки.

Чтобы добавить переменную в окружение, нужно исполнить конструкцию ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ:

.. code-block:: bash

	[user@comp ~]$ LOCAL_VAR="Hello World"
	[user@comp ~]$ echo $LOCAL_VAR
	Hello World
	[user@comp ~]$ env | grep LOCAL_VAR
	[user@comp ~]$ set | grep LOCAL_VAR
	'Hello World'
	[user@comp ~]$

Однако, при желании, можно включить локальную переменную оболочки в основное окружение. Для этого используется команда `export`:

.. code-block:: bash

	[user@comp ~]$ export LOCAL_VAR
	[user@comp ~]$ env | grep LOCAL_VAR
	LOCAL_VAR=Hello World
	[user@comp ~]$

Можно сделать сразу так:

.. code-block:: bash

	[user@comp ~]$ export ENV_VAR=Bye
	[user@comp ~]$ echo $ENV_VAR
	Goodbye
	[user@comp ~]$ env | grep ENV_VAR
	ENV_VAR=Bye
	[user@comp ~]$

Интерпретация значений переменных полностью возлагается на программу. Чтобы вывести на экран значение какой-нибудь переменной окружения, достаточно набрать `echo $ИМЯ_ПЕРЕМЕННОЙ`:

.. code-block:: bash

	[user@comp ~]$ echo $USER
	user
	[user@comp ~]$ 

По умолчанию с помощью `env` можно посмотреть все установленные переменные среды. Но с опцией `-i` она позволяет временно удалить все переменные оболочки и выполнить команду без переменных.

.. code-block:: bash

	[user@comp ~]$ env –i [Var=Value] <команда>

Var — это любая переменная, которую вы хотите передать этой команде.

Например, такая команда запустит оболочку вообще без переменных окружения:

.. code-block:: bash

	[user@comp ~]$ env –i bash


После запуска такого окружения, не будет доступно никаких переменных, но после выхода все вернется на свои места.

Существует другой способ удаления переменных окружения Linux - команда unset, удаляет переменную по имени до конца текущей сессии:

.. code-block:: bash

	unset имя_переменной

Например:

.. code-block:: bash

	[user@comp ~]$ export ENV_VAR=Bye
	[user@comp ~]$ echo $ENV_VAR
	Goodbye
	[user@comp ~]$ env | grep ENV_VAR
	ENV_VAR=Bye
	[user@comp ~]$ unset ENV_VAR
	[user@comp ~]$ env | grep ENV_VAR
	[user@comp ~]$


PATH
----

В Linux `$PATH` — это переменная среды, используемая для указания оболочке, где искать исполняемые файлы. `$PATH` обеспечивает большую гибкость и безопасность для систем Linux, и, безусловно, можно сказать, что это одна из самых важных переменных среды.

Программы/скрипты, расположенные в каталоге `$PATH`, могут быть выполнены непосредственно в вашей оболочке без указания полного пути к ним. Посмотрим текущее значение `$PATH`: 

.. code-block:: bash

	[user@comp ~]$ echo $PATH
	/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games/
	[user@comp ~]$ 

В результате выводится список каталогов, разделенных двоеточиями. При осуществлении поиска оболочка просматривает каталоги именно в том порядке, как они перечислены в переменной `PATH`. Чтобы добавить новую директорию необходимо выполнить команду:

.. code-block:: bash

	[user@comp ~]$ PATH=$PATH:<путь к директории>
	или
	[user@comp ~]$ PATH=<путь к директории>:$PATH

В первом случае поиск в добавленной директории будет происходить в последнюю очередь (только если запускаемый файл не найден в директориях, перечисленных в исходном значении `$PATH`), во втором случае - сначала в добавленной директории, а потом в исходном значении `$PATH`.
Отметим, что можно включить в этот список и текущий каталог, добавив в переменную `PATH` точку. Однако этого не рекомендуется делать по соображениям безопасности: злоумышленник может положить в общедоступный каталог команду, имя которой совпадает с одной из часто выполняемых суперпользователем команд, но выполняющую совершенно другие действия (особенно если текущий каталог стоит в начале перечня путей поиска).


Профиль пользователя, права доступа
===================================


Для входа в операционную систему UNIX каждый пользователь должен быть зарегистрирован в ней под определенным именем.  Все пользователи в системе делятся на группы пользователей. Например, все студенты одной учебной группы могут составлять свою собственную группу пользователей. Группы пользователей также получают свои имена.
Для получания информации об активных пользователях сущестует несколько команд:

#. `users` - выводит информацию о пользователях, подключенных к системе данный момент.
#. `w` - список пользователей, подключенных к системе: виртуальный терминал, с которого работает пользователь; время входа в систему для каждого пользователя, статистику использования системы (IDLE - время простоя, JCPU - использование процессора), выполняемые каждым пользователем задачи.
#. `who` - список пользователей, подключенных к системе; время и дату входа каждого пользователя.
#. `whoami` - имя пользования, который ввел команду. 
#. `ps` - выдает информацию об активных процессах. По умолчанию информация дается только о процессах, ассоциированных с данным терминалом. Выводятся идентификатор процесса, идентификатор терминала, истраченное к данному моменту время ЦП и имя команды. Если нужна иная информация, следует вопользоваться опцией `-e`.


Для каждого файла, созданного в файловой системе запоминаются имена его хозяина и группы хозяев. Заметим, что группа хозяев не обязательно должна быть группой, в которую входит хозяин. В операционной системе Linux при создании файла его хозяином становится пользователь, создавший файл, а его группой хозяев - группа, к которой он принадлежит. Впоследствии хозяин файла или системный администратор может передать его в собственность другому пользователю или изменить его группу хозяев с помощью команд `chown` и `chgrp`, описание которых можно найти в UNIX Manual.

Таким образом, для каждого файла выделяется три категории пользователей: 

#. Пользователь, являющийся хозяином файла.

#. Пользователи, относящиеся к группе хозяев файла.

#. Все остальные пользователи.


Для каждой из этих категорий пользователей владелец файла может определить различные права доступа к файлу, используя команду `chmod`. Различают три вида прав доступа: право на чтение файла - r(read), право на модификацию файла - w (write) и право на исполнение файла - x (execute). Для регулярных файлов смысл этих прав совпадает с указанным выше. Для директорий он несколько меняется. Право чтения для каталогов позволяет читать имена файлов, находящихся в этом каталоге (и только имена). Поскольку "исполнять" директорию бессмысленно (как, впрочем, и не исполняемый регулярный файл) право доступа на исполнение для директорий меняет смысл: наличие этого права позволяет получить дополнительную информацию о файлах, входящих в каталог: их размер, кто их хозяин, дата создания и т.д. Право на исполнение также требуется для директории, чтобы сделать ее текущей, а также для всех директорий по пути к указанной. Право записи для директории позволяет изменять ее содержимое: создавать и удалять в ней файлы, переименовывать их. Отметим, что для удаления файла достаточно иметь право записи для директории, в которую непосредственно входит данный файл, независимо от прав доступа к самому файлу. 

chmod
-----

.. code-block:: bash

	[user@comp ~]$ chmod опции права <путь к файлу>

Существует два способа задания прав символьный и числовой. В числовом виде файлу или каталогу устанавливаются абсолютные права, в то же время в символьном виде можно изменить отдельные права для разных типов пользователей.

В символьном виде опции описывают операции, которые нужно совершить над правами пользователей и имеют вид [references][operator][modes].

References определяют пользователей, которым будут меняться права. References определяются одной или несколькими буквами:

#. u (user) - Владелец файла
#. g (group) - Пользователи, входящие в группу владельца файла
#. o (others) - Остальные пользователи
#. a (all) - Все пользователи (или ugo)


Operator определяет операцию, которую будет выполнять `chmod`:

#. \+ - добавить определенные права
#. \- - удалить определенные права
#. = - установить определенные права

Modes определяет какие именно права будут установлены, добавлены или удалены:

#. r (read) -чтение файла или содержимого каталога
#. w (write) - запись в файл или в каталог
#. x (execute) - выполнение файла или чтение содержимого каталога

Например:

Установить права на чтение и выполнение для владельца файла, удалить права на выполнение у группы, удалить права на запись и выполнение у остальных пользователей:

.. code-block:: bash

	[user@comp ~]$ chmod u+rx,g-x,o-wx <filename>

В числовом виде, права задаются в виде трехзначного числа, каждая цифра которого задает права файла для определенной категории пользователей - первая для владельца, вторая - группы, третья - остальных.

Варианты записи прав пользователя

+----------+--------------+------------+
| двоичная | восьмеричная | символьная |
+----------+--------------+------------+
| 000      | 0            | ---        |
+----------+--------------+------------+
| 001      | 1            | --x        |
+----------+--------------+------------+
| 010      | 2            | -w-        |
+----------+--------------+------------+
| 011      | 3            | -wx        |
+----------+--------------+------------+
| 100      | 4            | r--        |
+----------+--------------+------------+
| 101      | 5            | r-x        |
+----------+--------------+------------+
| 110      | 6            | rw-        |
+----------+--------------+------------+
| 111      | 7            | rwx        |
+----------+--------------+------------+


Таким образом, `chmod 755 filename` означает права `rwxr-xr-x`:

+-------------------------------+----------+--------+-----------+
|                               | владелец | группа | остальные |
+===============================+==========+========+===========+
| восьмеричное значение         | 7        | 5      | 5         |
+-------------------------------+----------+--------+-----------+
| символьная запись             | rwx      | r-x    | r-x       |
+-------------------------------+----------+--------+-----------+
| обозначение типа пользователя | u        | g      | o         |
+-------------------------------+----------+--------+-----------+

Распространенные значения:

400 (-r--------). Владелец имеет право чтения; никто другой не имеет права выполнять никакие действия.

644 (-rw-r--r--). Все пользователи имеют право чтения; владелец может редактировать.

660 (-rw-rw----). Владелец и группа могут читать и редактировать; остальные не имеют права выполнять никаких действий.

664 (-rw-rw-r--). Все пользователи имеют право чтения; владелец и группа могут редактировать.

666 (-rw-rw-rw-). Все пользователи могут читать и редактировать.

700 (-rwx------). Владелец может читать, записывать и запускать на выполнение; никто другой не имеет права выполнять никакие действия.

744 (-rwxr--r--). Каждый пользователь может читать, владелец имеет право редактировать и запускать на выполнение.

755 (-rwxr-xr-x). Каждый пользователь имеет право читать и запускать на выполнение; владелец может редактировать.

777 (-rwxrwxrwx). Каждый пользователь может читать, редактировать и запускать на выполнение.


foreground и background процессы
--------------------------------

Запущенный процесс в обычном режиме работает в режиме “foreground“, т.е. – “на переднем плане” или, другими словами, “в приоритетном режиме”. В таком режиме он принимает команды с управляющего терминала, в котором он запущен, и на него же выводит информацию `stdout` и `stderr`. Кроме того, он делает недоступным командную строку.

Что бы запустить задачу в фоновом режиме – в конце команды необходимо добавить знак &, например:


.. code-block:: bash

	[user@comp ~]$ tar cpf usr.lib.tar usr/lib 2>/dev/null &
	[1] 55887
	[user@comp ~]$

Отобразить список текущих фоновых задач можно командой `jobs`, например:

.. code-block:: bash

	[user@comp ~]$  jobs
	[6]-  Stopped                 top
	[7]+  Stopped                 tar


Второй способ – запустить её в обычном режиме, после чего нажать комбинацию ctrl+Z. После этого – она появится в списке jobs с новым номером:

.. code-block:: bash

	[user@comp ~]$ tar cpf usr.lib.tar usr/lib 2>/dev/null
	^Z
	[2]+  Stopped                 tar cpf usr.lib.tar usr/lib 2>/dev/null &
	[user@comp ~]$


Теперь, что бы продолжить её выполнение в фоновом режиме – введите команду `bg` (background):

.. code-block:: bash

	[user@comp ~]$ bg
	[2]+      tar cpf usr.lib.tar usr/lib 2>/dev/null &


Команда `jobs` всегда вызывается без аргументов и показывает задания, запущенные из текущего экземпляра оболочки. В начале каждой строки вывода этой команды указывается порядковый номер задания в виде числа в квадратных скобках. После номера указывается состояние процесса: stopped (остановлен), running (выполняется) или suspended (приостановлен). В конце строки указывается команда, которая исполняется данным процессом. Один из номеров выполняющихся заданий помечен знаком +, а еще один — знаком -. Процесс, помеченный знаком +, будет по умолчанию считаться аргументом команд `fg` или `bg`, если они вызываются без параметров. Процесс, помеченный знаком -, получит знак +, если только завершится по какой-либо причине процесс, который был помечен знаком +.

Что бы вывести задачу из фонового режима – используется команда `fg` (foreground), которой можно либо передать номер задачи в качестве аргумента, либо – запустить без аргументов. В последнем случае – будет выведена задача, отмеченная знаком + в списке jobs, т.е. – последняя отправленная “в фон” задача.

Например, команда (в случае если `top` находится в фоновом режиме с номером задачи 6) :

.. code-block:: bash

	[user@comp ~]$ fg 6


Вернёт на экран утилиту `top` и переведёт её в режим Running.



Cигналы и команда kill
----------------------

Сигналы — это средство, с помощью которого процессам можно передать сообщения о некоторых событиях в системе. Сами процессы тоже могут генерировать сигналы, с помощью которых они передают определенные сообщения ядру и другим процессам. С помощью сигналов можно осуществлять такие акции управления процессами, как приостановка процесса, запуск приостановленного процесса, завершение работы процесса. Всего в Linux существует 63 разных сигнала, их перечень можно посмотреть по команде

.. code-block:: bash

	[user@comp ~]$ kill –l

Сигналы принято обозначать номерами или символическими именами. Все имена начинаются на SIG, но эту приставку иногда опускают: например, сигнал с номером 1 обозначают или как SIGHUP, или просто как HUP.

Когда процесс получает сигнал, то возможен один из двух вариантов развития событий. Если для данного сигнала определена подпрограмма обработки, то вызывается эта подпрограмма. В противном случае ядро выполняет от имени процесса действие, определенное по умолчанию для данного сигнала. Вызов подпрограммы обработки называется перехватом сигнала. Когда завершается выполнение подпрограммы обработки, процесс возобновляется с той точки, где был получен сигнал.

Можно заставить процесс игнорировать или блокировать некоторые сигналы. Игнорируемый сигнал просто отбрасывается процессом и не оказывает на него никакого влияния. Блокированный сигнал ставится в очередь на выдачу, но ядро не требует от процесса никаких действий до разблокирования сигнала. После разблокирования сигнала программа его обработки вызывается только один раз, даже если в течение периода блокировки данный сигнал поступал несколько раз.

Списрк некоторых из часто встречающихся сигналов.

+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| №  | Имя  | Описание                                                                                                                                                                                                      | Можно перехватывать | Можно блокировать | Комбинация клавиш    |
+====+======+===============================================================================================================================================================================================================+=====================+===================+======================+
| 1  | HUP  | Cигнал, посылаемый процессу для уведомления о потере соединения с управляющим терминалом пользователя                                                                                                         | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 2  | INT  | Interrupt. В случае выполнения простых команд вызывает прекращение выполнения, в интерактивных программах — прекращение активного процесса                                                                    | Да                  | Да                | <Ctrl>+<C> или <Del> |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 3  | QUIT | Сигнал, для остановки процесса пользователем. Также указывает, что система должна выполнить дамп памяти для процесса                                                                                          | Да                  | Да                | <Ctrl>+<\>           |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 4  | ILL  | Illegal Instruction. Центральный процессор столкнулся с незнакомой командой (в большинстве случаев это означает, что допущена программная ошибка). Сигнал отправляется программе, в которой возникла проблема | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 8  | FPE  | Floating Point Exception. Вычислительная ошибка, например, деление на ноль                                                                                                                                    | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 9  | KILL | Всегда прекращает выполнение процесса                                                                                                                                                                         | Нет                 | Нет               |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 11 | SEGV | Segmentation Violation. Доступ к недозволенной области памяти                                                                                                                                                 | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 15 | TERM | Software Termination. Требование закончить процесс (программное завершение)                                                                                                                                   | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 17 | CHLD | Изменение статуса порожденного процесса                                                                                                                                                                       | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 18 | CONT | Продолжение выполнения приостановленного процесса                                                                                                                                                             | Да                  | Да                |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 19 | STOP | Приостановка выполнения процесса                                                                                                                                                                              | Нет                 | Нет               |                      |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+
| 20 | TSTR | Сигнал останова, генерируемый клавиатурой. Переводит процесс в фоновый режим                                                                                                                                  | Да                  | Да                | <Ctrl>+<Z>           |
+----+------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+-------------------+----------------------+

Как видно из описания, некоторые сигналы можно сгенерировать с помощью определенных комбинаций клавиш. Но такие комбинации существуют не для всех сигналов. Зато имеется команда kill, которая позволяет послать заданному процессу любой сигнал. Как уже было сказано, с помощью этой команды можно получить список всех возможных сигналов, если указать опцию -l. Если после этой опции указать номер сигнала, то будет выдано его символическое имя, а если указать имя, то получим соответствующий номер.

Для посылки сигнала процессу (или группе процессов) можно воспользоваться командой `kill` в следующем формате:

.. code-block:: bash

	[user]$ kill [-сигн] PID [PID..]

где сигн — это номер сигнала, причем если указание сигнала опущено, то посылается сигнал 15 (`TERM` — программное завершение процесса). Чаще всего используется сигнал 9 (`KILL`), с помощью которого суперпользователь может завершить любой процесс. Но сигнал этот очень "грубый", если можно так выразиться, поэтому его использование может привести к нарушению порядка в системе. Поэтому в большинстве случаев рекомендуется использовать сигналы TERM или QUIT, которые завершают процесс более "мягко".

Естественно, что наиболее часто команду `kill` вынужден применять суперпользователь. Он должен использовать ее для уничтожения процессов-зомби, зависших процессов (они показываются в листинге команды `ps` как <exiting>), процессов, которые занимают слишком много процессорного времени или слишком большой объем памяти и т. д. 


Самостоятельная работа
======================

#. Напишите скрипт `hello.sh`, который при запуске печатает на экран строку "Hello world!" и сохраните его на рабочем столе.
#. Модифицируйте переменную окружения `PATH` так, чтобы скрипт `hello.sh` можно было запускать командой `hello.sh` из любой текущей директории.
#. Напишите и запустите скрипт `pause.sh`, содержащий внутри себя команду `sleep 1000` ("заснуть" на 1000 сек).
#. Переведите процесс в фоновый режим одним из способов, описанных выше.
#. Определите PID процесса и отправьте ему сигнал SIGKILL.
