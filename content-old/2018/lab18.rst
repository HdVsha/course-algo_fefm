Одномерные списки, строки, срезы, диапазоны.
############################################

:date: 2019-02-11 09:00
:summary: Одномерные списки, строки, срезы, диапазоны.
:status: published 

.. default-role:: code





Ввод данных: функция `input()`
==============================

 Напишем простую программу, которая требует на ввод два числа и вводит первое из них в степени второго.
 
 Для ввода данных будем использовать функцию `input()`, которая считывает строку с клавиатуры и возвращает значение считанной строки, которое сразу же присвоим переменым `a` и `b`.



.. code-block:: python

   a = input()
   b = input()



Правда, функция `input` возвращает текстовую строку, а нам нужно сделать так, чтобы переменные имели целочисленные
значения. Поэтому сразу же после считывания выполним преобразование типов при помощи фунцкии `int`, и запишем новые
значения в переменные `a` и `b`.  

.. code-block:: python

   a = int(a)
   b = int(b)


Можно объединить считывание строк и преобразование типов, если вызывать функцию `int` для того значения, которое вернет
функция `input`.  



.. code-block:: python

   a = int(input())
   b = int(input())


Далее в программе вычислим значение переменной `c` и выведем результат на экран.

Теперь мы можем не меняя исходного кода программы многократно использовать ее для решения различных задач. Для того
нужно запустить программу и после запуска программы ввести с клавиатуры два числа, нажимая после кажого числа клавишу
`Enter`. Затем программа сама выведет результат.

Вывод данных: функция `print()`
===============================

Функция `print` может выводить не только значения переменных, но и значения любых выражений. Например, допустима запись
`print(2 + 2 ** 2)`. Также при помощи функции `print` можно выводить значение не одного, а нескольких выражений, для
этого нужно перечислить их через запятую:

.. code-block:: python

   a = 1
   b = 2
   print(a, '^', b, '=', a ** b)


Обратите внимание, выводимые значение разделяются одним пробелом. Но такое поведение можно изменить: можно разделять
выводимые значения двумя пробелами, любым другим символом, любой другой строкой, выводить их в отдельных строках или не
разделять никак. Для этого нужно функции `print` передать специальный именованный параметр, называемый `sep`, равный
строке, используемый в качестве разделителя (sep —  аббревиатура от слова separator, т.е. разделитель). По умолчанию
параметр `sep` равен строке из одного пробела и между значениями выводится пробел. Чтобы использовать в качестве
разделителя, например, символ двоеточия нужно передать параметр `sep`, равный строке `':'`:

.. code-block:: python

   print(a, b, a ** b, sep = ':')

Аналогично, для того, чтобы совсем убрать разделитель при выводе нужно передать параметр `sep`, равный пустой строке:

.. code-block:: python

   print(a, '^', b, '=', a ** b, sep = '')

Для того, чтобы значения выводились с новой строке, нужно в качестве параметра `sep` передать строку, состоящую из
специального символа новой строки, которая задается так:

.. code-block:: python

   print(a, b, sep = '\n')

Символ обратного слэша в текстовых строках является указанием на обозначение специального символа, в зависимости
от того, какой символ записан после него. Наиболее часто употребляется символ новой строки `'\n'`.
А для того, чтобы вставить в строку сам символ обратного слэша, нужно повторить его два раза: `'\\'`.

Вторым полезным именованным параметром функции `print` является параметр `end`,
который указывает на то, что выводится после вывода всех значений, перечисленных в функции `print`.
По умолчанию параметр `end` равен `'\n'`, то есть следующий вывод будет происходить
с новой строки. Этот параметр также можно исправить, например, для того, чтобы убрать все дополнительные
выводимые символы можно вызывать функцию `print` так:

.. code-block:: python

   print(a, b, a ** b, sep = '', end = '')
   


Символы. Коды символов
======================

Любой текст состоит из символов. Символ — это некоторый значок, изображение. Один и тот же символ можно записать по-
разному, например, два человека по-разному напишут от руки букву «A», и даже в компьютерном представлении одна и та же
буква будет выглядеть по-разному, если ее отображать разными шрифтами, при этом это будет все равно один и тот же
символ. Верно и другое: разные символы могут быть записаны одинаково, например, вот две разные буквы, одна — латинского
алфавита, другая - русского: «A» и «А». Несмотря на то, что они выглядят одинаково, удобней считать их разными
символами.

Итак, способ хранения текстовой информации в компьютере не связан напрямую с изображением этого текста. Вместо символов
хранятся их номера - числовые коды, а вот то, как выглядит символ с данным числовым кодом на экране напрямую зависит от
того, какой используется шрифт для отображения символов. При этом, разумеется, следовало бы договориться о единообразном
способе кодирования символов числовыми кодами, иначе текст, записанный на одном компьютере, невозможно будет прочитать
на другом компьютере.

Первоначально договорились под кодирование одного символа отвести один байт, то есть 8 бит информации. Таким образом
можно было закодировать 256 различных значений, то есть в записи текста можно использовать 256 различных символов. Этого
достаточно, чтобы отобразить все символы латинского алфавита, цифры, знаки препинания и некоторые другие символы.
Стандарт, указывающий, какие числовые коды соответствуют каким основным символам, называется  ASCII_. В таблицу ASCII
включены символы с кодами от 0 до 127, то есть ASCII - это семибитный код. Вот так выглядит таблица ASCII:

.. _ASCII: http://ru.wikipedia.org/wiki/ASCII

+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| Char  | Dec | Oct  | Hex  | Char | Dec | Oct  | Hex  | Char | Dec | Oct  | Hex  | Char  | Dec | Oct  | Hex  |
+=======+=====+======+======+======+=====+======+======+======+=====+======+======+=======+=====+======+======+
| (nul) | 0   | 0000 | 0x00 | (sp) | 32  | 0040 | 0x20 | @    | 64  | 0100 | 0x40 | \`    | 96  | 0140 | 0x60 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (soh) | 1   | 0001 | 0x01 | !    | 33  | 0041 | 0x21 | A    | 65  | 0101 | 0x41 | a     | 97  | 0141 | 0x61 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (stx) | 2   | 0002 | 0x02 | "    | 34  | 0042 | 0x22 | B    | 66  | 0102 | 0x42 | b     | 98  | 0142 | 0x62 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (etx) | 3   | 0003 | 0x03 | #    | 35  | 0043 | 0x23 | C    | 67  | 0103 | 0x43 | c     | 99  | 0143 | 0x63 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (eot) | 4   | 0004 | 0x04 | $    | 36  | 0044 | 0x24 | D    | 68  | 0104 | 0x44 | d     | 100 | 0144 | 0x64 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (enq) | 5   | 0005 | 0x05 | %    | 37  | 0045 | 0x25 | E    | 69  | 0105 | 0x45 | e     | 101 | 0145 | 0x65 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (ack) | 6   | 0006 | 0x06 | &    | 38  | 0046 | 0x26 | F    | 70  | 0106 | 0x46 | f     | 102 | 0146 | 0x66 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (bel) | 7   | 0007 | 0x07 | '    | 39  | 0047 | 0x27 | G    | 71  | 0107 | 0x47 | g     | 103 | 0147 | 0x67 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (bs)  | 8   | 0010 | 0x08 | (    | 40  | 0050 | 0x28 | H    | 72  | 0110 | 0x48 | h     | 104 | 0150 | 0x68 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (ht)  | 9   | 0011 | 0x09 | )    | 41  | 0051 | 0x29 | I    | 73  | 0111 | 0x49 | i     | 105 | 0151 | 0x69 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (nl)  | 10  | 0012 | 0x0a | \*   | 42  | 0052 | 0x2a | J    | 74  | 0112 | 0x4a | j     | 106 | 0152 | 0x6a |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (vt)  | 11  | 0013 | 0x0b | \+   | 43  | 0053 | 0x2b | K    | 75  | 0113 | 0x4b | k     | 107 | 0153 | 0x6b |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (np)  | 12  | 0014 | 0x0c | ,    | 44  | 0054 | 0x2c | L    | 76  | 0114 | 0x4c | l     | 108 | 0154 | 0x6c |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (cr)  | 13  | 0015 | 0x0d | \-   | 45  | 0055 | 0x2d | M    | 77  | 0115 | 0x4d | m     | 109 | 0155 | 0x6d |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (so)  | 14  | 0016 | 0x0e | .    | 46  | 0056 | 0x2e | N    | 78  | 0116 | 0x4e | n     | 110 | 0156 | 0x6e |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (si)  | 15  | 0017 | 0x0f | /    | 47  | 0057 | 0x2f | O    | 79  | 0117 | 0x4f | o     | 111 | 0157 | 0x6f |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dle) | 16  | 0020 | 0x10 | 0    | 48  | 0060 | 0x30 | P    | 80  | 0120 | 0x50 | p     | 112 | 0160 | 0x70 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc1) | 17  | 0021 | 0x11 | 1    | 49  | 0061 | 0x31 | Q    | 81  | 0121 | 0x51 | q     | 113 | 0161 | 0x71 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc2) | 18  | 0022 | 0x12 | 2    | 50  | 0062 | 0x32 | R    | 82  | 0122 | 0x52 | r     | 114 | 0162 | 0x72 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc3) | 19  | 0023 | 0x13 | 3    | 51  | 0063 | 0x33 | S    | 83  | 0123 | 0x53 | s     | 115 | 0163 | 0x73 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (dc4) | 20  | 0024 | 0x14 | 4    | 52  | 0064 | 0x34 | T    | 84  | 0124 | 0x54 | t     | 116 | 0164 | 0x74 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (nak) | 21  | 0025 | 0x15 | 5    | 53  | 0065 | 0x35 | U    | 85  | 0125 | 0x55 | u     | 117 | 0165 | 0x75 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (syn) | 22  | 0026 | 0x16 | 6    | 54  | 0066 | 0x36 | V    | 86  | 0126 | 0x56 | v     | 118 | 0166 | 0x76 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (etb) | 23  | 0027 | 0x17 | 7    | 55  | 0067 | 0x37 | W    | 87  | 0127 | 0x57 | w     | 119 | 0167 | 0x77 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (can) | 24  | 0030 | 0x18 | 8    | 56  | 0070 | 0x38 | X    | 88  | 0130 | 0x58 | x     | 120 | 0170 | 0x78 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (em)  | 25  | 0031 | 0x19 | 9    | 57  | 0071 | 0x39 | Y    | 89  | 0131 | 0x59 | y     | 121 | 0171 | 0x79 |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (sub) | 26  | 0032 | 0x1a | :    | 58  | 0072 | 0x3a | Z    | 90  | 0132 | 0x5a | z     | 122 | 0172 | 0x7a |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (esc) | 27  | 0033 | 0x1b | ;    | 59  | 0073 | 0x3b | [    | 91  | 0133 | 0x5b | {     | 123 | 0173 | 0x7b |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (fs)  | 28  | 0034 | 0x1c | <    | 60  | 0074 | 0x3c | \\   | 92  | 0134 | 0x5c | \|    | 124 | 0174 | 0x7c |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (gs)  | 29  | 0035 | 0x1d | =    | 61  | 0075 | 0x3d | ]    | 93  | 0135 | 0x5d | }     | 125 | 0175 | 0x7d |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (rs)  | 30  | 0036 | 0x1e | >    | 62  | 0076 | 0x3e | ^    | 94  | 0136 | 0x5e | ~     | 126 | 0176 | 0x7e |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+
| (us)  | 31  | 0037 | 0x1f | ?    | 63  | 0077 | 0x3f | _    | 95  | 0137 | 0x5f | (del) | 127 | 0177 | 0x7f |
+-------+-----+------+------+------+-----+------+------+------+-----+------+------+-------+-----+------+------+


При этом символы с кодами, меньшими 32 — это специальные управляющие символы, которые не отображаются на экране.
Например, для того, чтобы обозначить конец строки в системе Linux используется один символ с кодом 10, а в системе
Windows — два подряд идущих символа с кодами 13 и 10, символы с кодами 48-57 соответствуют начертанию арабских цифр
(обратите внимание, символ с кодом 0 - это вовсе не символ, отображающийся на экране, как «0»), символы с кодами 65-90 —
заглавные буквы буквы латинского алфавита, а если к их кодам прибавить 32, то получатся строчные буквы латинского
алфавита. В промежутках между указанными диапазонами находятся знаки препинания, математические операции и прочие
символы.

Но в ASCII-таблицы нет русских букв! А также нет букв сотен других национальных алфавитов. Первоначально для отображения
букв национальных алфавитов использовали вторую половину возможного значения байта, то есть символы с кодами от 128 до
255. Это приводило к множеству проблем, например, поскольку 128 значений явно недостаточно для того, чтобы отобразить
символы всех национальных алфавитов (даже недостаточно для того, чтобы отобразить символы одного алфавита, например,
`китайской письменности`_. Поэтому в настоящее время для кодирования символов используется стандарт Unicode_ версия 6.0
которого (октябрь, 2010) включает свыше 109000 различных символов. Естественно, для кодирования Unicode-символов
недостаточно одного байта на символ, поэтому используются многобайтовые кодировки (для представления одного символа
необходимо несколько байт).

.. _`китайской письменности`: http://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%82%D0%B0%D0%B9%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D0%B8%D1%81%D1%8C%D0%BC%D0%BE
.. _Unicode: http://ru.wikipedia.org/wiki/Unicode

Язык программирования Python — современный язык, поэтому он работает исключительно с Unicode-символами.

Код символа можно определить при помощи функции `ord`. Эта функция получает на вход строку, которая дол на состоять
ровно из одного символа. Функция возвращает код этого символа. Например, `ord('A')` вернет число `65`.

Обратная функция получения по числовому коду его номера называется `chr`.

Сравнение символов
==================

Поскольку для символов заданы их числовые коды, то их можно сравнивать при помощи операций сравения. Поскольку символы
алфавита идут подряд, то результат их сравнения будет соответствовать лексикографическому порядку, но можно сравнивать
между собой не только буквы алфавита, но и два произвольных символа.

Также в питоне определены и операции сравнения строк, которые также сравниваются в лексикографическом порядке.

Упражнение №1: код ASCII-символа
--------------------------------

Считайте со стандартного ввода символ и выведите его код.

Программа получает на вход один символ с кодом от 33 до 126. Пример:

+------+-------+
| Ввод | Вывод |
+======+=======+
| A    | 65    |
+------+-------+


.. code-block:: python

   c = input()
   print(ord(c))


Упражнение №2: символ с данным ASCII-кодом
------------------------------------------

Считайте со стандартного ввода целое число и выведите ASCII-символ с таким кодом. Решите эту задачу с использованием
только одной переменной типа `int`.

Программа получает на вход число от 33 до 126. Пример:

+------+-------+
| Ввод | Вывод |
+======+=======+
| 65   | A     |
+------+-------+


.. code-block:: python

   n = int(input())
   print(chr(n))

Строки
======

Строка считывается со стандартного ввода функцией `input()`. Напомним, что для двух строк определа операция сложения
(конкатенации), также определена операция умножения строки на число.

Строка состоит из последовательности символов. Узнать количество символов (длину строки) можно при помощи функции `len`:


.. code-block:: pycon

   >>> S = 'Hello'
   >>> print(len(S))
   5

Срезы (slices)
==============

Срез (slice) — извлечение из данной строки одного символа или некоторого фрагмента подстроки или подпоследовательности.

Есть три формы срезов. Самая простая форма среза: взятие одного символа строки, а именно, `S[i]` — это срез, состоящий
из одного символа, который имеет номер `i`, при этом считая, что нумерация начинается с числа 0. То есть если
`S='Hello'`, то `S[0]=='H'`, `S[1]=='e'`, `S[2]=='l'`, `S[3]=='l'`, `S[4]=='o'`.

Номера символов в строке (а также в других структурах данных: списках, кортежах) называются **индексом**.

Если указать отрицательное значение индекса, то номер будет отсчитываться с конца, начиная с номера `-1`. То есть
`S[-1]=='o'`, `S[-2]=='l'`, `S[-3]=='l'`, `S[-4]=='e'`, `S[-5]=='H'`.


Или в виде таблицы:

+----------+-------+-------+-------+-------+-------+
| Строка S | H     | e     | l     | l     | o     |
+==========+=======+=======+=======+=======+=======+
| Индекс   | S[0]  | S[1]  | S[2]  | S[3]  | S[4]  |
+----------+-------+-------+-------+-------+-------+
| Индекс   | S[-5] | S[-4] | S[-3] | S[-2] | S[-1] |
+----------+-------+-------+-------+-------+-------+

Если же номер символа в срезе строки `S` больше либо равен `len(S)`, или меньше, чем `-len(S)`, то при обращении к этому
символу строки произойдет ошибка `IndexError: string index out of range`.

Срез с двумя параметрами: `S[a:b]` возвращает подстроку из `b-a` символов, начиная с символа c индексом `a`, то есть до
символа с индексом `b`, не включая его. Например, `S[1:4]=='ell'`, то же самое получится если написать `S[-4:-1]`. Можно
использовать как положительные, так и отрицательные индексы в одном срезе, например, `S[1:-1]` —  это строка без первого
и последнего символа (срез начинается с символа с индексом 1 и  заканчиватеся индексом -1, не включая его).

При использовании такой формы среза ошибки `IndexError` никогда не возникает. Например, срез `S[1:5]` вернет строку
`'ello'`, таким же будет результат, если сделать второй индекс очень большим, например, `S[1:100]` (если в строке не
более 5 символов).

Если опустить второй параметр (но поставить двоеточие), то срез берется до конца строки. Например, чтобы удалить из
строки первый символ (его индекс равен 0, то есть взять срез, начиная с символа с индексом 1), то можно взять срез
`S[1:]`, аналогично если опустиить первый параметр, то срез берется от начала строки. То есть удалить из строки
последний символ можно при помощи среза `S[:-1]`. Срез `S[:]` совпадает с самой строкой `S`.

Если задать срез с тремя параметрами `S[a:b:d]`, то третий параметр задает шаг, как в случае с функцией `range`, то есть
будут взяты символы с индексами `a`, `a+d`, `a+2*d` и т.д. При задании значения третьего параметра, равному 2, в срез
попадет кажый второй символ, а если взять значение среза, равное `-1`, то символы будут идти в обратном порядке.

Методы
======

Метод — это функция, применяемая к объекту, в данном случае — к строке. Метод вызывается в виде
`Имя_объекта.Имя_метода(параметры)`. Например, `S.find("e")` — это применение к строке `S` метода `find` с одним
параметром `"e"`.

Метод `find` находит в данной строке (к которой применяется  метод) данную подстроку (которая передается в качестве
параметра). Функция возвращает индекс первого вхождения искомой подстроки. Если же подстрока не найдена, то метод
возвращает значение -1. Например:

.. code-block:: pycon

   >>> S = 'Hello'
   >>> print(S.find('e'))
   1
   >>> print(S.find('ll'))
   2
   >>> print(S.find('L'))
   -1

Аналогично, метод `rfind` возвращает индекс последнего вхождения данной строки («поиск справа»).

.. code-block:: pycon

   >>> S = 'Hello'
   >>> print(S.find('l'))
   2
   >>> print(S.rfind('l'))
   3

Если вызвать метод `find` с тремя параметрами `S.find(T, a, b)`, то поиск будет осуществляться в срезе `S[a:b]`. Если
указать только два параметра `S.find(T, a)`, то поиск будет осуществляться в срезе `S[a:]`, то есть начиная с символа с
индексом `a` и до конца строки. Метод `S.find(T, a, b)` возращает индекс в строке `S`, а не индекс относительно начала
среза.

Метод `replace` заменяет все вхождения одной строки на другую. Формат: `S.replace(old, new)` — заменить в строке `S` все
вхождения подстроки `old` на подстроку `new`. Пример:

.. code-block:: pycon

   >>> 'Hello'.replace('l', 'L')
   'HeLLo'

Если методу `replace` задать еще один параметр: `S.replace(old, new, count)`, то заменены будут не все вхождения, а
только не больше, чем первые `count` из них.

.. code-block:: pycon

   >>> 'Abrakadabra'.replace('a', 'A', 2)
   'AbrAkAdabra'

Метод `count` подсчитывает количество вхождений одной строки в другую строку. Простейшая форма вызова `S.count(T)`
возвращает число вхождений строки `T` внутри строки `S`. При этом подсчитываются только непересекающиеся вхождения,
например:

.. code-block:: pycon

   >>> 'Abracadabra'.count('a')
   4
   >>> ('a' * 100000).count('aa')
   50000

При указании трех параметров `S.count(T, a, b)`, будет выполнен подсчет числа вхождений строки `T` в срез `S[a:b]`.

Упражнение №3: срезы
--------------------

Дана строка. Последовательно на разных строках выведите:

- третий символ этой строки;
- предпоследний символ этой строки;
- первые пять символов этой строки;
- всю строку, кроме последних двух символов;
- все символы с четными индексами (считая, что индексация начинается с 0, поэтому символы выводятся начиная с первого);
- все символы с нечетными индексами, то есть начиная со второго символа строки;
- все символы в обратном порядке.
- все символы строки через один в обратном порядке, начиная с последнего;
- длину данной строки.

Пример:

 +-------------+-------------+
 | Ввод        | вывод       |
 +=============+=============+
 | Абракадабра | р           |
 +-------------+-------------+
 |             | р           |
 +-------------+-------------+
 |             | Абрак       |
 +-------------+-------------+
 |             | Абракадаб   |
 +-------------+-------------+
 |             | Аркдба      |
 +-------------+-------------+
 |             | бааар       |
 +-------------+-------------+
 |             | арбадакарбА |
 +-------------+-------------+
 |             | абдкрА      |
 +-------------+-------------+
 |             | 11          |
 +-------------+-------------+


 .. code-block:: python

   s = input()

   print(s[2])
   print(s[-2])
   print(s[:5])
   print(s[:-2])
   print(s[::2])
   print(s[1::2])
   print(s[-1::-1])
   print(s[-1::-2])
   print(len(s ))





Списки в Python
===============

Большинство программ работает не с отдельными переменными, а с набором переменных. Например, программа может
обрабатывать информацию об учащихся класса, считывая список учащихся с клавиатуры или из файла, при этом изменение
количества учащихся в классе не должно требовать модификации исходного кода программы.

Раньше мы сталкивались с задачей обработки элементов последовательности, например, вычисляя наибольший элемент
последовательности. Но при этом мы не сохраняли всю последовательность в памяти компьютера, однако, во многих задачах
нужно именно сохранять всю последовательность, например, если бы нам требовалось вывести все элементы последовательности
в возрастающем порядке («отсортировать последовательность»).

Для хранения таких данных можно использовать структуру данных, называемую в Питоне список (в большинстве же языков
программирования используется другой термин — «массив»). Список представляет собой последовательность элементов,
пронумерованных от 0. Список можно задать перечислением элементов в квадратных скобках,
например, список можно задать так:

.. code-block:: python

	 primes = [2, 3, 5, 7, 11, 13]
	Rainbow = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']

В списке `primes` — 6 элементов:
.. code-block:: python

    >>> primes = [2, 3, 5, 7, 11, 13]
    >>> print(primes[0])
    2
    >>> print(primes[1])
    3
    >>> print(primes[2])
    5
    >>> print(len(primes))
    6

Список `rainbow` состоит из 7 элементов, каждый из которых является строкой.

Также как и символы строки, элементы списка можно индексировать отрицательными числами с конца, например,
`primes[-1] == 13`, `primes[-6] == 2.`

Длину списка, то есть количество элементов в нем, можно узнать при помощи функции len, например, `len(A) == 6`.

Рассмотрим несколько способов создания и считывания списков. Пустой, т.е. не имеющий элементов список, можно создать
следующим образом:

.. code-block:: python

	A = []

Для добавления элементов в конец списка используется метод `append`. Если программа получает на вход количество
элементов в списке `n`, а потом `n` элементов списка по одному в отдельной строке, то организовать считывание списка
можно так:

.. code-block:: python

	A = []
	for i in range(int(input()):
	    A.append(int(input())

В этом примере создается пустой список, далее считывается количество элементов в списке, затем по одному считываются
элементы списка и добавляются в его конец.

Для списков целиком определены следующие операции: конкатенация списков (добавление одного списка в конец другого) и
повторение списков (умножение списка на число). Например:

.. code-block:: python

	A = [1, 2, 3]
	B = [4, 5]
	C = A + B
	D = B * 3

В результате список `C` будет равен `[1, 2, 3, 4, 5]`, а список `D` будет равен `[4, 5, 4, 5, 4, 5]`. Это позволяет по-другому организовать процесс считывания списков: сначала считать размер списка и создать список из нужного числа
элементов, затем организовать цикл по переменной `i` начиная с числа 0 и внутри цикла считывается `i`-й элемент списка:

.. code-block:: python

	A = [0] * int(input())
	for i in range(len(A)):
	    A[i] = int(input())

Вывести элементы списка `A` можно одной инструкцией `print(A)`, при этом будут выведены квадратные скобки вокруг
элементов списка и запятые между элементами списка. Такой вывод неудобен, чаще требуется просто вывести все элементы
списка в одну строку или по одному элементу в строке. Приведем два примера, также отличающиеся организацией цикла:

.. code-block:: python

	for i in range(len(A)):
	    print(A[i])

Здесь в цикле меняется индекс элемента `i`, затем выводится элемент списка с индексом `i`.

.. code-block:: python

	for elem in A:
	    print(elem, end = ' ')

В этом примере элементы списка выводятся в одну строку, разделенные пробелом, при этом в цикле меняется не индекс
элемента списка, а само значение переменной. Например, в цикле `for elem in ['red', 'green', 'blue']` переменная `elem`
будет последовательно принимать значения 'red', 'green', 'blue'.

Внутри одного списка могут быть любые объекты (и даже вперемешку), поэтому такая конструкция как список списков вполне осмысленна (аналог двумерного массива).
Обращаться к элементам внутри такого списка нужно так `A[i][j]` , где `j` - индекс внутри внутреннего списка, `i` - индекс внутри внешнего списка.
Но обратите внимание на следующую вещь:

.. code-block:: python

	A = [[0] * 10]*10 # вроде бы это обычный список списков 10х10 состоящий из 0
	A[0][0] = 1 # меняем элемент с индексом 0 в списке с индексом 0
	print(A[1][0]) # печатаем элемент с индексом 0 в списке с индексом 1

Что вывела программа? Как можно это объяснить? Попробуйте напечатать `A` целиком.

Методы split и join
-------------------

Выше мы рассмотрели пример считывания списка, когда каждый элемент расположен на отдельной строке. Иногда бывает удобно
задать все элементы списка при помощи одной строки. В такой случае используется метод `split`, определённый в строковом
типе:

.. code-block:: python

	A = input().split()

Если при запуске этой программы ввести строку 1 2 3, то список `A` будет равен `['1', '2', '3']`. Обратите внимание, что
список будет состоять из строк, а не из чисел. Если хочется получить список именно из чисел, то можно затем элементы
списка по одному преобразовать в числа:

.. code-block:: python

	for i in range(len(A)):
	    A[i] = int(A[i])

Используя функции языка map и list то же самое можно сделать в одну строку:

.. code-block:: python

	A = list(map(int, input().split()))

Объяснений, как работает этот пример, пока не будет. Если нужно считать список действительных чисел, то нужно заменить
тип `int` на тип `float`.

У метода `split` есть необязательный параметр, который определяет, какая строка будет использоваться в качестве
разделителя между элементами списка. Например, вызов метода `split('.')` для строки вернет список, полученный
разрезанием этой строки по символам '.'.

Используя «обратные» методы можно вывести список при помощи однострочной команды. Для этого используется метод строки
`join`. У этого метода один параметр: список строк. В результате создаётся строка, полученная соединением элементов
списка (которые переданы в качестве параметра) в одну строку, при этом между элементами списка вставляется разделитель,
равный той строке, к которой применяется метод. Например, программа

.. code-block:: python

	A = ['red', 'green', 'blue']
	print(' '.join(A))
	print(''.join(A))
	print('***'.join(A))

выведет строки `red green blue`, `redgreenblue` и `red***green***blue`. Обратите внимание, что `join` является методом **строки**, а не списка.

Если же список состоит из чисел, то придется использовать еще и функцию map. То есть вывести элементы списка чисел,
разделяя их пробелами, можно так:

.. code-block:: python

	print(' '.join(map(str, A)))


Срезы списков
-------------

Со списками, так же как и со строками, можно делать срезы. А именно:

+-------------+--------------------------------------------------------------------------------------------------------------------------+
| `A[i:j]`    | срез из `j-i` элементов `A[i], A[i+1], ..., A[j-1]`.                                                                     |
+-------------+--------------------------------------------------------------------------------------------------------------------------+
| `A[i:j:-1]` | срез из `i-j` элементов `A[i], A[i-1], ..., A[j+1]` (то есть меняется порядок элементов).                                |
+-------------+--------------------------------------------------------------------------------------------------------------------------+
| `A[i:j:k]`  | срез с шагом `k`: `A[i], A[i+k], A[i+2*k],...` . Если значение `k` меньше 0, то элементы идут в противоположном порядке. |
+-------------+--------------------------------------------------------------------------------------------------------------------------+

Каждое из чисел `i` или `j` может отсутствовать, что означает «начало строки» или «конец строки».

Списки, в отличие от строк, являются изменяемыми объектами: можно отдельному элементу списка присвоить новое значение. Но можно менять и целиком срезы. Например:

.. code-block:: python

	A = [1, 2, 3, 4, 5]
	A[2:4] = [7, 8, 9]

Получится список, у которого вместо двух элементов среза `A[2:4]` вставлен новый список уже из трех элементов. Теперь список стал равен `[1, 2, 7, 8, 9, 5]`.

.. code-block:: python

	A = [1, 2, 4, 5, 6,  7]
	A[::-2] = [10, 20, 30, 40]

Получится список `[40, 2, 30, 4, 20, 6, 10]`. Здесь `A[::-2]` — это список из элементов `A[-1], A[-3], A[-5], A[-7]`, которым присваиваются значения 10, 20, 30, 40 соответственно.

Если **не непрерывному** срезу (то есть срезу с шагом `k`, отличному от 1), присвоить новое значение, то количество элементов в старом и новом срезе обязательно должно совпадать, в противном случае произойдет ошибка `ValueError`.

Обратите внимание, `A[i]` — это **элемент** списка, а не срез!


Генерация списков
-----------------

В питоне существует специальная синтаксическая конструкция, позволяющая создавать заполненные списки по определенным правилам.
Создаваемые списки могут быть разными, содержание конструкции немного отличаться, поэтому такие конструкции называют генераторами списков  (англ. - List comprehensions).
Их удобство заключается в более короткой записи, чем если создавать список обычным способом. Расскажем вкратце об этой конструкции.

Например, надо создать список, заполненный натуральными числами до определенного числа.
"Классический" способ будет выглядеть так:

.. code-block:: python

	a = []
    for i in range(1,10):
        a.append(i)

С помощью генераторов можно сделать это одной строкой:


.. code-block:: python

	a = [i for i in range(1,10)]


Пример генерации списка квадратов четных натуральных чисел


.. code-block:: python

	a = [i**2 for i in range(10) if i % 2 == 0]


Таким образом, генератору можно передавать следующую информацию:

#. Что делаем (возводим в квадрат).
#. Что берем (элемент i).
#. Откуда берем (из range(10), но можно сюда передать список или даже строку).
#. Условие (в генератор попадают только числа i, для которых выполнено `i % 2 == 0` ).

Пример изменения типа всех элементов списка с помощью генератора:

.. code-block:: python

    a = ['12', '4', '151']
    b = [int(i) for i in a]

Операции со списками
--------------------

Со списками можно легко делать много разных операций.

+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| Операция         | Действие                                                                                                                                           |
+==================+====================================================================================================================================================+
| `x in A`         | Проверить, содержится ли элемент в списке. Возвращает `True` или `False`.                                                                          |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `x not in A`     | То же самое, что `not(x in A)`.                                                                                                                    |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `min(A)`         | Наименьший элемент списка. Элементы списка могут быть числами или строками, для строк сравнение элементов проводится в лексикографическом порядке. |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `max(A)`         | Наибольший элемент списка.                                                                                                                         |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `sum(A)`         | Сумма элементов списка, элементы обязательно должны быть числами.                                                                                  |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.index(x)`     | Индекс первого вхождения элемента `x` в список, при его отсутствии генерирует исключение `ValueError`.                                             |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.count(x)`     | Количество вхождений элемента `x` в список.                                                                                                        |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.append(x)`    | Добавить в конец списка `A` элемент `x`.                                                                                                           |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.insert(i, x)` | Вставить в список `A` элемент `x` на позицию с индексом `i`. Элементы списка `A`, которые до вставки имели индексы `i` и больше сдвигаются вправо. |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.extend(B)`    | Добавить в конец списка `A` содержимое списка `B`.                                                                                                 |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.pop()`        | Удалить из списка последний элемент, возвращается значение удаленного элемента.                                                                    |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+
| `A.pop(i)`       | Удалить из списка элемент с индексом `i`, возвращается значение удаленного элемента. Все элементы, стоящие правее удаленного, сдвигаются влево.    |
+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------+

Упражнение №4. Однострочники.
+++++++++++++++++++++++++++++

Каждая из задач должна быть решена в одну строку.
Список чисел A уже введён.

#. Выведите элементы списка с чётными индексами.

	+-----------+-------+
	| Ввод      | Вывод |
	+===========+=======+
	| 1 2 3 4 5 | 1 3 5 |
	+-----------+-------+

#. Найдите наибольший элемент в списке. Выведите значение элемента и его индекс.

	+-----------+-------+
	| Ввод      | Вывод |
	+===========+=======+
	| 1 2 3 2 1 | 3 2   |
	+-----------+-------+

#. Выведите список в обратном порядке.

	+-----------+-----------+
	| Ввод      | Вывод     |
	+===========+===========+
	| 1 2 3 4 5 | 5 4 3 2 1 |
	+-----------+-----------+

Упражнение №5. Задачи посложнее.
++++++++++++++++++++++++++++++++

#. Переставьте соседние элементы в списке. Задача решается в три строки.

	+-----------+-----------+
	| Ввод      | Вывод     |
	+===========+===========+
	| 1 2 3 4 5 | 2 1 4 3 5 |
	+-----------+-----------+

#. Выполните циклический сдвиг элементов списка вправо. Решите задачу в две строки.

	+-----------+-----------+
	| Ввод      | Вывод     |
	+===========+===========+
	| 1 2 3 4 5 | 5 1 2 3 4 |
	+-----------+-----------+

#. Выведите элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том порядке, в котором они встречаются в списке.

	+-------------+-------+
	| Ввод        | Вывод |
	+=============+=======+
	| 1 2 2 3 3 3 | 1     |
	+-------------+-------+

	В этой задаче **нельзя** модицифицировать список, использовать вспомогательные списки, строки, срезы.

#. Определите, какое число в этом списке встречается чаще всего. Если таких чисел несколько, выведите любое из них.

	+-------------+-------+
	| Ввод        | Вывод |
	+=============+=======+
	| 1 2 3 2 3 3 | 3     |
	+-------------+-------+

	В этой задаче также **нельзя** модицифицировать список, использовать вспомогательные списки, строки, срезы.




Упражнение №6. Задача DNA.
++++++++++++++++++++++++++


Строка это упорядоченный набор символов, выбранных из некоторого алфавита и формирующих слова. Длина строки это количество символов, которые она содержит.

ДНК кодируется четырьмя разными нуклеотидными основаниями (н.о.): “A”, “C”, “G” и “Т”. Требуется найти сколько раз встречается каждое основание.


Параметр входных данных:

Дается строка фрагмента ДНК, состоящая не более чем из 1000 н.о.


Параметр выходных данных:

Вывести через пробел сколько раз встречается каждое н.о.




Упражнение №7. Задача RNA.
++++++++++++++++++++++++++


Последовательность РНК представляет собой строку, в которой встречаются буквы “A”, “C”, “G” и “U”. Вместо тимина информация кодируется урацилом. Следует преобразовать Цепочку ДНК в последовательность РНК, заменив все н.о. “T” на “U”.

Параметр входных данных:

Дается строка фрагмента ДНК, состоящая не более чем из 1000 н.о.


Параметр выходных данных:

Вывести на экран строку РНК.


Упражнение №8. Задача FIBD.
+++++++++++++++++++++++++++


Вспомните определение чисел Фибоначчи из задачи “Кролики и рекуррентные соотношения”, которому соответствовала формула Fn=Fn−1+Fn−2. 
В той задаче предполагалось, что каждая пара кроликов достигает зрелости через месяц и производит на свет 1 пару потомства
( один самец, одна самчиха) каждый последующий месяц.
Наша задача как-то улучшить это рекуррентное соотношение, чтобы достичь решение динамическим программированием в случае,
когда все кролики умирают после определенного числа месяцев. 


Параметр входных данных:

Натуральные числа n≤100 и m≤20.


Параметр выходных данных:

Число всех кроличьих пар,которые останутся после n-го месяца, если кролики живут по m месяцев.



Упражнение №9. Задача REVC.
+++++++++++++++++++++++++++

В цепочках ДНК символы «А» и «Т» являются дополнениями друг к другу, как и «С» и «G».

Обратное дополнение строки ДНК s представляет собой строку sc, сформированную путем обращения символов s с
последующим взятием дополнения каждого символа (например, обратное дополнение "GTCA" - это "TGAC").


Дано: ДНК-нить длиной не более 1000 п.н.


Возврат: обратное дополнение sc к s.


Упражнение №10. Задача GC.
++++++++++++++++++++++++++

Содержание GC в строке ДНК определяется процентом символов в строке, которые являются «C» или «G». Например, содержание GC в «AGCTATAG» составляет 37,5%. Обратите внимание, что обратный комплемент любой нити ДНК имеет одинаковое содержание GC.

Строки ДНК должны быть помечены, когда они объединены в базу данных. Обычно используемый метод маркировки строк называется форматом FASTA. В этом формате строка вводится строкой, которая начинается с «>», после чего следует некоторая информация о маркировке. Последующие строки содержат саму строку; первая строка, начинающаяся с «>», обозначает метку следующей строки.

В реализации Rosalind строка в формате FASTA будет помечена идентификатором «Rosalind_xxxx», где «xxxx» обозначает четырехзначный код от 0000 до 9999.

Дано: не более 10 строк ДНК в формате FASTA (длиной не более 1 т.п.н. каждая).

Return: идентификатор строки, имеющей самое высокое содержание GC, за которым следует содержание GC этой строки. Розалинд допускает ошибку по умолчанию 0,001 во всех десятичных ответах, если не указано иное; см. примечание об абсолютной ошибке ниже.

Образец набора данных

CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC
TCCCACTAATAATTCTGAGG


CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT
ATATCCATTTGTCAGCAGACACGC


CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC
TGGGAACCTGCGGGCAGTAGGTGGAAT


Пример вывода


60.919540


Примечание об абсолютной ошибке.

Мы говорим, что число x находится в пределах абсолютной ошибки y для правильного решения, если x находится в пределах y
от правильного решения. Например, если точное решение равно 6,157892, то для x должно быть в пределах абсолютной ошибки 0,001,
мы должны иметь, что | x − 6,157892 | <0,001 или 6,156892 <x <6,158892.

Ограничение ошибок является жизненно важным практическим инструментом из-за присущей ему ошибки округления при
представлении десятичных чисел в компьютере, где только конечному числу десятичных разрядов присваивается любое число.
После компоновки по нескольким операциям эта ошибка округления может стать очевидной. В результате, вместо того,
чтобы проверять, равны ли два числа с x = z, вы можете просто проверить, что | x − z | очень маленькое.


Упражнение №11. Задача HAMM.
++++++++++++++++++++++++++++


Для двух строк s и t одинаковой длины расстояние Хэмминга между s и t, обозначаемое dH (s, t), 
представляет собой количество соответствующих символов, которые различаются в s и t. 

Дано: две строки ДНК s и t одинаковой длины (не более 1 кбп).

Возврат: расстояние Хэмминга dH (s, t).


Образец входных данных

GAGCCTACTAACGGGAT
CATCGTAATGACGGCCT

Пример вывода

7


