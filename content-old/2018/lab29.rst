Практика: поиск путей минимального веса
#######################################

:date: 2019-04-29 09:00
:summary: Алгоритмы поиска кратчайших путей в графе.
:status: published
:published: yes

.. default-role:: code

.. contents:: Содержание

Введение
========

Ранее вы изучили алгоритм поиск в ширину, позволяющий находит кратчайшие пути в невзвешенном графе. 
Однако, в случае взвешенных графов BFS будет не всегда давать корректный ответ, т.к. он по факту находит 
путь, содержащий минимальное количество ребер. Перед нами будет стоять задача нахождения пути с наименьшей суммой весов ребер в нем.



Использование контейнеров (стеки и очереди) для реализации поиска в глубину и ширину.
=====================================================================================

Рассмотрим материал, который уже был пройден в темах по DFS и BFS, с некоторой более общей точки зрения.

Для обходов в ширину и глубину нужны:

1. Граф, заданный списком смежности adjacent;
2. Отдельный список или другая структура данных, которая хранит уже посещённые вершины visited;
3. Очередь (queue) или стек (stack) вершин (в обоих новые элементы присоединяются к списку в конец, но из очереди достают элемент только с начала, а в стеке наоборот - с конца, как и кладут).


DFS можно реализовать просто рекурсивно, тогда не нужен стек вершин. Временная сложность DFS равна O(m+n), где m - число рёбер, 
n - число вершин, поскольку алгоритм обрабатывает каждую вершину и каждое ребро ровно один раз.

BFS реализовать сложнее, так как алгоритм последовательно посещает вершины, находящиеся в различных частях графа. Типичная реализация 
основана на очереди вершин - на каждом шаге обрабатывается следующий узел очереди, которая содержит вершины, подлежащие обработке, в
порядке увеличения расстояния. Сложность по времени у BFS такая же, как у DFS.

В обоих случаях очередь или стек - это структура данных, которая реализует идею отложенных заданий. Когда мы обрабатываем очередную
вершину графа, все смежные с ней кладутся в эту структуру данных как отложенные задания. В DFS новое задание выполняется как последнее из положенных, следовательно этот поиск будет идти вглубь, а первые положенные задания будут выполнены в самом конце. BFS же исполняет в 
обратном порядке, очередное задание - первое из положенных, следовательно сначала будут обработаны все ближайшие вершины. 

Таким образом, DFS и BFS при реализации через список будут отличаться только одним действием - как вынимать элементы из списка
отложенных заданий. В Python вытаскивание из списка с конца реализуется как List.pop(), а с начала - List.pop(0).

Рассмотрим сначала код, который работает с матрицей инцидентности MatrixGraph. 


.. code-block:: python

    def BFS(MatrixGraph, n, s):
      d = [n+2]*n  # здесь можно записать любые числа,  которые не могут быть расстояниями в данном графе
      d[s] = 0
      queue = []
      queue.append(s)
      while len(queue) > 0:
        u = queue.pop(0)
        for i in range(n):
            if MatrixGraph[u][i] != 0 and d[i] == n+2:
                d[i] = d[u] + 1
                queue.append(i)
      for i in range(n):
        if d[i] == n+2:
            d[i] = -1   #отрицательность означает, что вершина недостижима
      return d


    def DFS(MatrixGraph, n, s):
      d = [n+2]*n  # здесь можно записать любые числа,  которые не могут быть расстояниями в данном графе
      d[s] = 0
      stack = []
      stack.append(s)
      while len(stack) > 0:
        u = stack.pop()
        for i in range(n):
            if MatrixGraph[u][i] != 0 and d[i] == n+2:
                d[i] = d[u] + 1
                stack.append(i)
      for i in range(n):
        if d[i] == n+2:
            d[i] = -1   #отрицательность означает, что вершина недостижима
      return d




Как видим, различие между алгоритмами минимальное. После переработки оба кода можно приспособить для работы со списком смежности.



.. code-block:: python

    def BFS(adjacent, n, s):
  	d = [n+2]*n  # здесь можно записать любые числа,  которые не могут быть расстояниями в данном графе
  	d[s] = 0
  	queue = []
  	queue.append(s)
  	while len(queue) > 0:
    	    u = queue.pop(0)
    	    for i in range(len(adjacent[u])):
        	if  d[adjacent[u][i]] == n+2:
            		d[adjacent[u][i]] = d[u] + 1
            		queue.append(adjacent[u][i])            
  	for i in range(n):
	    if d[i] == n+2:
        	d[i] = -1   #отрицательность означает, что вершина недостижима
  	return d

    def DFS(adjacent, n, s):
  	d = [n+2]*n  # здесь можно записать любые числа,  которые не могут быть расстояниями в данном графе
  	d[s] = 0
  	stack = []
  	stack.append(s)
  	while len(stack) > 0:
    	    u = stack.pop()
    	    for i in range(len(adjacent[u])):
        	if  d[adjacent[u][i]] == n+2:
            		d[adjacent[u][i]] = d[u] + 1
            		stack.append(adjacent[u][i])            
  	for i in range(n):
	    if d[i] == n+2:
        	d[i] = -1   #отрицательность означает, что вершина недостижима
  	return d



Для иллюстрации работы рассмотрим, как эти алгоритмы обходят бинарное дерево глубины 3, вершины которого можно пронумеровать так:
<>, <0>, <1>, <00>, <01>, <10>, <11>,  <000>, <001>, <010>, <011>, <100>, <101>, <110>, <111>

Подразумевается, что список смежности у него следующий:

.. code-block:: python

	a, a0, a1, a00, a01, a10, a11, a000, a001, a010, a011, a100, a101, a110, a111 = range(15)
	adjacent = [
 	 [a0, a1], # a
 	 [a00, a01], # a0
	 [a10, a11], # a1
	 [a000, a001], # a00
	 [a010, a011], # a01
	 [a100, a101], # a10
	 [a110, a111], # a11
	 [], # a000
   	 [], # a001
   	 [], # a010
   	 [], # a011
   	 [], # a100
   	 [], # a101
   	 [], # a110
   	 [], # a111   
	]


Отметим, что, хотя здесь используется ориентированный граф, в случае такого же неориентированного обход в глубину и обход в ширину не
будет отличаться ничем, потому что уже пройденные вершины не будут попадать в стек или очередь отложенных заданий.

Итак, DFS в данном случае работает следующим образом:

u = a; stack = [a0, a1]

u = a1; stack = [a0, a10, a11]

u = a11; stack = [a0, a10, a110, a111]

u = a111; stack = [a0, a10, a110]

u = a110; stack = [a0, a10]

u = a10; stack = [a0, a100, a101]

u = a101; stack = [a0, a100]

u = a100; stack = [a0]

u = a0; stack = [a00, a01]

u = a01; stack = [a00, a010, a011]

u = a011; stack = [a00, a010]

u = a010; stack = [a00]

u = a00; stack = [a000, a001]

u = a001; stack = [a000]

u = a000; stack = []


Как видим, обход через стек отличается от рекурсивной реализации DFS - рекурсивный даёт другой обход вершин. Чтобы они совпадали, 
нужно в одном из алгоритмов обходить список смежности каждой вершины с его начала, а в другом - с его конца. Если же нужно хранить дерево произвольного размера, то для этого можно использовать вложение списков друг в друга в Python - такой способ обычно удобнее. 


Упражнение №0
+++++++++++++


Реализуйте алгоритм BFS для этого бинарного дерева и с помощью него выведите на экран текст обхода, аналогичный приведённому для DFS.
Дополнительное упражнение - реализуйте для дерева с помощью многократного вложения списков в списки, а не обычным списком смежности. То есть, например, для данного дерева такой список будет выглядеть так: 

.. code-block:: python

	List = [ [ [ [], [] ], [ [], [] ] ] , [ [ [], [] ], [ [], [] ] ] ]



Алгоритм Флойда-Уоршалла
========================

Для начала рассмотрим алгоритм Флойда (Флойда-Уоршалла). Его отличительной особенностью является то, что он умеет находить кратчайшие расстояния между всеми парами вершин. Но за это приходится платить временем работы, О(N^3). Идея заключается в следующем: мы будем перебирать все возможные тройки вершин (i, j, k) и пытаться улучшить путь из i в j, проходя через k.

.. code-block:: python

    # Считываем граф, преобразуем его в матрицу смежности, которую храним в d
    # Отсутствие ребра помечаем каким-нибудь заведомо большим числом
    # Считаем, что n - кол-во вершин, вершины пронумерованы от 0
    for k in range(n):
        for i in range(n):
            for j in range(n):
                d[i][j] = min(d[i][j], d[i][k]+d[k][j])

Упражнение №1
+++++++++++++

Вам дано число N, далее N строк по N чисел - матрица смежности взвешенного графа, отсутствие ребра помечено как 0. На следующих двух строках даны 2 списка: с начальными вершинами и с целевыми вершинами. Вам необходимо распечатать таблицу кратчайших расстояний, где строки - список начальных вершин, а столбцы - список целевых вершин.

Алгоритм Дейкстры
=================

Снова вернемся к задаче поиска кратчайшего растояния от одной вершины до всех остальных, но теперь во взвешенном графе. Для ее решения будем применять алгоритм Дейкстры, который работает следующим образом:

1. На каждой итерации алгоритм среди непомеченных вершин вибирает с наименьшим до нее расстоянием;
2. Помечает вершину как посещенную.
3. Пытается улучшить расстояние до смежных с ней вершин;

На каждой итерации поддерживается инвариант, что расстояния до помеченных вершин являются кратчайшими и более меняться не будут. Однако, чтобы это условие не нарушалось, граф не должен содержать ребер отрицательного веса. Иначе, алгоритм в такой задаче не применим. Код алгоритма выглядит следующим образом:

.. code-block:: python

    # считываем граф, преобразуем его в список смежности, который храним в graph
    # INF - заведомо большое число
    d = [INF]*n  # Считаем, что n - кол-во вершин, вершины пронумерованы от 0
    d[s] = 0  # s - стартовая вершина
    used = [False]*n
    while True:
        u = -1
        for i in range(n):
            if not used[i] and (u == -1 or d[u] > d[i]):
                u = i
        if u == -1:
            break
        used[u] = True
        for v, w in graph[u]:
            d[v] = min(d[v], d[u] + w)

Время работы алгоритма зависит от того, как быстро ищется минимум. В приведенном выше варианте время работы O(N^2). Для ускорения алгоритма применяют особые структуры данных - кучу, либо дерево отрезков. В обоих случаях время работы будет O((N+M) log N). 

Упражнение №2
+++++++++++++

Вам даны числа N и M, количество вершин и ребер ориентированного графа. Далее идет M строк вида u, v, w, где u и v задают начало и конец ребра, а w - его вес. В конце дано число - стартовая вершина. Посчитайте кратчайшие расстояния до всех вершин, используя алгоритм Дейкстры за O(N^2).

Упражнение №3
+++++++++++++

Оптимизируйте алгоритм из упражнения 2,  реализовав алгоритм Дейкстры за O((N+M) log N).

Алгоритм Форда-Беллмана
=======================

Алгоритм Форда-Беллмана будет последним рассмотренным алгоритмом, который, как и алгоритм Дейкстры, используется для поиска кратчайшего расстояния от одной вершины до остальных. Он является типичным алгоритмом ДП. Состояния описываются двумя параметрами и означают "длину кратчайшего пути, проходящего не более, чем по i ребрам, и заканчивающегося в вершине j".

.. code-block:: python

    # считываем граф, преобразуем его в список ребер, который храним в edges
    d = [None]*n  # Считаем, что n - кол-во вершин, вершины пронумерованы от 0
    d[s] = 0  # s - стартовая вершина
    # INF - заведомо большое число
    for i in range(n-1):
        for u, v, w in edges:
            if d[u] is not None:
                d[v] = min(INF if d[v] is None else d[v], d[u] + w)

Такой алгоритм работает O(N\*M). Заметим несколько вещей:

1. Алгоритм работает корректно даже при наличии ребер отрицательного веса, -1 - валидное значение для расстояний, поэтому массив инициализировался с None;
2. Вернувшись в вершину, пройдя по циклу, расстояние до нее не может уменьшится (циклы отрицательного веса пока не рассматриваем);
3. Исходя из (2) для нахождения кратчайшего пути до всех вершин достаточно N-1 итерации, т.е. кратчайшие пути до всех вершин не содержат циклов.

Однако утверждение (2) справедливо, только когда нет циклов отрицательного веса, т.е. цикла, в которой растояния до вершин в нем будут каждый раз уменьшаться, если мы будем по нему гулять. Таким образом нам вообще не выгодно его заканчивать, а значит мы можем счиать, что кратчайшие расстояния до этих вершин будут -∞. Таким образом N-1 итерации не хватит чтобы посчитать кратчайшие расстояния. Поэтому мы можем внешний цикл увеличить на одну итерацию. Все вершины, расстояние до которых обновится на последней итерации, можем считать имеют расстояние -∞.

Отсюда можно сделать вывод, что алгоритм применяется не только для поиска кратчайших расстояний в графе, но и для поиска циклов отрицательного веса. Кроме того, алгоритм используется для поиска максимального потока минимальной стоимости.

Упражнение №4
+++++++++++++

Решите задачу из упражнения №2, используя алгоритм Форда-Беллмана. Гарантируется, что циклов отрицательного веса в графе нет.

Упражнение №5
+++++++++++++

Как и в предыдущих задачах, нам задан ориентированный взвешенный граф. Но теперь в нем могут быть циклы отрицательного веса. Необходимо вывести любой из таких циклов, либо сказать, что в графе его нет.
