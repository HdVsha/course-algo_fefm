Арифметика с плавающей запятой.
###############################


:date: 2018-10-08 09:00
:summary: Арифметика с плавающей запятой.
:status: published 

.. default-role:: code




Представление целых чисел в памяти ПК.
======================================



Выбор способа хранения целых чисел в памяти компьютера — не такая тривиальная задача, как могло бы показаться на первый взгляд. 
Желательно, чтобы этот способ:

•	не требовал усложнения архитектуры процессора для выполнения арифметических операций с отрицательными числами,
•	не усложнял арифметические действия,
•	хранил бы одинаковое количество положительных и отрицательных чисел.

Рассмотрим разные методы представления.
При записи числа в прямом коде (англ. Signed magnitude representation) старший разряд является знаковым разрядом. 
Если его значение равно нулю, то представлено положительное число или положительный ноль, если единице, 
то представлено отрицательное число или отрицательный ноль. В остальных разрядах (они называются цифровыми) 
записывается двоичное представление модуля числа. Например, число ( −5) в 8-битном типе данных, 
использующем прямой код, выглядит так:  10000101.
Прямой код прост, но он плох тем, что в нём есть два нуля и выполнение операций с отрицательными числами
требует усложнения архитектуры ЭВМ.

Из-за этих недостатков прямой код  используют крайне редко. Чаще используют на практике код со сдвигом, который их лишён. 
При таком кодировании:

1)	 к кодируемому числу прибавляют 2^n-1;

2)	переводят получившееся число в двоичную систему исчисления.

Из-за необходимости усложнять арифметические операции код со сдвигом для представления целых чисел используется не часто, 
но зато применяется для хранения порядка вещественного числа. Чаще всего для представления отрицательных чисел используется 
код с дополнением до двух. Алгоритм получения дополнительного кода: 

•	если число неотрицательное, то в старший разряд записывается ноль, далее записывается само число;

•	если число отрицательное, то все биты модуля числа инвертируются, то есть все единицы меняются на нули, а нули — на единицы, к инвертированному числу прибавляется единица, и к результату дописывается знаковый разряд, равный единице.

Дополнительный код также удобно использовать для вычислений в длинной арифметике, особенно для операций сложения и вычитания. 
Это операции удобно выполнять с числами одинаковой длины, поэтому в старшие разряды меньшего числа нужно поместить нули
(если число положительно) или единицы (если число отрицательно). Тогда числа будут выглядеть следующим образом:
в старших разрядах бесконечное число нулей (единиц), а в младших разрядах уже встречаются и нули, и единицы,
которые кодируют само число, а не знак. 

Удобство заключается в том, что нам не обязательно проделывать операции сложения с каждой парой бит, 
если мы знаем, что на этом отрезке в числах стоят либо единицы, либо нули. Таким образом, на этом отрезке 
в получившемся числе тоже будут либо только единицы, либо только нули. Операцию сложения можно выполнить
только один раз для старших битов, таким образом, мы узнаем знак получившегося числа. 
Вычитание тоже выполняется просто: инвертируем число, прибавляем один и получаем это число с минусом,
затем просто делаем сложение. 

Однако умножение с числами, представленными дополнительным кодом, 
выполнять не всегда оптимально: алгоритм либо слишком медленный (наивный алгоритм работает за O(n^2)), 
либо слишком сложный. Лучше для умножения использовать прямой код (бит под знак). Тогда можно числа 
перевести в десятичную систему счисления, выполнить быстрое преобразование Фурье за O(n×logn), затем
перевести их обратно в двоичную. Обычно такой алгоритм работает быстрее, чем выполнение операции 
напрямую с двоичными числами. Для деления тоже лучше прямой код. 

Подробнее на эту тему в книге Эндрю Таненбаум «Архитектура компьютера». 

Представление вещественных чисел в памяти ПК.
=============================================

Вещественные числа обычно представляются в виде чисел с плавающей запятой. 
Числа с плавающей запятой — один из возможных способов представления действительных чисел, который является 
компромиссом между точностью и диапазоном принимаемых значений, его можно считать аналогом экспоненциальной записи чисел.
Число с плавающей запятой состоит из набора отдельных двоичных разрядов, условно разделенных на
так называемые знак (англ. sign), порядок (англ. exponent) и мантиссу (англ. mantis). 
В стандарте IEEE 754 число с плавающей запятой представляется в виде набора битов, 
часть из которых кодирует собой мантиссу числа, другая часть — показатель степени, и ещё один бит 
используется для указания знака числа (0 — если число положительное, 1 — если число отрицательное). 
При этом порядок записывается как целое число в коде со сдвигом, а мантисса — в нормализованном виде 
своей дробной частью в двоичной системе счисления. Порядок и мантисса — целые числа, которые вместе со знаком
дают представление числа с плавающей запятой в виде:  

(−1)^ S × M × B^E,

где S — знак, B — основание, E — порядок, а M — мантисса. 

Нормальной формой (англ. normal form) числа с плавающей запятой называется такая форма, в которой мантисса (без учёта знака) 
в десятичной системе находится на полуинтервале [0;1). Эта форма неоднозначна, поэтому используют 
нормализованную (англ. normalized), в которой мантисса десятичного числа принимает значения от 1 (включительно)
до 10 (не включительно), а мантисса двоичного числа принимает значения от 1 (включительно) до 2 (не включительно).
То есть в мантиссе слева от запятой до применения порядка находится ровно один знак.
В такой форме любое число (кроме 0) записывается единственным образом. Ноль же представить таким образом невозможно,
поэтому стандарт предусматривает специальную последовательность битов для задания числа 00 
(а заодно и некоторых других полезных чисел, таких как −∞ и +∞).

IEEE 754-2008 Standard for Floating-Point Arithmetic определяет представление и операции для чисел с плавающей точкой в
компьютерных системах. Рассматривает форматы хранения, правила арифметики (в том числе и правила округления),
стандартные и расширенные функции для типов одинарной (single), двойной (double), расширенной (extended) 
и расширяемой (extendable) точности, а также рекомендует форматы для обмена данными. В рамках используемых форматов определяет:

•	как представлять нормализованные и денормализованные  положительные и отрицательные числа с плавающей запятой; 
•	как представлять специальные величины «плюс бесконечность» и «минус бесконечность» (±Infinity, ±∞), ноль; 
•	исключительные ситуации: деление на ноль, переполнение, потеря значимости - результат операции становится настолько близким к нулю, что порядок числа выходит за пределы разрядной сетки, работа с денормализованными числами и другие;
•	как представлять специальные величины «Не число» (NaN, not a number). 

Неопределенность или NaN (от not a number) – это представление, придуманное для того, чтобы арифметическая операция
могла всегда вернуть какое-то не бессмысленное значение. В IEEE754 NaN представлен как число, в котором E=Emax+1, 
а мантисса не нулевая. Любая операция с NaN возвращает NaN. При желании в мантиссу можно записывать информацию,
которую программа сможет интерпретировать. Стандартом это не оговорено и мантисса чаще всего игнорируется. 

Как можно получить NaN? Одним из следующих способов: 

∞+(- ∞); 

0 × ∞ ;

0/0;  

∞/∞ ; 

sqrt(x), где x<0. 

По определению NaN ≠ NaN, поэтому, для проверки значения переменной нужно просто сравнить ее с собой.
Два вида NaN: тихий NaN (qNaN) и сигнализационный NaN (sNaN). NaN может нести полезную нагрузку, предназначенный для 
диагностической информации, указывающей источник, вызвавший NaN. Знак NaN не имеет никакого значения, но может быть
предсказуемым в некоторых случаях.

Денормализованные числа (англ. denormalized/subnormal numbers) - это способ увеличить количество представимых
числом с плавающей запятой значений около нуля, дабы повысить точность вычислений. Каждое значение денормализованного
числа меньше самого маленького нормализованного ("обычного") значения числа с плавающей запятой. 
Согласно стандарту, если порядок равен своему минимальному значению (все его биты — нули, а истинное значение
порядка равно его сдвигу) и все биты мантиссы равны нулю, то это ±0. Если же мантисса не равна нулю, 
то это число с порядком, на единицу большим минимального (все биты порядка, кроме младшего — нули) 
и данной мантиссой, целая часть которой считается равной нулю, а не единице. 

В IEEE 754-2008 денормализованные числа (denormal или denormalized numbers) были 
переименованы в subnormal numbers, то есть в числа, меньшие "нормальных". Поэтому их еще называют "субнормальными".

Типы чисел с плавающей точкой в С++ и их соответствие стандарту.
================================================================

Основная цель любой программы состоит в обработке каких-либо данных, например, чисел или текстов. 
Данные могут быть различного вида или типа и, в зависимости от этого, с ними можно выполнять разные действия.
В любом языке программирования каждая константа, переменная, результат вычисления выражения или функции
должны иметь определенный тип данных.

В некоторых языках программирования (Python, Matlab) тип данных можно явно не указывать – в таком случае 
он определяется автоматически. Начиная с С++ 11 такая возможность появилась и в С++ - для этого
нужно использовать ключевое слово auto.


.. code-block:: c

  auto i = 42; // i - int 
  auto l = 42LL; // l - long long 



Тип данных – это множество допустимых значений, которые может принимать тот или иной объект, 
а также множество допустимых операций, которые применимы к нему. В современном понимании тип также зависит 
от внутреннего представления информации.

Таким образом, данные различных типов хранятся и обрабатываются по-разному. Тип данных определяет:

•	внутреннее представление данных в памяти компьютера;
•	объем памяти, выделяемый под данные;
•	множество (диапазон) значений, которые могут принимать величины этого типа;
•	операции и функции, которые можно применять к данным этого типа.

Исходя из данных характеристик, необходимо определять тип каждой величины, используемой в программе для представления объектов.
Обязательное описание типа позволяет компилятору производить проверку допустимости различных конструкций программы.
От выбора типа величины зависит последовательность машинных команд, построенная компилятором.
Тип данных определяет размер памяти, выделяемой под переменную данного типа при ее создании.
Язык программирования C++ поддерживает следующие типы данных.

•	Базовые типы. Они предопределены стандартом языка, указываются зарезервированными ключевыми словами и характеризуются одним значением. Их не надо определять и их нельзя разложить на более простые составляющие без потери сущности данных. Базовые типы создают основу для построения сложных типов.
•	Производные типы. Производные типы задаются пользователем, и переменные этих типов создаются как с использованием базовых типов, так и типов классов.
•	Типы класса. Экземпляры этих типов называются объектами.
 
 
.. image:: {filename}/images/type data.png
   :width: 800





Void – это самый простой тип данных для объяснения. В основном он и означает «нет типа»! 
Следовательно, переменные не могут быть определены типом void.
Есть три типа данных с плавающей точкой (floating point): float, double и long double. 
На современных архитектурах они представляются в соответствии со стандартом IEEE 754. 

Рассмотрим floating point в стандарте IEEE 754:

===================  =============================  =============================  ==============  =================
Название в IEEE 754  Название типа переменной в Си  Диапазон значений переменной   Бит в мантиссе  Бит на переменную
Half precision       -                              6,10×10^(-5)..65504            11              16
Single presicion     float                          -3,4×10^(38)..3,4×10^(38)      23              32
Double precision     double                         -1,7×10^(308)..1,7×10^(308)    53              64
Extended precision   long double                    -3,4×10^(4932)..3,4×10^(4932)  65              80
===================  =============================  =============================  ==============  =================


В С++ float, double и long double определяются так:

Величина float занимает 4 байта. Из них 1 бит отводится для знака, 8 бит для избыточной экспоненты и 23 бита для мантиссы. 
Старший бит мантиссы всегда равен 1, поэтому он не заполняется, в связи с этим диапазон модулей значений переменной 
с плавающей точкой приблизительно равен от 3.14E–38 до 3.14E+38.

Величина типа double занимает 8 байтов. Ее формат аналогичен формату float. Биты памяти распределяются следующим образом:
1 бит для знака, 11 бит для экспоненты и 52 бита для мантиссы. С учетом опущенного старшего бита мантиссы
диапазон модулей значений переменной с двойной точностью равен от 1.7E–308 до 1.7E+308.

long double — это тип с плавающей запятой, размер которого больше или равен размеру типа double 
(зависит от конкретной системы, обычно 80 бит – диапазон тот же самый, а вот точность может быть больше). 

Узнать размер типа данных можно узнать с помощью функции sizeof. Вставьте и выполните следующий код (”\\t” – это символ табуляции):


.. code-block:: c

  #include <iostream>
  int main()
   {
    std::cout << "bool:\t\t" << sizeof(bool) << " bytes" << std::endl;
    std::cout << "char:\t\t" << sizeof(char) << " bytes" << std::endl;
    std::cout << "wchar_t:\t" << sizeof(wchar_t) << " bytes" << std::endl;
    std::cout << "char16_t:\t" << sizeof(char16_t) << " bytes" << std::endl; // C++11 
    std::cout << "char32_t:\t" << sizeof(char32_t) << " bytes" << std::endl; // C++11
    std::cout << "short:\t\t" << sizeof(short) << " bytes" << std::endl;
    std::cout << "int:\t\t" << sizeof(int) << " bytes" << std::endl;
    std::cout << "long:\t\t" << sizeof(long) << " bytes" << std::endl;
    std::cout << "long long:\t" << sizeof(long long) << " bytes" << std::endl; // C++11
    std::cout << "float:\t\t" << sizeof(float) << " bytes" << std::endl;
    std::cout << "double:\t\t" << sizeof(double) << " bytes" << std::endl;
    std::cout << "long double:\t" << sizeof(long double) << " bytes" << std::endl;
    return 0;
   }



Ошибки вычислений. Машинная точность.
=====================================

Числа представленные в формате IEEE754 представляют конечное множество, на которое отображается бесконечное 
множество вещественных чисел. Поэтому исходное число может быть представлено в формате IEEE754 с ошибкой.
 
 
.. image:: {filename}/images/machine.jpg
   :width: 800
 
 
 
Абсолютная максимальная ошибка для числа в формате IEEE754 равна в пределе половине шага чисел. 
Шаг чисел удваивается с увеличением экспоненты двоичного числа на единицу. Чем дальше от нуля, 
тем шире шаг чисел в формате IEEE754 по числовой оси.

Стандарт IEEE 754 широко применяется в технике и программировании.
Большинство современных микропроцессоров изготовляются с аппаратной реализацией представления 
вещественных переменных в формате IEEE754. 
Язык программирования и программист не могут изменить эту ситуацию, иного преставления
вещественного числа в микропроцессоре не существует.
Когда создавали стандарт IEEE754-1985 представление вещественной переменной в виде 4 или 8 байт казалось
очень большой величиной, так как объём оперативной памяти MS-DOS был равен 1 Мб. А, программа в этой
системе могла использовать только 0,64 Мб. Для современных ОС размер в 8 байт является ничтожным, 
тем не менее переменные в большинстве микропроцессоров продолжают представлять в формате IEEE754.

Рассмотрим ошибки вычислений, вызванные применением чисел в формате IEEE754:

1)	Ошибки, связанные с точностью представления вещественных чисел в формате IEEE754. Опасная редукция.
Радует только то, что величина относительной ошибки имеет размерность для single 10^-6 для double 10^-14.
Величины абсолютных ошибок могут быть значительными, максимально для single 10^31 и для double 10^292, что 
может вызывать определённые проблемы вычислений. Для примера запустим код:


.. code-block:: c

    int main(int argc, char *argv[])
		{    
			float a, b, f;
			a=123456789; 
			b=123456788;     
			f=a-b;	
        		cout << "Result: " <<  f << endl;
     			return 0;
		}
    
     
Относительная погрешность исходных чисел приблизительно равна 3,24e-6%
В результате одной операции относительная погрешность результата стала 800%, т.е. увеличилась в 2,5e+8 раз. 
Эту особенность следует учитывать при вычислениях.

2)	Ошибки, связанные с неправильным приведением типов данных. Эти ошибки вызваны тем, что исходное число, 
представленное в формате single и в формате double –обычно не совпадает по значению в разных форматах. 

Например: исходное число 123456789,123456789.  Single: 4CEB79A3=+123456792,0(dec).

Double: 419D6F34547E6B75=+123456789,12345679104328155517578125.

Разница между Single и Double составит: 2,87654320895671844482421875.

Эта ошибка зависит также от вида компилятора. Чтобы минимизировать её влияние, рекомендуется использовать тип double,
так как все промежуточные вычисления в ходе вычисления программой различных числовых выражений
(например, в выражении попалась дробь 1/7) производятся в double, и этом может приводить к ошибкам. 


3)	Ошибки, вызванные сдвигом мантисс. Циклические дыры. Эти ошибки связаны с потерей точности результата
при неполном пересечении мантисс чисел на числовой оси. Если мантиссы чисел не пересекаются на числовой оси,
то операции сложения и вычитания между ними невозможны. Это происходит, если числа отличаются более чем в 2^23 (для single)
и 2^52 (для double). Для каждого исходного числа существует предел выполнения цикла называемый "циклической дырой":
если существует цикл, в котором исходное число суммируется к сумме, то существует численный предел суммы для этого числа.
То есть сумма, достигнув определённой величины, перестает увеличиваться от сложения её с исходным числом.
Нередко основная работа программиста заключается в борьбе с погрешностями, а не в математических решениях
поставленной задачи. Программисту приходится вычислять погрешность результата в каждом цикле, чтобы 
учесть её в следующем цикле. Программист должен быть абсолютно готов к тому, что многие основные понятия 
математики будут не выполняться в машинной арифметике. 

Например, правило (a+b) + c = (a+c) + b, обычно не выполняется. 


4)	Ошибки, вызванные округлением. Грязный ноль – когда переменная, которая должна быть равна нулю,
не равна нулю из-за округления, которое делает процессор – вследствие этого относительная погрешность
результата может достигать бесконечности. 

5)	Ошибки на границе норма/денорма числа. Числа убийцы. 

Эти ошибки возникают при работе с числами находящимися на границе нормализованного/денормализованного представления чисел.
Они связаны с различием в представления чисел в формате IEEE754 и в различии формул перевода формата IEEE754
в вещественные числа. То есть устройства (или программы) должны применять различные алгоритмы в зависимости 
от положения вещественного числа на числовой оси формата. 

Кроме того, что это приводит к усложнению устройств и алгоритмов, ещё возникает неопределённость переходной зоны.
Неопределённость переходной зоны заключается в том, что стандарт не определяет конкретного значения границы перехода.
По сути дела граница перехода находится между двумя вещественными числами: последним денормализованным числом 000FFFFFFFFFFFFF.

Точное десятичное значение этого числа:

+2,22507385850720088902458687608585988765042311224095946549352480256244000922823569517877588880375915526

42309780950434312085877387158357291821993020294379224223559819827501242041788969571311791082261043971979

60400045489739193807919893608152561311337614984204327175103362739154978273159414382813627511383860409424

94649422863166954291050802018159266421349966065178030950759130587198464239060686371020051087232827846788

43631944515866135041223479014792369585208321597621066375401613736583044193603714778355306682834535634005

07407304013560296804637591858316312422452159926254649430083685186171942241764645513713542013221703137049

65832101546540680353974179060225895030235019375197730309457631732108525072993050897615825191597207572324

55434770912461317493580281734466552734375e-308

и первым нормализованным числом 0010000000000000. Точное значение этого числа:

+2,225073858507201383090232717332404064219215980462331830553327416887204434813918195854283159012511020564

067339731035811005152434161553460108856012385377718821130777993532002330479610147442583636071921565046942

503734208375250806650616658158948720491179968591639648500635908770118304874799780887753749949451580451605

050915399856582470818645113537935804992115981085766051992433352114352390148795699609591288891602992641511

063466313393663477586513029371762047325631781485664350872122828637642044846811407613911477062801689853244

110024161447421618567166150540154285084716752901903161322778896729707373123334086988983175067838846926092

773977972858659654941091369095406136467568702398678315290680984617210924625396728515625e-308

Так как граница является вещественным числом, то её точность можно задавать до бесконечности и цифровому устройству
или программе может не хватить разрядности для принятия решения, к какому диапазону отнести число. Для примера можно привести баг https://bugs.php.net/bug.php?id=53632 , который вызвал панику в 2011-м.

Ввод числа 2.2250738585072011e-308 вызывал зависание процесса со 100 % загрузкой процессора. 
Сообщение о баге поступило 30.12.2010, исправлено было 10.01.2011.

Так как PHP препроцессор используют большинство серверов, то у любого пользователя сети в эти 10 дней была
возможность вырубить большую часть информационные ресурсов планеты, используя данную уязвимость.

С ошибками округления связано огромное количество крупных аварий, например:

– Взрыв ракеты "Пэтриот» в Саудовской Аравии 25 февраля 1991, который привел к гибели 28 человек, связан с ошибками округления.

– Взрыв ракеты Ариан-5 сразу после старта при ее первом испытании во Французской Гвиане 4 июня 1996 был следствием переполнения числовой сетки компьютера.

– 23 августа 1991 в Гандсфиорде в Норвегии затонула нефтяная платформа, что привело к убытку почти в один миллиард долларов – из-за ошибок округления при выполнении конечно-элементного анализа при моделировании.

Помимо ошибок округления, в машинных вычислениях есть ещё два источника ошибок – погрешности 
используемых методов и неопределённость входных данных.

Дискретизация – замена непрерывной функции на таблицу значений в конечном количестве точек или на каком-либо дискретном множестве. 

Обусловленность задачи – малость чувствительности решения задачи от малого изменения входных данных.
Если решение слишком чувствительно, то задача плохо обусловленная («эффект бабочки», моделирование погоды).

При разработке программ необходимо учитывать все источники ошибок. 

Когда мы выводим числа с плавающей запятой, то cout, по умолчанию, имеет точность 6. 
То есть, в консольном окне мы увидим только 6 значащих цифр, всех остальных не будет. Запустим код:


.. code-block:: c

    #include <iostream>
    #include <iomanip>
    int main()
     { 
        double d(0.1);
        std::cout << d << std::endl; // используем точность cout по умолчанию (6 цифр)
        std::cout << std::setprecision(17);
        std::cout << d << std::endl;
        return 0;
     }

    


В нижней же строке, после того, как мы изменили точность по умолчанию в cout до 17 цифр, мы видим, что переменная d – это не совсем 0.1! Подобное происходит из-за ограничений в количестве выделяемой памяти типу double, и в необходимости урезать (округлять) числа. Это и называется — ошибка округления.

Есть две специальные категории чисел типа с плавающей запятой. Первая — Inf, что значит infinity (бесконечность). 
Inf может быть положительной или отрицательной. Вторая — NaN, что значит “Not a Number” (не число). 
Есть несколько разных видов NaN (их мы здесь обсуждать не будем). 

Запустим код:

.. code-block:: c

    #include <iostream>
    int main()
    {
      double zero = 0.0;
      double posinf = 5.0 / zero; // положительная бесконечность 
      std::cout << posinf << "\n";
      double neginf = -5.0 / zero; // отрицательная бесконечность 
      std::cout << neginf << "\n";
      double nan = zero / zero; // не число (математически неверно)
      std::cout << nan << "\n";
      return 0;
    }



Упражнение 1.
=============

Напишите программу, которая создаёт файл ”in.txt”, записывает туда с помощью генератора случайных чисел три числа,
первое из которых случайное вещественное типа double в интервале от 0.1 до 10 с шагом 0.1, второе случайное в 
интервале от 1000000.0 до 1001000.0  с шагом 0.1, третье – от 1000000000000.0  до 1001000000000.0  с шагом 0.1. 

После этого программа должна считывать их под именами a, b , c и определять, какой из способов сложения даёт наиболее
точный ответ. Программа должна создать выходной файл ”out.txt”, записать в него каждый раз с новой строки:

1)	Значение переменной a;

2)	Значение переменной b;

3)	Значение переменной c;

4)	Значение  (a+b) + c;

5)	Значение  (c+b) + a;

6)	Значение  (c+a) + b;

Пример генерации случайных чисел, чтения и записи в файл:

.. code-block:: c

    #include <iostream>
    #include <fstream>
    #include <cstdlib>
    #include <ctime>
    using namespace std;
    int main ()
     {
      int a, b, c , a1, b1, c1, N; N = 100 ;
      ofstream fout("out.txt");  
      a = (rand() % N);  
      srand ( time(NULL) );  
      b = (rand() % N);   
      srand ( 1 );  
      c = (rand() % N);   
      fout << a << " "; 
      fout  << b << " "; 
      fout  << c << " ";  
      fout.close(); 
      ifstream fin("out.txt");
      fin >> a1 >> b1 >> c1; 
      fin.close();    
      cout  << a1 << endl << b1  << endl << c1 << endl;
      return 0;
     }



Модуль cmath. Математические функции С++.
=========================================


Машинная обработка числовых данных обычно сводится к анализу данных, которые заданы таблицами чисел.
Математические методы удобно применять, приближая эти таблицы чисел теми или иными непрерывными функциями.
Чаще всего используют аналитические функции (бесконечно много раз непрерывно дифференцируемые). 

Модуль <cmath> содержит много очень распространённых аналитических функций. 

Полный список с подробным описанием можно найти, например, по ссылке
https://en.cppreference.com/w/cpp/header/cmath .

Скопируйте и запустите код:

.. code-block:: c

    #include <iostream>
    #include <cmath>
    using namespace std;
    int main(int argc, char* argv[])
    {   
    cout << "log10(10)     = " << log10(10.0)   << endl; // логарифм десятичный  
    cout << "log10(1)      = " << log10(1.0)    << endl;  
    cout << "log2(16)      = " << log2(16.0)    << endl; // логарифм двоичный 
    cout << "log(2.718281) = " << log(2.718281) << endl; // натуральный логарифм(по основанию экспоненты) exp = 2.718281
    cout << "sqrt(9)       = " << sqrt(9.0)     << endl; // корень квадратный
    cout << "cbrt(27)       = " << cbrt(27.0)     << endl; // корень кубический
    cout << "pow(2,3)      = " << pow(2.0,3.0)  << endl; // два в кубе 
    cout << "abs(0)        = " << abs(0.0)      << endl; // модуль от нуля
    cout << "abs(-5)       = " << abs(-5.0)     << endl; 
    cout << "ceil(3.14)    = " << ceil(3.14)    << endl; // округление 3.14 до наименьшего целого, но не меньше чем 3.14    
    cout << "ceil(-2.4)    = " << ceil(-2.4)    << endl; // округление -2.4 до наименьшего целого, но не меньше чем -2.4    
    cout << "floor(3.14)   = " << floor(3.14)   << endl; // округление 3.14 до наибольшего целого, но не больше чем 3.14   
    cout << "floor(-2.4)   = " << floor(-2.4)   << endl; // округление -2.4 до наибольшего целого, но не больше чем -2.4 
    cout << "round(3.5)   = " << round(3.5)   << endl; // симметричное округление 3.5 до ближайшего целого 
    cout << "round(-2.5)   = " << round(-2.5)   << endl; // симметричное округление -2.5  до ближайшего целого
    cout << "trunc(3.14)   = " << trunc(3.14)   << endl; // округление 3.14 отбрасыванием дробной части 
    cout << "trunc (-2.4)   = " << trunc(-2.4)   << endl; // округление -2.4  отбрасыванием дробной части
    cout << "exp(2.0)   = " << exp(2.0) << endl; // е  в степени 2
    cout << "sin(2.0)   = " << sin(2.0) << endl; // синус 2
    cout << "cos(2.0)   = " << cos(2.0) << endl; // косинус 2
    cout << "tan(2.0)   = " << tan(2.0) << endl; // тангенс 2
    cout << "asin(0.5)   = " << asin(0.5) << endl; // арксинус 0.5
    cout << "acos(0.5)   = " <<acos(0.5) << endl; // арккосинус 0.5
    cout << "atan(2.0)   = " << atan(2.0) << endl; // арктангенс 2
    cout << "atan2(2.0/3.0)   = " << atan2(2.0/3.0) << endl; // арктангенс от 2/3 с учётом знака квадранта, угол выдаёт в полуинтервале (-π, π)
    cout << "hypot(3.0, 4.0)   = " << hypot(3.0, 4.0) << endl; // корень суммы квадратов
    cout << "sinh(2.0)   = " << sinh(2.0) << endl; // гиперболический синус 2
    cout << "cosh(2.0)   = " << cosh(2.0) << endl; // гиперболический косинус 2
    cout << "tanh(2.0)   = " << tanh(2.0) << endl; // гиперболический тангенс 2
    cout << "asinh(0.5)   = " << asinh(0.5) << endl; // гиперболический арксинус 0.5
    cout << "acosh(0.5)   = " <<acosh(0.5) << endl; // гиперболический арккосинус 0.5
    cout << "atanh(2.0)   = " << atanh(2.0) << endl; // гиперболический арктангенс 2
    cout << "fmod(2.4/2.0)   = " << fmod(2.4,2.0) << endl; // остаток от деления 2.4/2
    cout << "fmax(2.4, 2.0)   = " << fmax(2.4,2.0) << endl; // максимум из двух чисел
    cout << "fmin(2.4, 2.0)   = " << fmin(2.4,2.0) << endl; // минимум из двух чисел
    cout << "fdim(2.4, 2.0)   = " << fdim(2.4,2.0) << endl; // максимум из (2.4 - 2, 0) 
    cout << "fabs( - 2.0)   = " << fabs(- 2.0) << endl; // модуль числа (-2)
    cout << "fma(2.0, 3.0, 1.0)   = " <<  fma(2.0, 3.0, 1.0) << endl; // даёт 2*3 + 1
    return 0;
    }


Помимо выведенного этим кодом на экран, в <cmath> есть множество специальных функций, часто используемых в теории вероятностей
и статистике,  в задачах математической физики и тому подобных. Есть другие функции округления, функции работы 
с представлением вещественного числа в виде типа с плавающей запятой.

Математические константы не определены в стандарте C/C++. Чтобы использовать их, необходимо сначала определить
_USE_MATH_DEFINES, а затем cmath.


.. code-block:: c

    #define _USE_MATH_DEFINES
    #include <cmath>
    #include <iostream>
    using namespace std;
    int main() 
    { 
      cout <<" M_PI  = " << M_PI  << endl; // pi
      cout <<" M_PI_2  = " << M_PI_2 << endl; // pi/2
      cout <<" M_PI_4= " << M_PI_4 << endl;  //  pi/4
      cout <<" M_1_PI= " << M_1_PI<< endl;  // 1/pi
      cout <<" M_2_PI= " << M_2_PI<< endl;  // 2/pi
      cout <<" M_2_SQRTPI = " << M_2_SQRTPI<< endl; // 2/sqrt(pi)
      cout <<" M_SQRT2 = " << M_SQRT2 << endl; // sqrt(2)
      cout <<" M_SQRT1_ 2 = " << M_SQRT1_ 2 << endl; // 1/sqrt(2)
      cout <<" M_E = " << M_E << endl; // e
      cout <<" M_LOG2E = " << M_LOG2E << endl; // log_2(e)
      cout <<" M_LOG10E = " << M_LOG10E << endl; // log_10(e)
      cout <<" M_LN2 = " << M_LN2 << endl; // log_e(2)
      cout <<" M_LN10 = " << M_LN10 << endl; // log_e(10)
      return 0;
     }
     



Аналитические функции могут быть также рассмотрены как бесконечные многочлены.  Такие многочлены называются рядами Тейлора:
f(x) = a0 + a1(x-x0) + a2(x-x0)^2+ … 
Последовательность коэффициентов определяется следующим образом: n-й коэффициент равен значению производной функции 
в точке x0 , делённой на факториал n. 
Частный случай – ряд Маклорена, для которого x0 = 0. 

Простейшим способом вычисления ряда Тейлора является суммирование его членов в цикле до тех пор, пока погрешность 
не станет достаточно мала. Теоремы математического анализа позволяют оценить эту погрешность, и ещё Ньютон 
использовал простейший способ ускорения вычислений: пересчитать коэффициенты ряда вокруг точки, близкой к той,
которая вам нужна (это делается с помощью бинома Ньютона). Например, для тригонометрических функций достаточно 
замены переменной с использованием периодичности, формул приведения и того факта, что 3.5π приближённо равно 11. 

Эффективные методы суммирования рядов Тейлора существуют в комбинаторике и теории производящих функций для последовательностей чисел.
В этой теории сама функция f(x) по определению является производящей функцией для коэффициентов её ряда Маклорена.
Исследование производящих функций позволяет существенно ускорять вычисления. Например, один из простейших методов
ускорения заключается, в том, чтобы разложить ряд в произведение двух рядов, один из которых легко суммируется
до бесконечности, а второй - быстро сходящийся. 

Чтобы проще перемножать многочлены, их записывают с помощью векторов из коэффициентов и делают умножение,
аналогичное умножению в столбик, но без переноса разрядов. 

Например, arctg(x) = (x - (1/3)×x^3 + (1/5)×x^5 -.... 

Вектор:
V = <1, 0, -1/3, 0, 1/5, 0, -1/7, 0, 1/9, -1/11, …>

Для многочлена (1+x^2):  u  = <1, 0, 1, 0, 0, 0, 0, 0, 0, 0, …>

V*u = <1, 0, -1/3, 0, 1/5, 0, -1/7, …> + <0,  0,  1, 0, -1/3, 0, 1/5 ,…> = <1, 0, 2/3, 0, -2/15, …>

Нечётные коэффициенты, начиная с третьего, равны +2/(1×3), -2/(3×5), +2/(5×7), …

(1+x×x)^2)× arctg(x):  w = <1, 0, 2/3, 0, -2/15, …> + <0, 0, 1, 0, 2/3, 0, -2/15, …>

w = <1, 0, 5/3, 0, 8/15, 0, -8/105 , …> . 

Нечётные коэффициенты, начиная с пятого:  +8/(1×3×5), -8/(3×5×7), +8/(5×7×9), …

arctg(x) = (1/(1+x×x)^2)× (x + (5/3)×x^3 + 8×(x^5/15 - x^7/105 + x^9/315 - x^11/693 +....). 

Если подставить x = 1, то получается неплохая формула для вычисления числа Пи :

Pi = 1 + (5/3) + 8×(1/15 - 1/105 + 1/315 - 1/693 + 1/1287 - ....), причём общая формула для вычисления коэффициентов:

Pi = A1 + A2 + …; An = (-1)^n × 8/((2n-3)×(2n-1)×(2n+1)) 

Формула членов ряда функции arctg(x)×(1+x×x)^N. для произвольного N аналогичная.

Без этого приёма считать число Пи через арктангенс было бы сильно сложнее:

Pi = 4×(1 – 1/3 + 1/5 – 1/7 + 1/9 –  …). 

Так можно неограниченно ускорять (правда, первые слагаемые будет считать несколько сложнее, зато намного быстрее потом),
если увеличивать степень (1+x×x)^N. 

Работает этот метод в общем виде так - нужно оценить скорость сходимости. Тогда, если ряд знакопеременный, 
то подбираем функцию, разлагаемую в знакопостоянный ряд и наоборот. Главное - чтобы скорость сходимости 
была очень похожей. Тогда второй ряд окажется быстро сходящимся, потому что при перемножении рядов 
(исходного на ряд подобранной функции) соседние члены будут сокращать друг друга. А подобранная функция 
должна быть такая, чтобы её было легко посчитать по формуле, без рядов.

В таблице http://www.genfunc.ru/theory/pril03/  указаны основные производящие функции, которые обычно требуются 
для решения типичных задач.
Все суммы  выполняются по переменной n от 0 до бесконечности, если не указано иное. 
Элементы последовательности нумеруются от 0.

.. image:: {filename}/images/table func.jpg
   :width: 600




Упражнение 2.
=============

Напишите программу, которая с помощью указанной выше формулы ускоренного вычисления арктангенса вычисляет число
Пи и по формуле Pi = 4×(1 – 1/3 + 1/5 – 1/7 +  …). 

Возьмите 20 членов ряда и сравните оба полученных числа с более точным значением Пи, которое возьмите 
с помощью встроенной константы M_PI  .

Упражнение 3.
=============

Напишите программу, которая с помощью бинома Ньютона с дробной степенью вычисляет  кубический корень из 730.
Для построения ряда использовать, что 9^3 = 729. 



Численное интегрирование.
=========================


Основные методы численного интегрирования основаны на том, что аналитическую функцию можно приближать 
многочленами и делать оценку точности с помощью теоремы Лагранжа. Согласно ей, если функция непрерывна
на отрезке [a, b] и дифференцируема на интервале (a, b), то существует на этом отрезке точка с такая, 
что производная в ней равна (f(b) – f(a)) / (b – a) . Геометрически это можно сформулировать так: 
на отрезке [a, b]  найдётся точка, в которой касательная  параллельна хорде,  проходящей через точки графика, 
соответствующие концам отрезка.

.. image:: {filename}/images/Lagrange.jpg
   :width: 600

 
Отсюда следует, в частности, что f(b) – f(a) по модулю не превосходит  произведения максимального 
значения модуля производной на интервале на длину интервала.

Используя эту теорему, можно сделать оценку погрешности в формуле Тейлора и, интегрируя ряд Тейлора,
оценить погрешность метода численного интегрирования. 

Есть два основных метода поиска формулы численного интегрирования – через интегрирование  интерполяционного полинома
(многочлен, совпадающий с данной функцией в N точках на отрезке – квадратурные формулы Ньютона-Котеса)
и через метод неопределённых коэффициентов (квадратурные формулы Эйлера). Примеры: 

Метод Симпсона:  I = (b – a)(f(a) + 4f((a+b)/2) + f(a))/6

Формула Эйлера по двум точкам: I = (b – a)×(f[(a+b)/2-(b-a)/(2×sqrt(3))] + f[(a+b)/2 + (b-a)/(2×sqrt(3))])/2

Наиболее эффективным является метод Гаусса - Кронрода, который комбинирует оба способа. В нём особым образом выбираются 
как коэффициенты при обозначениях функции, так и точки, в которых эти значения считаются.


Упражнение 4.
=============

Используя метод Симпсона и формулу Эйлера по двум точкам, посчитайте интеграл от какой-нибудь аналитической функции 
на отрезке [0,1]. Сравните с точным ответом оба метода и выведите в текстовый файл “out4.txt” погрешности методов. 

Повторите то же самое, разбивая отрезок на N отрезков одинаковой длины и на каждом из них вычисляя интеграл по 
соответствующим формулам.


Дополнительные задачи.
======================


Задача 1.
=========

Запустите код.


.. code-block:: c

    #define _USE_MATH_DEFINES
    #include <iostream>
    #include <cmath>
    int main()
    {
    std::cout << "remainder(+5.1, +3.0) = " << std::remainder(5.1,3) << '\n' 
              << "remainder(-5.1, +3.0) = " << std::remainder(-5.1,3) << '\n'
              << "remainder(+5.1, -3.0) = " << std::remainder(5.1,-3) << '\n'
              << "remainder(-5.1, -3.0) = " << std::remainder(-5.1,-3) << '\n';
    std::cout << "remainder(-0.0, 1.0) = " << std::remainder(-0.0, 1) << '\n'
              << "remainder(5.1, Inf) = " << std::remainder(5.1, INFINITY) << '\n';
     }


     



1)	Что делает функция remainder? 

2)	 Используя её, напишите программу, которая будет вычислять НОД двух чисел.

3)	Напишите программу, которая делает то же самое, что и remainder.


Задача 2.
=========


Для ускорения вычисления экспоненты используют формулу: exp[x] = (exp[x/N])^N.

Удобно подобрать N так, чтобы x/N << 1. Затем вводят y = exp[x/N]) – 1. После этого по биному Ньютона можно посчитать (1+y)^N.

Реализуйте это программно. Входные данные: x и точность eps (для оценки точности просто сравнивайте с
более точным значением , которое получается при увеличении количества использованных членов ряда Маклорена в обоих случаях).


Задача 3.
=========

Придумайте аналогичный алгоритм для натурального логарифма и реализуйте его. 

Задача 4.
=========

Пусть функция f(x) задаётся значениями в точках x = 1, 2, 3, которые записаны в текстовом файле “spline.txt”.
Построить приближение этой функции  квадратичным сплайном (куски парабол на отрезках [1,2] и [2,3],
в заданных точках совпадают по значению с функцией, их производные в точке 2 равны друг другу).

Используя это приближение, вычислить интеграл от функции по формуле Симпсона для указанных двух отрезков.

Задача 5.
=========

Написать программу, которая по числам во входном файле (пары значений x и y, заранее неизвестно, сколько их)
вычисляет коэффициенты интерполяционного полинома, проходящего через все эти точки, и выводит эти коэффициенты на экран.
При решении этой задачи нельзя пользоваться массивами (нужно придумать алгоритм, для работы которого не нужны массивы).
