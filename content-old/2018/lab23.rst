Функциональное программирование. Клеточные Автоматы
###################################################

:date: 2019-03-17
:summary: Функциональное программирование. Клеточные Автоматы.
:status: published

.. default-role:: code

.. contents:: Содержание


Функциональное программирование
===============================

Функциональное программирование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании) и предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).

Как правило, когда рассматривают функциональное программирование в Python, то подразумевают следующие функции: `lambda`, `map`, `filter`, `reduce`, `zip`.

lambda
------

`lambda` функция в Python это способ создать анонимную функцию, то есть функцию без имени. Такие функции можно назвать одноразовыми, они используются только при создании. Как правило, `lambda` функции используются в комбинации с функциями `filter`, `map`, `reduce`.

Синтаксис `lambda` выражения в Python

.. code-block:: python

   lambda arguments: expression

В качестве  `arguments` передается список аргументов, разделенных запятой, после чего над переданными аргументами выполняется `expression`. Если присвоить `lambda`-функцию переменной, то получим поведение как в обычной функции:

.. code-block:: python

   sum = lambda x,y: x + y
   print (sum(4, 5))
   
   9


Преимущества использования `lambda`-выражений особенно проявляются в связке с другими функциями.


map
---

В Python функция `map` принимает два аргумента: функцию и аргумент составного типа данных, например, список. Функция `map` применяет к каждому элементу списка переданную функцию. Например, чтобы превратить список чисел, представленных в виде строк в список чисел, можно воспользоваться `map`:

.. code-block:: python

   # Преобразование с помощью цикла, без использования map: 
   str_list = ['1', '2', '3', '4', '5', '6', '7']
   int_list = []
   
   for item in str_list:
       int_list.append(int(item))
   
   # Преобразование с помощью цикла, с использованием map: 
   int_list_map = list(map(int, str_list))
   
   print (int_list)
   print (int_list_map)
   
   
   [1, 2, 3, 4, 5, 6, 7]
   [1, 2, 3, 4, 5, 6, 7]


Использование функции `map` занимает меньше строк кода, делает его более читабельным и более быстрым. Функция `map` также работает и с функциями созданными пользователем:

.. code-block:: python

   def cels_to_fahr(cels):
     return 32 + cels * 1.8
   
   cels_temps = [0, 4, 20, 36, 100]
   fahr_temps = list(map(cels_to_fahr, cels_temps))
   print (fahr_temps)
   

   [32.0, 39.2, 68.0, 96.8, 212.0]


Это преобразование можно осуществить используя `lambda`-выражение:

.. code-block:: python

   cels_temps = [0, 4, 20, 36, 100]
   fahr_temps = list(map(lambda x: 32 + x * 1.8, cels_temps))
   print (fahr_temps)
   

   [32.0, 39.2, 68.0, 96.8, 212.0]


Функция `map` может быть так же применена для нескольких списков, в таком случае функция-аргумент должна принимать количество аргументов, соответствующее количеству списков:

.. code-block:: python

   lx = [1, 2, 3]
   ly = [4, 5, 6]
   
   res_list = list(map(lambda x,y: x + y, lx, ly))
   print (res_list)
   

   [5, 7, 9]

Если же количество элементов в списках совпадать не будет, то выполнение закончится на минимальном списке:

.. code-block:: python

   lx = [2,3]
   ly = [4,5,6]
   
   res_list = list(map(lambda x,y: x + y, lx, ly))
   print (res_list)
   
   
   [6, 8]


filter
------

Функция filter предлагает простой вариант фильтрации элементов последовательности. Принимает в качестве аргументов функцию и последовательность, которую необходимо отфильтровать:

.. code-block:: python

   nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   even_nums =  list(filter(lambda x: x%2 == 0, nums))
   print (even_nums)
   
   
   [2, 4, 6, 8, 10]


Функция, передаваемая в `filter` должна возвращать значение `True` / `False`, чтобы элементы корректно отфильтровались.

reduce
------

Функция `reduce` принимает 2 аргумента: функцию и последовательность. Функция `reduce` последовательно применяет функцию-аргумент к элементам списка, возвращает единичное значение. В Python 2.x функция reduce доступна как встроенная, в то время, как в Python 3 она была перемещена в модуль `functools`.

Вычисление суммы всех элементов списка при помощи `reduce`:

.. code-block:: python

   from functools import reduce
   
   items = [1,2,3,4,5]
   sum_all = reduce(lambda x,y: x + y, items)
   
   print (sum_all)
   

   15


Вычисление наибольшего элемента в списке при помощи reduce:

.. code-block:: python

   from functools import reduce
   
   items = [1, 24, 17, 14, 9, 32, 2]
   all_max = reduce(lambda a,b: a if (a > b) else b, items)
   
   print (all_max)
   

   32


zip
---

Функция `zip` объединяет в кортежи элементы из последовательностей переданных в качестве аргументов.

.. code-block:: python

   a = [1,2,3]
   b = "xyz"
   c = (False, True)
   
   res = list(zip(a, b, c))
   print (res)
   
   
   [(1, 'x', False), (2, 'y', True)]


Функция `zip` прекращает выполнение, как только достигнут конец самого короткого списка.


Клеточный автомат
=================

`Клеточный автомат`__ — это математическая модель, описывающая эволюционирующую во времени систему, состояние которой в
каждый момент времени определяется её состоянием в предыдущий момент. Клеточный автомат состоит из набора клеток, для
каждой из которых задана окрестность, т.е. набор соседних клеток. Для всего автомата в целом задаются правила изменения
состояния клетки в зависимости от состояния клеток, находящихся в её окрестности.

.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82

Одномерный клеточный автомат
----------------------------

Рассмотрим простейший пример одномерного клеточного автомата. Под одномерным клеточным автоматом в данном случае
понимается автомат, состоящий из клеток, выстроенных в линию. Т.е. в данном случае у каждой клетки есть ровно два соседа:
один слева и один справа.

Пусть поведение клеточного автомата подчиняется следующим правилам:

#. Клетка находится в одном из двух состояний: 1 или 0.
#. Состояние в следующий момент времени вычисляется следующим образом: `_A[i] = (A[i-1] + A[i+1]) % 2`. Т.е. клетка
   находится в состоянии 1, если в предыдущий момент в этом состянии находилась ровно одна соседняя клетка.

Пример программы, реализующей описанный выше клеточный автомат:

.. code-block:: python

   N = 35

   def cell_calculate(left, current, right):
       return left^right

   def calculate_field(field):
       """field -- список из N ноликов или единичек"""
       new_field = [0]*N
       for i in range(1, N-1):
           new_field[i] = cell_calculate(field[i-1], field[i], field[i+1])
       field[:] = new_field

   def generate_field():
       field = [0]*N
       x = N//2
       field[x] = 1
       return field

   def print_field(field):
       for cell in field:
           print('★' if cell else ' ' , end = '')
       print()

   def modelling():
       """ цикл моделирования клеточного автомата """
       field = generate_field()
       print_field(field)
       for t in range(15):
           calculate_field(field)
           print_field(field)

   if __name__ == '__main__':
       modelling()

Вывод программы:

.. code-block:: text

                 ★                 
                ★ ★                
               ★   ★               
              ★ ★ ★ ★              
             ★       ★             
            ★ ★     ★ ★            
           ★   ★   ★   ★           
          ★ ★ ★ ★ ★ ★ ★ ★          
         ★               ★         
        ★ ★             ★ ★        
       ★   ★           ★   ★       
      ★ ★ ★ ★         ★ ★ ★ ★      
     ★       ★       ★       ★     
    ★ ★     ★ ★     ★ ★     ★ ★    
   ★   ★   ★   ★   ★   ★   ★   ★   
  ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ 


Нетрудно заметить, что результат работы такого клеточного автомата внешне выглядит как дискретный аналог
`треугольника Серпинского`__.

.. __: https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%A1%D0%B5%D1%80%D0%BF%D0%B8%D0%BD%D1%81%D0%BA%D0%BE%D0%B3%D0%BE

Код Вольфрама
-------------

Если клетка автомата может находится только в двух состояниях, такой автомат называется бинарным. Одномерный бинарный клеточный автомат принято называть простейшим(элементарным), если состояние клетки в любой момент времени зависит только от её собственного состояния и состояния смежных клеток в предыдущий момент времени(окрестности радиуса 1).

Элементарных клеточных автоматов существует всего 256, так как состояний для трёх соседних клеток может быть 2**3, и для каждого состояния может быть два варианта задать новое значение центральной клетки.
Стивен Вольфрам предложил нумеровать эти автоматы числами от 0 до 255, это именование и называется `Код Вольфрама`__.

.. __: https://en.wikipedia.org/wiki/Wolfram_code

Способ нумерования: запишем конфигурации окрестности в виде двоичного числа и отсортируем конфигурации по убыванию. Тогда сам клеточный автомат можо представить как упорядоченный набор результирующих значений для каждой конфигурации, то есть тоже число в двоичной системе счисления, это и будет номер этого клеточного автомата. (Автомат из примера будет это номер 18)

Например для номера 110, в зависимости от состояний соседа слева, самой клетки и соседа справа (первая строка таблицы) на следующем шаге клетка примет одно из состояний, указанных во второй строке.

+-----+-----+-----+-----+-----+-----+-----+-----+
| 111 | 110 | 101 | 100 | 011 | 010 | 001 | 000 |
+=====+=====+=====+=====+=====+=====+=====+=====+
|  0  |  1  |  1  |  0  |  1  |  1  |  1  |  0  |
+-----+-----+-----+-----+-----+-----+-----+-----+

Упражнение №1
+++++++++++++

Напишите программу, реализующую элементарный коннечный автомат по его коду Вольфрама переданному на ввод. Программа должна считывать начальное состояние клеточной ленты из файла.

Указание: Чтобы вычислять значения клеток на концах нужно замкнуть автомат в кольцо - сделать крайнюю левую клетку правым соседом крайней правой и наоборот.

Игра «Жизнь» Джона Конвея
-------------------------

`Игра «Жизнь»`__ — это двумерный клеточный автомат, предложенный математиком Джоном Конвеем. Поведение этого клеточного
автомата подчиняется следующим правилам:

#. Автомат работает на плоскости, разделённой на одинаковые квадратные клетки.
#. Каждая клетка может находиться в двух состояниях: живая или мёртвая.
#. В начальный момент времени задано первое поколение — расположение живых клеток на плоскости.
#. Каждое следующее поколение рассчитывается исходя из состояния прошлого поколения по следующим правилам:

   * в мёртвой клетке зарождается жизнь, если у этой клетки ровно три живых соседних клетки;
   * если у живой клетки есть две или три живых соседних клетки, то клетка продолжает жить, в противном случае клетка
     погибает.

#. Игра завершается в трёх случаях:

   * все клетки погибли;
   * клетки сформировали устойчивую конфигурацию (т.е. на новом шаге не родилось и не погибло ни одной клетки);
   * клетки сформировали периодическую конфигурацию (т.е. клетки в точности повторили свою конфигурацию в один из
     предыдущих моментов).

.. __: https://ru.wikipedia.org/wiki/%D0%96%D0%B8%D0%B7%D0%BD%D1%8C_(%D0%B8%D0%B3%D1%80%D0%B0)

Упражнение №2
+++++++++++++

Напишите программу, реализующую игру «Жизнь». Программа должна считывать начальное состояние поля из текстового файла.

Упражнение №3
+++++++++++++

Проверьте свою программу при помощи известных конфигураций клеток:

* `осцилляторы`__;
* `космические корабли`__;
* `натюрморты`__;
* `планерное ружьё Госпера`__.

.. __: https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D1%86%D0%B8%D0%BB%D0%BB%D1%8F%D1%82%D0%BE%D1%80_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%81%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%BE%D1%80%D0%B0%D0%B1%D0%BB%D1%8C_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)
.. __: https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%82%D1%8E%D1%80%D0%BC%D0%BE%D1%80%D1%82_(%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B0)#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D1.8B.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B
.. __: http://www.conwaylife.com/w/index.php?title=Gosper_glider_gun



Использование numpy
===================

Python — язык для быстрой разработки. Однако чистый Python не предназначен для написания быстрых программ. Это интерпретируемый язык, поэтому программы на Python выполняются медленнее аналогов на C, C++ или Fortran. С другой стороны математики, физики, биологи и инженеры часто применяют Python для решения вычислительных задач, именно вычислительным мощностям Python и библиотека Numpy содержит быстро работающие библиотеки. 


Как замерять скорость?
----------------------


В Python для замера времени работы кода служит библиотека timeit. Например, мы можем замерить способы заполнить список из миллиона квадратных корней.


.. code-block:: python

   import timeit 

   print(timeit.timeit("[sqrt(x) for x in range(1000000)]", "from math import sqrt", number=1)) 
   print(timeit.timeit("for i in range(1000000): a.append(sqrt(i))", "from math import sqrt; a=[]", number=1)) 
   print(timeit.timeit("list(map(sqrt, range(1000000)))", "from math import sqrt; a=[]", number=1)) 



Как видим,  предпочтительно использовать map. Самый медленный способ — это, конечно же, динамическое расширение существующего списка (append). Причем, чем больше список — тем медленнее он меняет свой размер. Несмотря на относительную быстроту, скорость можно увеличить ещё примерно в 10 раз. Давайте посмотрим как.


Массивы в Numpy.
----------------

Основной объект в Numpy — это многомерный массив. Массивы — одна из базовых структур данных, которая позволяет моделировать многие объекты, относящиеся как к науке, так и к обычной жизни: список покупок, результаты наблюдения температуры, матрицы и вектора, изображения, видео и т. д. Массивы работают быстрее списков Python и могут содержать данные только одного типа. 

Напомним, что в чистом Python нет типа данных с именем массив, и нам приходится моделировать его с помощью списков. Другое дело numpy. За тип массива здесь отвечает объект array.

Как же создать массив? 

Пишем сначала:  import numpy as np .

Во-первых, массив можно сделать из обычного списка или диапазона :  np.array(range(10)); np.array([1, 4, 10, 34])

Во-вторых, с помощью функции fromiter():


.. code-block:: python

   np.fromiter(map(int, ["1", "2", "3", "4"]), dtype=np.int8) 


Функции для работы с массивами.
-------------------------------

В Numpy элементы одного массива должны быть одного типа. 

За тип элементов в большинстве случаев отвечает параметр dtype(data type). 


.. code-block:: python

   a = np.array([1, 3, 8], dtype=np.float64)
   
   

Размерность массива можно в любой момент изменить операцией reshape. 
Узнать размерность можно атрибутом shape. Например, a.reshape(5, 5, 4) – сделает массив трёхмерной матрицей.

Самое главное — при использовании функции reshape() произведение ее параметров должно быть равно количеству элементов в массиве. 


Есть много видов доступа к элементам массива:
 
 
A[1][2];   A[1,2];   A[(1,2)] – это всё обозначает одно и то же.


Можно использовать срезы – они дают другой массив.

Например, a[:, 2:4] – даст массив из исходного с использованием всех строк и двух столбцов (номер 2 и номер 3).


Кроме того, доступ можно организовать через списки с индексами:


Например, a[[1], [4, 4, 7, 8]] – это альтернатива срезам. 


Можете попробовать применять эти функции:

.. code-block:: python

   np.ones(10) # заполняем единицами
   np.ones(10, dtype=np.int32) # заполняем единицами целого типа
   np.zeros(30).reshape(5, 6) # заполняем нулями и сразу указываем форму
   np.random.randint(1, 10, (5, 5)) # заполняем случайными целыми из диапазона [1..10] и сразу указать форму
   np.random.random(10) # заполняем случайными вещественными числами из диапазона [0..1)
   np.fromstring("1, 3, 4, 5, 120", sep=",") # формируем массив из строки чисел, указывая разделитель
   np.fromfunction(lambda x, y: x*5+y, (3, 5), dtype=np.int8) # каждый элемент массива вычисляется по функции



Работают основные операции арифметики, сравнения, причем на всем массиве целиком. Введём:



.. code-block:: python

   a = np.random.randint(1, 5, 10) 
   b = np.random.randint(1, 5, 10)
   print(a); print(b)
   print(a>b) ; print(a+b) ; print(a*b) ; print(a**2)
   print(a[a>b]) ; print(a.sum())  ;  print(np.sqrt(a))
   
   
Решим ту же задачу по вычислению 1 миллиона корней с помощью numpy и посмотрим, какого ускорения мы добились:

.. code-block:: python

   timeit.timeit("np.sqrt(np.arange(1000000))", "import numpy as np", number=1)


На порядок быстрее!!!


Numpy позволяет очень эффективно работать с двумерными и вообще n-мерными массивами.

Заполним матрицу "последовательно" по строкам: a = np.arange(1,21).reshape(4,5)

Транспонируем матрицу (строки станут столбцами, а столбцы строками). Повернем матрицу вправо и влево.


.. code-block:: python

   b = a.transpose()
   b = np.rot90(a)
   c = np.rot90(a, -1)

 

Также в numpy предоставлено много и других функций для работы с данными – для вычислений, или, например, сортировки массивов.


Упражнение №4
+++++++++++++


Надо смоделировать шахматную доску, которая представляет собой numpy-матрицу. Черная клетка представляется нулем, а белая — единицей. Если смотреть на доску сверху, то левая верхняя клетка — белая. 

Напишите функцию makeﬁeld(size), в которую поступает размер доски и которая возвращает требуемый массив numpy. Тип элементов массива должен быть np.int8.


Упражнение №5
+++++++++++++


Змейка "ползет"по матрице по четным строкам слева направо, а по нечетным справа налево, заполняя матрицу последовательно натуральными числами. Напишите программу, которая заполняет матрицу указанным образом.


Формат ввода

На вход программы поступают два натуральных числа через пробел - размеры матрицы.


Формат вывода

Выведите полученную матрицу numpy с помощью функции print.


Примеры: 


Ввод 3 5 


Вывод [[ 1 2 3 4 5] [10 9 8 7 6] [11 12 13 14 15]]


Ввод 6 3 


Вывод  [[ 1 2 3] [ 6 5 4] [ 7 8 9] [12 11 10] [13 14 15] [18 17 16]]



Упражнение №6
+++++++++++++


Давайте попробуем написать игру «Жизнь», используя библиотеку numpy. 


Живые клетки обозначаются единицей, а мёртвые — нулём. Нужно решить, что делать на границах поля. Мы не можем обеспечить бесконечность в обоих направлениях, поэтому замкнём поле само на себя. Если выйти за нижнюю границу, мы окажемся наверху, а если за правую — появимся слева, и наоборот. Получается что-то вроде глобуса.


Для начала познакомимся с операцией roll, доступной для массивов. Она сдвигает исходный массив вдоль одного из измерений (в данном случае — строки или столбца). Мы можем посчитать количество соседей у каждой клетки, просто сделав 8 копий со сдвигом массива и просуммировав их.


.. code-block:: python

   neighbors = sum([
   np.roll(np.roll(population, -1, 1), 1, 0), np.roll(np.roll(population, 1, 1), -1, 0), np.roll(np.roll(population, 1, 1), 1, 0),
   np.roll(np.roll(population, -1, 1), -1, 0), np.roll(population, 1, 1), np.roll(population, -1, 1), np.roll(population, 1, 0),
   np.roll(population, -1, 0) ])


Теперь нужно получить новую популяцию. Выполним на матрице следующую операцию: «если у клетки 3 соседа, то в следующем поколении на этом месте будет клетка; а если 2 соседа, то клетка будет при условии, что она была "жива" в текущем поколении». Для этого воспользуемся операторами | (или) и & (и).


.. code-block:: python

   neighbors == 3
   population & (neighbors == 2)
   population = (neighbors == 3) | (population & (neighbors == 2)) 


Используя эти куски кода, напишите работающую программу. А затем измените её так, чтобы она давала возможность генерировать игру для произвольного правила игры, заданного кодом Вольфрама как входным параметром.


Для групп 838 и 843
===================

.. _`Хеширование и хеш-таблицы`: /algo/extra/Hash.pdf

`Хеширование и хеш-таблицы`_
