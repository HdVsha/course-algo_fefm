Массивы.
########


:date: 2018-10-15 09:00
:summary: Массивы.
:status: published 

.. default-role:: code









Что такое массивы?
==================





Массив – это структура данных, представленная в виде группы ячеек одного типа, объединенных под одним единым именем. 
Массивы используются для обработки большого количества однотипных данных. Имя массива является указателем.
Отдельная ячейка данных массива называется элементом массива.  Элементами массива могут быть  данные любого типа. 
Массивы могут иметь как одно, так и более одного измерений. В зависимости от количества измерений массивы делятся на 
одномерные массивы, двумерные массивы, трёхмерные массивы и так далее до n-мерного массива. 
Чаще всего в программировании используются одномерные и двумерные массивы. Массивы бывают статические и динамические.





Инициализация переменных.
=========================





Во время объявления переменных можно сообщить им значение путем помещения знака равенства и константы после имени переменной. 
Этот процесс называется инициализацией и в общем случае имеет вид:

тип имя_переменной — константа;

Ниже приведено несколько примеров:

.. code-block:: c

  char ch = 'а';
  int p = 2;
  float f = 1.05;

При объявлении переменной можно сразу не определять её значение:

.. code-block:: c

  char ch ; 
  int p ; 
  float f;


Указатели.
==========





Указатель – переменная, значением которой является адрес ячейки памяти. То есть указатель ссылается на блок данных  из 
области памяти, причём на самое его начало. Указатель может ссылаться на переменную или функцию. Для этого нужно знать
адрес переменной или функции. Так вот, чтобы узнать адрес конкретной переменной в С++ существует унарная операция взятия
адреса &. Такая операция извлекает адрес объявленных переменных, для того, чтобы его присвоить указателю.

Указатели используются для передачи по ссылке данных, что намного ускоряет процесс обработки этих данных (в том случае, 
если объём данных большой), так как их не надо копировать, как при передаче по значению, то есть, используя имя переменной.
В основном указатели используются для организации динамического распределения памяти, например при объявлении массива,
не надо будет его ограничивать в размере. Ведь программист заранее не может знать, какого размера нужен массив тому
или иному пользователю, в таком случае используется динамическое выделение памяти под массив. Любой указатель 
необходимо объявить перед использованием, как и любую переменную.

//объявление указателя

/*тип данных*/  * /*имя указателя*/;

Принцип объявления указателей такой же, как и принцип объявления переменных. Отличие заключается только в том, что перед именем
ставится символ звёздочки \*. Визуально указатели отличаются от переменных только одним символом. При объявлении указателей
компилятор выделяет несколько байт памяти, в зависимости от типа данных отводимых для хранения некоторой информации в памяти.
Чтобы получить значение, записанное в некоторой области, на которое ссылается указатель нужно воспользоваться операцией
разыменования указателя \*. Необходимо поставить звёздочку перед именем и получим доступ к значению указателя. 

Рассмотрим программу, которая будет использовать указатели.
В программировании принято добавлять к имени указателя приставку Ptr, таким образом, получится осмысленное имя указателя, 
и уже с обычной переменной такой указатель не спутаешь. 

.. code-block:: c

   #include <iostream>
   using namespace std;
   
   int main()
    {
    	int var = 123; // инициализация переменной var числом 123
    	int *ptrVar = &var; // указатель на переменную var (присвоили адрес переменной указателю)
    	cout << "&var    = " << &var << endl;// адрес переменной var содержащийся в памяти, извлечённый операцией взятия адреса 
    	cout << "ptrVar  = " << ptrVar << endl;// адрес переменной var, является значением указателя ptrvar 
   	cout << "var     = " << var << endl; // значение в переменной var
    	cout << "*ptrVar = " << *ptrVar << endl; // вывод значения содержащегося в переменной var через указатель, операцией разыменования указателя
    	return 0;
    }

Итак, программа показала, что строки 8 и 9 выводят идентичный адрес, то есть адрес переменной var, который содержится 
в указателе ptrvar. Тогда как операция разыменования указателя \*ptrvar обеспечивает доступ к значению, на которое
ссылается указатель. Указатели можно сравнивать на равенство или неравенство. Рассмотрим программу, которая будет
сравнивать адреса указателей.

.. code-block:: c

   #include <iostream>
   using namespace std;
   
   int main()
   {
    	int var1 = 123; // инициализация переменной var1 числом 123
   	int var2 = 99; // инициализация переменной var2 числом 99
    	int *ptrVar1 = &var1; // указатель на переменную var1
    	int *ptrVar2 = &var2; // указатель на переменную var2
    	cout << "var1    = " << var1 << endl;
    	cout << "var2    = " << var2 << endl;
    	cout << "ptrVar1 = " << ptrVar1 << endl;
    	cout << "ptrVar2 = " << ptrVar2 << endl;
    	if (ptrVar1 > ptrVar2) // сравниваем значения указателей, то есть адреса переменных
        	cout << "ptrVar1 > ptrVar2" << endl;
    	if (*ptrVar1 > *ptrVar2) // сравниваем значения переменных, на которые ссылаются указатели
        	cout << "*ptrVar1 > *ptrVar2" << endl;
     	return 0;
     }

В первом случае, мы сравнивали адреса  переменных, и, причём адрес второй переменной, всегда меньше адреса первой переменной. 
При каждом запуске программы адреса выделяются разные. Во втором случае мы сравнивали значения этих переменных, используя 
операцию разыменования указателя.

Указатели могут ссылаться на другие указатели. При этом в ячейках памяти, на которые будут ссылаться первые указатели, 
будут содержаться не значения, а адреса вторых указателей. Число символов * при объявлении указателя показывает 
порядок указателя. Чтобы получить доступ к значению, на которое ссылается указатель его необходимо разыменовывать
соответствующее количество раз. Рассмотрим программу, которая будет выполнять некоторые операции с указателями порядка выше первого.

.. code-block:: c

   #include <iostream>
   using namespace std;
   
   int main()
   {
    	int var = 123; // инициализация переменной var числом 123
    	int *ptrVar = &var; // указатель на переменную var
    	int **ptr_ptrVar = &ptrVar; // указатель на указатель на переменную var
    	int ***ptr_ptr_ptrVar = &ptr_ptrVar;
    	cout << " var\t\t= " << var << endl;
    	cout << " *ptrVar\t= " << *ptrVar << endl;
    	cout << " **ptr_ptrVar   = " << **ptr_ptrVar << endl; // два раза разименовываем указатель, так как он второго порядка 
    	cout << " ***ptr_ptrVar  = " << ***ptr_ptr_ptrVar << endl; // указатель третьего порядка
    	cout << "\n ***ptr_ptr_ptrVar -> **ptr_ptrVar -> *ptrVar ->      var -> " << var << endl;
    	cout << "\t  " << &ptr_ptr_ptrVar<< " -> " << "    " << &ptr_ptrVar << " ->" << &ptrVar << " -> " << &var << " -> " << var << endl;
    	return 0;
    }


Инициализация и использование массивов C++.
===========================================

Статические массивы определяются следующим образом:


.. code-block:: c

  int arr[5], a[6]; // определены два массива размерами 5 и 6 элементов.
          // пример объявление двумерного массива 10 на 8:
  int a[10][8];


Динамическое выделение памяти необходимо для эффективного использования памяти компьютера. 
Например, мы написали какую-то программку, которая обрабатывает массив. При написании данной 
программы необходимо было объявить массив, то есть задать ему фиксированный размер (к примеру, от 0 до 100 элементов).
Тогда данная программа будет не универсальной, ведь может обрабатывать массив размером не более 100 элементов. 
А если нам понадобятся всего 20 элементов, но в памяти выделится место под 100 элементов, ведь 
объявление массива было статическим, а такое использование памяти крайне не эффективно.

В С++ операции new и delete предназначены для динамического распределения памяти компьютера.
Операция new  выделяет память из области свободной памяти, а delete высвобождает выделенную память.
Выделяемая память, после её использования должна высвобождаться, поэтому операции new и delete используются парами.
Рассмотрим программу, в которой создаётся одномерный динамический массив, заполненный случайными числами:


.. code-block:: c

  #include <iostream>
  #include <ctime> 
  #include <iomanip>
  #include <cstdlib>
  using namespace std;
  
  int main()
   {
    	srand(time(0)); // генерация случайных чисел
	cout << " Введите размер массива ";
	int N;
	cin >> N;
    	float *ptrArray = new float [N]; // создание динамического массива вещественных чисел на десять элементов
        for (int count = 0; count < N; count++) 
        	ptrArray[count] = (rand() % 10 + 1) / float((rand() % 10 + 1)); //заполнение массива случайными числами с масштабированием от 1 до 10
        cout << "array = ";
        for (int count = 0; count < N; count++)
        	cout << setprecision(2) << ptrArray[count] << "    ";
        delete [] ptrArray; // высвобождение памяти 
        cout << endl;
    	return 0;
    }

  
Запустим программу, в которой в функции создаётся двумерный динамический массив и заполняется случайными числами, 
и функция распечатывает их.

.. code-block:: c

  #include <iostream>
  #include <algorithm>
  #include <ctime>
  #include <iomanip>
  #include <cstdlib>
  using namespace std;

  void initializemassive(float **ptrArray, int m, int n)
   {
     // заполнение массива 
    	for (int count_row = 0; count_row < m; count_row++) 
        	for (int count_column = 0; count_column < n; count_column++) 
            		ptrArray[count_row][count_column] = (rand() % 10 + 1) / float((rand() % 10 + 1)); //заполнение массива случайными числами с масштабированием от 1 до 10
    // вывод массива 
    	for (int count_row = 0; count_row < m; count_row++) 
    	{
        	for (int count_column = 0; count_column < n; count_column++) 
            		cout << setw(4) <<setprecision(2) << ptrArray[count_row][count_column] << "   ";
        	cout << endl;
    	}
   }

    int main()
   {
    	srand(time(0)); // генерация случайных чисел
    // динамическое создание двумерного массива вещественных чисел на десять элементов
    	float **ptrArray = new float* [2]; // две строки в массиве
    	for (int count = 0; count < 2; count++)
        	ptrArray[count] = new float [5]; // и пять столбцов
    	initializemassive (ptrArray, 2, 5);

    // удаление двумерного динамического массива
    	for (int count = 0; count < 2; count++) 
        	delete []ptrArray[count];
	 
	delete [] ptrArray;
    	return 0;
    }





Упражнение 1. 
=============

Напишите программу, которая создаёт одномерный статический массив размером 10 элементов из целых чисел и заполняет его нулями.
Выведите этот массив в файл “out.txt”. Напоминание работы с файлами:


.. code-block:: c

  ofstream   fout("out.txt");  
  fout << “hello world”;   
  fout.close();
  ifstream  fin("out.txt ");
  char  a1, b1, c1;
  fin >> a1 >> b1 >> c1; 
  fin.close();  


Упражнение 2.
=============

1)	Напишите программу, которая создаёт двумерный статический массив размером 10 на 20 элементов из целых чисел и заполняет его нулями.

2)	 Напишите программу, которая создаёт двумерный динамический массив размером 10 на 20 элементов из целых чисел и заполняет его нулями.


Упражнение 3.
=============

Напишите программу, которая создаёт двумерный динамический массив, определяет его размеры случайными числами от 2 до 10 
и заполняет случайными числами от -5 до 5.


Упражнение 4. 
=============



Вводится натуральное число A > 0. Требуется вывести такое минимально возможное нечётное натуральное число K, 
при котором сумма 1×2 + 3×4 + … + K×(K+1) окажется больше A. Напишите решение с помощью отдельной функции.



Упражнение 5. 
=============

Написать программу, при выполнении которой с клавиатуры считывается положительное целое число N, не превосходящее 109,
и определяется сумма цифр этого числа. Напишите решение с помощью отдельной функции.


Упражнение 6. 
=============

Написать программу, при выполнении которой с клавиатуры считывается натуральное число x, не превосходящее 1000, 
и выводится количество единиц в двоичной записи этого числа. Напишите решение с помощью отдельной функции.



Упражнение 7. 
=============



Факториалом натурального числа n (обозначается n!) называется произведение всех натуральных чисел от 1 до n.
Дано целое положительное число A. 
Необходимо вывести минимальное натуральное K, для которого 1! + 2! + … + K! > A.
Для решения этой задачи напишите программу с помощью отдельной функции.



Упражнение 8. 
=============

Вводится натуральное число A > 0. Разложить на множители число А и сохранить все простые множители в массив. 
Выведите этот массив на экран.



Алгоритм Евклида нахождения НОД (наибольшего общего делителя).
==============================================================



Даны два целых неотрицательных числа a и b. Требуется найти их наибольший общий делитель, т.е. наибольшее число, 
которое является делителем одновременно и a, и b. На английском языке "наибольший общий делитель" пишется 
"greatest common divisor", и распространённым его обозначением является gcd.
Когда оно из чисел равно нулю, а другое отлично от нуля, их наибольшим общим делителем, согласно определению, 
будет это второе число. Когда оба числа равны нулю, результат не определён (подойдёт любое число), 
мы положим в этом случае наибольший общий делитель равным нулю. Поэтому можно говорить о таком правиле: если 
одно из чисел равно нулю, то их наибольший общий делитель равен второму числу.


Данный алгоритм был впервые описан в книге Евклида "Начала" (около 300 г. до н.э.), хотя, вполне возможно, 
этот алгоритм имеет более раннее происхождение.

Функция, описанная ниже, реализует его :



.. code-block:: c

  int gcd (int a, int b) {
	while (b) {
		a %= b;
		swap (a, b);
	}
	return a;
  }



        

Функция  swap (a, b) определена в  <algorithm>. Она меняет местами значения a и b. 

Вычисление наименьшего общего кратного (least common multiplier, lcm) сводится к вычислению gcd следующим простым утверждением:

gcd(a, b) × lcm(a, b) = a × b.

Таким образом, НОК также можно вычислить с помощью алгоритма Евклида:


.. code-block:: c

  int lcm (int a, int b) {
    	return a / gcd (a, b) * b;
  }

        
Здесь выгодно сначала поделить на gcd, а только потом домножать на b, поскольку
это поможет избежать переполнений в некоторых случаях.


Числа Фибоначчи.
================



Числа Фибоначчи — математическая последовательность, каждый член которой является суммой двух предыдущих:

F(n) = F(n-1) + F(n-2). 

Сам Фибоначчи упоминал эти числа в связи с такой задачей:
"Человек посадил пару кроликов в загон, 
окруженный со всех сторон стеной. Сколько пар кроликов за год может произвести на свет эта пара,
если известно, что каждый месяц, начиная со второго, каждая пара кроликов производит на свет одну пару?". 

Индийские математики Гопала и Хемачандра упоминали числа этой последовательности в связи с количеством 
ритмических рисунков, образующихся в результате чередования долгих и кратких слогов в стихах или 
сильных и слабых долей в музыке. Число таких рисунков, имеющих в целом n долей, равно Fn.

Числа Фибоначчи появляются и в работе Кеплера 1611 года, который размышлял о числах, встречающихся 
в природе (работа "О шестиугольных снежинках").

Интересен пример растения — тысячелистника, у которого число стеблей (а значит и цветков) всегда есть число Фибоначчи.
Причина этого проста: будучи изначально с единственным стеблем, этот стебель затем делится на два, затем 
от главного стебля ответвляется ещё один, затем первые два стебля снова разветвляются, затем все стебли, 
кроме двух последних, разветвляются, и так далее. Таким образом, каждый стебель после своего появления 
"пропускает" одно разветвление, а затем начинает делиться на каждом уровне разветвлений, что и даёт в результате числа Фибоначчи.
Вообще говоря, у многих цветов (например, лилий) число лепестков является тем или иным числом Фибоначчи.

Также в ботанике известно явление ''филлотаксиса''. В качестве примера можно привести расположение семечек
подсолнуха: если посмотреть сверху на их расположение, то можно увидеть одновременно две серии спиралей
(как бы наложенных друг на друга): одни закручены по часовой стрелке, другие — против. Оказывается, что
число этих спиралей примерно совпадает с двумя последовательными числами Фибоначчи: 34 и 55 или 89 и 144. 
Аналогичные факты верны и для некоторых других цветов, а также для сосновых шишек, брокколи, ананасов, и т.д.

Для многих растений (по некоторым данным, 90% из них) верен и такой интересный факт.
Рассмотрим какой-нибудь лист, и будем спускаться от него вниз до тех пор, пока не достигнем листа, 
расположенного на стебле точно так же (т.е. направленного точно в ту же сторону). Попутно будем считать
все листья, попадавшиеся нам (т.е. расположенные по высоте между стартовым и конечным), но расположенными
по-другому. Нумеруя их, мы будем постепенно совершать витки вокруг стебля (поскольку листья расположены
на стебле по спирали). В зависимости от того, совершать витки по часовой стрелке или против, будет 
получаться разное число витков. Но оказывается, что число витков, совершённых нами по часовой стрелке, 
число витков, совершённых против часовой стрелки, и число встреченных листьев образуют 3 последовательных числа Фибоначчи.

По отношению к алгоритму Евклида числа Фибоначчи обладают тем замечательным свойством, что они
являются наихудшими входными данными для этого алгоритма.



Решето Эратосфена.
==================

Решето Эратосфена — алгоритм нахождения всех простых чисел до некоторого целого числа N, который
приписывают древнегреческому математику Эратосфену Киренскому. Название алгоритма говорит о принципе
его работы, то есть решето подразумевает фильтрацию, в данном случае фильтрацию всех чисел за 
исключением простых. По мере обработки массива чисел нужные числа (простые) остаются, а ненужные 
(составные) исключаются.

Сама проблема получения простых чисел занимает ключевое место в математике, на ней основаны некоторые
криптографические алгоритмы, например RSA.

Для нахождения всех простых чисел не больше заданного числа N нужно выполнить следующие шаги:

•	Заполнить массив из N элементов целыми числами подряд от 2 до N.

•	Присвоить переменной p значение 2 (первого простого числа).

•	Удалить из массива числа от p^2 до N с шагом p (это будут числа кратные p: p^2, p^2+p, p^2+2p и т. д.).

•	Найти первое не удаленное число в массиве, большее p, и присвоить значению переменной p это число.

•	Повторять два предыдущих шага пока это возможно.

Все оставшиеся в массиве числа являются простыми числами от 2 до N.

Пример реализации на С++:



.. code-block:: c

  #include <iostream>
  using namespace std;
  
  int main()
   {
  	int n;
  	cout << "n = ";
  	cin >> n;
  	int *a = new int[n + 1];
  	for (int i = 0; i < n + 1; i++)
    		a[i] = i;
  	for (int p = 2; p < n + 1; p++)
  	 {
    		if (a[p] != 0)
    		{
     			cout << a[p] << endl;
     	for (int j = p * p; j < n + 1; j += p)
         	a[j] = 0;
    		}
   	 }
    }


Упражнение 9.
=============

Напишите функцию, которая вычисляет простые числа от 2 до N, и возвращает их в виде  массива чисел,
используя решето Эратосфена. Для написания программы можно использовать код, который был приведён выше.

Упражнение 10.
==============

Дан массив, содержащий 2017 положительных целых чисел, не превышающих 10000. Необходимо найти
и вывести сумму таких элементов этого массива, шестнадцатеричная запись которых содержит 
ровно три знака, причём последний из них – буква от A до F. Например, для массива из 4 
элементов, содержащего числа 522, 4095, 296, 205, ответ будет равен 4617: в шестнадцатеричной
системе эти числа записываются как 20A, FFF, 128, CD; первые два подходят, в третьем – 
последняя цифра не записывается буквой, в четвёртом – меньше трёх знаков. Если таких чисел в массиве нет, сумма равна 0.

Упражнение 11. 
==============

Дан массив, содержащий неотрицательные целые числа, не превышающие 10 000. 
В массиве присутствуют чётные и нечётные числа. Необходимо вывести:

- минимальный чётный элемент, если количество чётных не больше, чем нечётных;

- минимальный нечётный элемент, если количество нечётных меньше, чем чётных.

Например, для массива из шести элементов, равных соответственно 4, 6, 12, 17, 9, 8, ответом будет 9

— наименьшее нечётное число, поскольку нечётных чисел в этом массиве меньше. 

В следующих задачах требуется придумать решение, не использующее массивы для запоминания всей 
входной последовательности. Программа должна генерировать входную последовательность с помощью 
псевдослучайных чисел, и они должны сразу обрабатываться. Количество этих чисел равно N = 1000 + x,
где х – случайное число от 0 до 1000. Ответ нужно записывать в файл “out.txt”. 

Упражнение 12. 
==============

Дается последовательность чисел. нужно определить, сколько есть пар чисел, в которых есть хотя бы одно число, оканчивающееся на "3". 


Упражнение 13. 
==============

На вход программы поступает последовательность из N целых положительных чисел, все числа в последовательности различны.
Рассматриваются все пары различных элементов последовательности (элементы пары не обязаны стоять в
последовательности рядом, порядок элементов в паре не важен). Необходимо определить количество пар,
для которых произведение элементов делится на 26. 

Упражнение 14.
==============

По каналу связи передаётся последовательность положительных целых чисел Х(1), Х(2), ... все числа 
не превышают 1000, их количество заранее неизвестно. Каждое число передаётся в виде отдельной 
текстовой строки, содержащей десятичную запись числа. Признаком конца передаваемой последовательности является число 0.

Участок последовательности от элемента Х(T) до элемента X(T+N) называется подъёмом, если на этом участке
каждое следующее число больше или равно предыдущему, причем участок нельзя расширить, то есть:
 
1) Т = 1 или Х(T-1) > Х(T);


2) X(T+N) — последний элемент последовательности или X(T+N) > X(T+N+1). Высотой подъёма называется 
разность X(T+N) − Х(T). Подъём считается значительным, если высота подъёма больше величины минимального элемента этого подъема.

Напишите программу, которая вычисляет количество значительных подъемов в заданной последовательности.
Программа должна вывести результаты в форме:

Получено чисел: ...           

Найдено значительных подъемов: ...

Упражнение 15. 
==============

Радиотелескоп пытается получать и анализировать сигналы, поступающие из различных участков космоса, 
при этом различные шумы переводятся в последовательность целых неотрицательных чисел. Чисел может 
быть очень  много, но не может быть меньше трёх. Все числа различны. Хотя бы одно из чисел нечётно. 

В данных, полученных из одного участка, выделяется основное подмножество чисел. 
Это непустое подмножество чисел (в него могут войти как одно число, так и все поступившие числа), 
такое, что их сумма нечётна и максимальна среди всех возможных непустых подмножеств с нечётной суммой. 
Если таких подмножеств несколько, то из них выбирается то подмножество, которое содержит наименьшее количество элементов. 

Упражнение 16. 
==============

На вход программе подается последовательность целых чисел. В первой строке сообщается количество чисел N, 
во второй строке идут сами числа.  Требуется написать программу, которая будет выводить на экран числа в 
следующем порядке: сначала отрицательные числа, потом положительные. При этом должно сохраняться исходное 
взаимное положение чисел, как положительных, так и отрицательных.


Упражнение 17. 
==============

На плоскости дан набор точек с целочисленными координатами. Необходимо найти такой треугольник 
наибольшей площади с вершинами в этих точках, у которого нет общих точек с осью Ох, а одна из сторон лежит на оси Оу.

Напишите эффективную, в том числе по памяти, программу, которая будет решать эту задачу. 
Размер памяти, которую использует Ваша программа, не должен зависеть от количества точек. 

Описание входных данных

В первой строке вводится одно целое положительное число - количество точек N.
Каждая из следующих N строк содержит два целых числа - сначала координата х, затем координата у очередной точки.
Числа разделены пробелом.

Описание выходных данных

Программа должна вывести одно число - максимальную площадь треугольника, удовлетворяющего условиям задачи. 
Если такого треугольника не существует, программа должна вывести ноль.

 Пример входных данных

8

0 -10

0 2

4 0

3 3

0 7

0 4

5 5

-9 9

Пример выходных данных для приведённого выше примера входных данных: 22.5


Дополнительные задачи повышенной сложности. 
===========================================

Бинарное возведение в степень — это приём, позволяющий возводить в степень.

Более того, описываемый приём применим к любой ассоциативной операции, а не только к умножению чисел. 
Наиболее очевидное обобщение — на остатки по некоторому модулю (очевидно, ассоциативность сохраняется). 
Следующим по "популярности" является обобщение на произведение матриц (его ассоциативность общеизвестна).


.. code-block:: c

  int binpow (int a, int n) {
	int res = 1;
	while (n)
		if (n & 1) {
			res *= a;
			--n;
		}
		else {
			a *= a;
			n >>= 1; // вместо деления на 2 можно делать битовый сдвиг
		}
	return res;
   }



Задача 1. 
=========

Матричная формула для чисел Фибоначчи: [ F(n-2) , F(n-1) ] × [ 0 , 1 ; 1 , 1 ]   = [ F(n-1) , F(n) ].

Значит, для нахождения n-го числа надо возвести матрицу [0 , 1 ; 1 , 1] в степень n.

Используя бинарное возведение в степень, написать функцию, вычисляющую  эти числа.


Задача 2. 
=========

Даны n точек Pi, и даны m преобразований, которые надо применить к каждой из этих точек.
Каждое преобразование — это либо сдвиг на заданный вектор, либо масштабирование 
(умножение координат на заданные коэффициенты), либо вращение вокруг заданной оси 
на заданный угол. Кроме того, имеется составная операция циклического повторения: 
она имеет вид "повторить заданное число раз заданный список преобразований" (операции 
циклического повторения могут вкладываться друг в друга).

Напишите функции, реализующие всё это.

Требуется вычислить результат применения указанных операций ко всем точкам эффективно, т.е.
с помощью алгоритма бинарного возведения в степень.

Задача 3. 
=========

Дан неориентированный граф G с n вершинами, и дано число k. Требуется для каждой пары вершин  i и j найти 
количество путей между ними, содержащих ровно k рёбер.

Указание:  задача решается с помощью бинарного возведения в степень матрицы смежности графа,
однако вместо обычной операции перемножения двух матриц следует использовать модифицированную: 
вместо умножений берётся сумма, а вместо суммирования — взятие минимума. Матрица смежности графа G с
конечным числом вершин n (пронумерованных числами от 1 до n) — это квадратная матрица A размера n, 
в которой значение элемента a(i, j) равно числу рёбер из i-й вершины графа в j-ю вершину.

Задача 4. 
=========

Троичная сбалансированная система счисления — это нестандартная позиционная система счисления. Основание
системы равно 3, однако она отличается от обычной троичной системы тем, что цифрами являются -1, 0, 1. 
Поскольку использовать -1 для одной цифры очень неудобно, то обычно принимают какое-то специальное обозначение.
Условимся здесь обозначать её буквой x. Троичная сбалансированная система счисления позволяет 
записывать отрицательные числа без записи отдельного знака "минус".
Написать функцию, которая переводит число в эту систему счисления, и возвращает её в виде массива символов char. 

Задача 5. 
=========

Диофантово уравнение с двумя неизвестными имеет вид: a×X + b×Y = c.

Общий вид решения этого уравнения: X = X0 + p×t ; Y = Y0 + q×t .

Напишите функцию, которая возвращает решение в общем виде, учесть все случаи.
