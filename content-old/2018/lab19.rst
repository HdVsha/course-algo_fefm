Работа с файлами, случайными числами, многомерными списками.
############################################################

:date: 2019-02-18 09:00
:summary: Работа с файлами, случайными числами, многомерными списками.
:status: published 

.. default-role:: code




Генерация случайных чисел в Python
===================================

Генерация случайных чисел - очень важный, с прикладной точки зрения, инструмент.
Она используется в криптографии, при численном интегрировании - Метод Монте-Карло,
для семплирования выборок в машинном обучении, вероятностных алгоритмах,
имитационном моделировании (одно из самых известных тут распределение Пуассона) и многом-многом другом.

Python порождает случайные числа на основе формулы, так что они не на самом деле случайные, а, как говорят, псевдослучайные.

В набор стандартных библиотек Python включен модуль random,
который предназначен для генерации случайных чисел из различных распределений, примитивного семплирования,
перемешки данных и т.д. Библиотека matplotlib используется для рисования графиков и визуализации данных.


Модуль **random** позволяет генерировать случайные числа. Прежде чем использовать модуль, необходимо подключить его с помощью инструкции:

.. code-block:: python

    from random import *


Этот формат инструкции from позволяет подключить  почти все переменные из модуля.
Более подробно форматы подключения модулей будем изучать позже. В примерах ниже используются ещё два - подключением модуля напрямую, 
тогда элементы модуля придётся использовать, каждый раз выписывая его название, или по псевдониму. Например 


.. code-block:: python

    import random
    import matplotlib.pyplot as plt


 

Давайте рассмотрим основные функции модуля random:


+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Функция библиотеки math              | Математическая функция                                                                                                                                                                                                                         |
+======================================+================================================================================================================================================================================================================================================+
| `random.seed([X], version=2)`        |  Инициализация генератора случайных чисел. Если X не указан, используется системное время.                                                                                                                                                     |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.getstate()`                  |  Возвращает внутреннее состояние генератора.                                                                                                                                                                                                   |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.setstate(state)`             |  Устанавливает внутреннее состояние генератора. Параметр state должен быть получен функцией getstate().                                                                                                                                        |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.randrange(start, stop, step)`|  Возвращает случайно выбранное число из последовательности.                                                                                                                                                                                    |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.randint(A, B)`               |  Случайное целое число N, A ≤ N ≤ B.                                                                                                                                                                                                           |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.choice(sequence)`            |  Случайный элемент непустой последовательности.                                                                                                                                                                                                |
+------------------------------+-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.shuffle(sequence, [rand])`   |  Перемешивает последовательность (изменяется сама последовательность). Поэтому функция не работает для неизменяемых объектов.                                                                                                                  |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.sample(population, k)`       |  Список длиной k из последовательности population.                                                                                                                                                                                             |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.random()`                    | Случайное число от 0 до 1.                                                                                                                                                                                                                     |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.uniform(A, B)`               | Случайное число с плавающей точкой, A ≤ N ≤ B (или B ≤ N ≤ A).                                                                                                                                                                                 |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.triangular(low, high, mode)` | Случайное число с плавающей точкой, low ≤ N ≤ high. Mode - распределение. Пример: random.triangular(0, 10, mode=random.uniform(6, 0))                                                                                                          |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.betavariate(alpha, beta)`    | Бета-распределение. alpha>0, beta>0. Возвращает от 0 до 1. Часто используется в инормационном поиске.                                                                                                                                          |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.expovariate(lambd)`          | Экспоненциальное распределение. lambd равен 1/среднее желаемое.                                                                                                                                                                                |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.gammavariate(alpha, beta)`   | Гамма-распределение. Условия на параметры alpha>0 и beta>0.                                                                                                                                                                                    |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.gauss(mu, sigma)`            | Распределение Гаусса.                                                                                                                                                                                                                          |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.lognormvariate(mu, sigma)`   | Логарифм нормального распределения. Если взять натуральный логарифм этого распределения, то вы получите нормальное распределение со средним mu и стандартным отклонением sigma. mu может иметь любое значение, и sigma должна быть больше нуля.|
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.normalvariate(mu, sigma)`    | Нормальное распределение. mu - среднее значение, sigma - стандартное отклонение.                                                                                                                                                               |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.vonmisesvariate(mu, kappa)`  | mu - средний угол, выраженный в радианах от 0 до 2π, и kappa - параметр концентрации, который должен быть больше или равен нулю. Если каппа равна нулю, это распределение сводится к случайному углу в диапазоне от 0 до 2π.                   |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.paretovariate(alpha)`        | Распределение Парето.                                                                                                                                                                                                                          |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `random.weibullvariate(alpha, beta)` | Распределение Вейбулла.                                                                                                                                                                                                                        |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


Давайте попробуем нарисовать что из себя представляет нормальное распределение:

.. code-block:: python

    import random
    import matplotlib.pyplot as plt

    random.seed(0)
    n = 1000
    values = [random.normalvariate(0, 1) for i in range(n)]
    plt.hist(values, bins=100)
    plt.show()

Давайте рассмотрим некоторые участки кода.

`random.seed(0)` - устанавливает состояние генератора случайных чисел в одинаковое состояние у всех.
Поэтому, у всех будут одинаковые результаты работы случайного генератора.
Если вы не выполните эту команду, то генератор инициализирует себя текущим временем, в таком случае,
у всех генерация случайных чисел будет работать по-разному.

`plt.hist(values, bins=100)` - рисует гистограмму, которая содержит 100 столбиков.

::

    В статистике гистограмма — геометрическое изображение эмпирической функции плотности
    вероятности некоторой случайной величины, построенное по выборке.

    Гистограмма строится следующим образом. Сначала множество значений, которое может принимать элемент выборки,
    разбивается на несколько интервалов (bins). Чаще всего эти интервалы берут одинаковыми,
    но это не является строгим требованием. Эти интервалы откладываются на горизонтальной оси,
    затем над каждым рисуется прямоугольник. Если все интервалы были одинаковыми, то высота каждого прямоугольника
    пропорциональна числу элементов выборки, попадающих в соответствующий интервал. Если интервалы разные,
    то высота прямоугольника выбирается таким образом, чтобы его площадь была пропорциональна числу элементов выборки,
    которые попали в этот интервал.
    
    
    
Упражнение 1. Гистограммы
=========================

Нарисовать при помощи 'matplotlib' 4 гистограммы стандартного нормального распределения (mu=0, sigma=1)
с N=[100, 1000, 10000, 100000] и убедиться, что чем больше данных,
тем больше распределение похоже на "Мексиканскую шляпу".
Картинки доджны быть нарисованны вместе. Используйте subplot для этого.

Упражнение 2. Метод Монте-Карло.
================================
В данном задании вам предлагается посчитать интеграл методом Монте-Карло на заданном отрезке.

Функция:

f(x) = -x**2 + 4, при -2<=x<=2, 0 во всех остальных случаях


Интервал: [-3, 3]


Метод Монте-Карло заключается в следующем:


1. Мы берем N случайных точек из области интегрирования, распределенных по равномерному закону и вычисляем значение интегрируемой функции в этих точках.

2. Утверждается, что интеграл равен произведению среднего арифметического этих значений на длину интервала интегрирования.




Работа с текстовыми файлами в Python
====================================

До этого для ввода информации мы использовали исключительно клавиатуру. При этом в большинстве случаев данные,
считываемые программой, **уже** хранятся на носителе информации в виде **файлов**.

Для каждого файла, с которым необходимо производить операции ввода-вывода, нужно создать специальный объект – поток.
Именно с потоками работают программы — использование такого дополнительного слоя **абстракции** позволяет прозрачно
работать не только с текстовыми файлами, но и, например, с архивами.


Открытие файла
--------------

Открытие файла осуществляется функцией `open`, которой нужно передать два параметра. Первый параметр — строка, задающая
имя открываемого файла. Второй параметр — строка, указывающая режим октрытия файла.

Существует три режима открытия файлов:

+--------------+-----------------------------------------------------------------+
| Режим        | Описание                                                        |
+==============+=================================================================+
| "r" (read)   | Файл открывается для чтения данных.                             |
+--------------+-----------------------------------------------------------------+
| "w" (write)  | Файл открывается на запись, при этом его содержимое очищается.  |
+--------------+-----------------------------------------------------------------+
| "a" (append) | Файл открывается для добавления данных в конец файла.           |
+--------------+-----------------------------------------------------------------+

Если второй параметр не задан, то считается, что файл открывается в режиме чтения.

Функция open возвращает ссылку на **файловый объект**, которую нужно записать в переменную,
чтобы потом через данный объект работать с этим файлом. Например:

.. code-block:: python

	file_input = open('input.txt', 'r')
	file_output = open('output.txt', 'w')

Здесь открыто два файла (один на чтение, другой на запись) и создано два связанных с ними объекта.

Чтение данных из файла
----------------------

Для файла, открытого на чтение данных, можно использовать несколько методов, позвозволяющих считывать данные. Мы рассмотрим
три из них: `readline`, `readlines`, `read`.

Метод `readline()` считывает одну строку из файла (до символа конца строки `\n`, возвращается считанная строка вместе с
символом `\n`). Если считывание не было успешно (достигнут конец файла), то возвращается пустая строка. Для удаления
символа `\n` из конца файла удобно использовать метод строки `rstrip()`. Например:

.. code-block:: python

	s = s.rstrip().

Метод `readlines()` считывает все строки из файла и возвращает список из всех считанных строк (одна строка — один
элемент списка). При этом символы `\n` остаются в концах строк.

Метод `read()` считывает все содержимое из файла и возвращает строку, которая может содержать символы `\n`. Если методу
read передать целочисленный параметр, то будет считано не более заданного количества символов. Например, считывать файл
побайтово можно при помощи метода `read(1)`.

Вывод данных в файл
-------------------

Данные выводятся в файл при помощи метода `write`, которому в качестве параметра передается одна строка. Этот метод не
выводит символ конца строки `\n` (как это делает функция `print` при стандартном выводе), поэтому для перехода на новую
строку в файле необходимо явно вывести символ `\n`.

Выводить данные в файл можно и при помощи `print`, если передать функции еще один именованный параметр `file`. Например:

.. code-block:: python

	output = open('output.txt', 'w')
	print(a, b, c, file=output) # через print

	output.write("Some string") # через write

Закрытие файла
--------------

После окончания работы с файлом необходимо закрыть его при помощи метода `close()`.

Следующая программа считывает все содержимое файла `input.txt`, записывает его в переменную `s`, а затем выводит ее в
файл `output.txt`.

.. code-block:: python

	input = open('input.txt', 'r')
	output = open('output.txt', 'w')
	s = input.read()
	output.write(s)
	input.close()
	output.close()

А вот аналогичная программа, но читающая данные посимвольно:

.. code-block:: python

	input = open('input.txt', 'r')
	output = open('output.txt', 'w')
	c = input.read(1)
	while len(c) > 0:
	    output.write(c)
	    c = input.read(1)
	input.close()
	output.close()


Так же работать с файлами можно при помощи конструкции `with ... as` :

.. code-block:: python

    with open('file_name.txt', 'r') as f:
        for line in f:
            print(line)


В этом случае гарантированно выполняется закрытие файла. 




Модель данных в Python
======================


Python - язык с неявной сильной динамической типизацией. Неявная типизация означает, что при объявлении переменной вам не нужно указывать её тип, при явной – это делать необходимо. Сильная типизация не позволяет производить операции в выражениях с данными различных типов, слабая – позволяет. В языках с сильной типизацией вы не можете складывать например строки и числа, нужно все приводить к одному типу. К первой группе можно отнести Python, Java, ко второй – С и С++. Динамическая типизация означает, что все типы данных выясняются непосредственно во время выполнения программы - зачастую это удобно, но менее надёжно. 

Язык C имеет статическую слабую явную типизацию, являясь, тем самым, по этим параметрам полной противоположностью языка Python.

Очень важным отличием Python от многих других языков программирования является ссылочная модель данных. В отличие, например, от компиллятора С++, интерпретатор Python не использует переменные. В Python всё является объектами. Объект, в данном случае – это абстракция для представления данных, данные – это числа, списки, строки и т.п. При этом, под данными следует понимать как непосредственно сами объекты, так и отношения между ними (об этом чуть позже). Каждый объект имеет три атрибута – это идентификатор, значение и тип. Идентификатор – это уникальный признак объекта, позволяющий отличать объекты друг от друга, а значение – непосредственно информация, хранящаяся в памяти, которой управляет интерпретатор.

Например, запишем строчку кода 

n = 0

При инициализации и создании переменной, на уровне интерпретатора, происходит следующее:

1) создается целочисленный объект, имеющий значение 0 (можно представить, что в этот момент создается ячейка и 0 кладется в эту ячейку);

2) данный объект имеет некоторый идентификатор, значение: 0, и тип: целое число;

3) посредством оператора “=” создается ссылка между переменной b и целочисленным объектом 0 (переменная b ссылается на объект 0).


Для того, чтобы посмотреть на объект с каким идентификатором ссылается данная переменная, можно использовать функцию id().
Для того, чтобы посмотреть на объект какого типа ссылается данная переменная, можно использовать функцию type(). 

При приведении типов, например, как здесь ниже


.. code-block:: python

    n = 0
    n = float(n)


объект 0 не меняет свой тип. Вместо этого просто переменная n начинает ссылаться на другой объект другого типа. 

Если мы пишем, например, А = В, то переменные А и В будут ссылаться на один и тот же объект (являться разными именами одного объекта). 
Далее возникает вопрос, а что будет, если мы изменим В?  Проверив это с числами, мы можем видеть, что В изменится, а А нет. Проверив же идентификаторы, увидим, что идентификатор В изменился, то есть создан другой объект, а В стал ссылаться на него. Исходный же объект изменить нельзя - такие типы данных являются неизменяемыми. В случае же изменяемых типов данных при изменении переменной В автоматически бы изменилась переменная А, так как изменился бы объект, на который обе переменные ссылаются.


К неизменяемым (immutable) типам относятся: целые числа (int),  числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set).



К изменяемым (mutable) типам относятся: списки (list), множества (set), словари (dict).


Идентификатор является целым числом, гарантированно являющееся уникальным и постоянным для объекта на время его существования.

Таким образом, объекты, периоды существования которых не пересекаются, могут иметь одинаковый идентификатор.

Помимо этого, следует иметь в виду, что некоторые объекты могут иметь один и тот же идентификатор, например: 
мелкие целые (с -5 по 256), True и False.

Строки в Python относятся к категории неизменяемых последовательностей, то есть все функции и методы могут лишь создавать новую строку.

Аналогичное верно для кортежей. Так же как и список, кортеж (tuple) является упорядоченной последовательностью элементов. Вся разница заключается в том, что кортежи неизменяемы.

Кортежи используются для защиты данных от перезаписи и обычно работают быстрее, чем списки, т.к. их нельзя изменять.

Для создания кортежа нужно поместить внутрь круглых скобок элементы, разделённые запятой. Также, как и со строками, для кортежей мы можем использовать оператор извлечения среза [] для извлечения элементов, но мы не можем менять их значения.


Подробнее про особенности разных типов данных мы поговорим ещё на следующих семинарах.


Упражнение №3
=============


Создайте кортеж из 5 элементов, в котором первые два равны по значению, но имеют разные идентификаторы, вторые два равны по значению и
имеют одинаковые идентификаторы, а пятый элемент равен по значению первому и имеет одинаковый с ним идентификатор. 

Продемонстрируйте верность выполнения упражнения, создав и сразу распечатав список из идентификаторов с помощью генератора списков (однострочником).



Список (list)
=============
Для начала вспомним операции работы со списками.

+--------------------+-------------+----------------------+---------------------------------------------------+
| Операция           | Пример      | Трудоемкость         | Замечания                                         |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Взятие индекса     | l[i]        | O(1)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Сохранение элемента| l[i] = 0    | O(1)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Длина              | len(l)      | O(1)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Добавление в конец | l.append(5) | O(1)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Извлечение с конца | l.pop()     | O(1)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Очистка списка     | l.clear()   | O(1)                 | Аналогично l = []                                 |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Срез(Slice)        | l[a:b]      | O(b-a)               |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Расширение         | l.extend(A) | O(len(A))            | Зависит только от длины A                         |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Создание           | list(A)     | O(len(A))            | Зависит от длины A (итерируемый объект)           |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Проверка ==, !=    | l1 == l2    | O(N)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Присваивание в срез| [a:b] = ... | O(N)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Удаление элемента  | del l[i]    | O(N)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Поиск элемента     | x (not) in l| O(N)                 | Поиск работает за O(N)                            |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Копирование списка | l.copy()    | O(N)                 | То же самое что l[:], который O(N)                |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Удаление из списка | l.remove(..)| O(N)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Извлечение элемента| l.pop(i)    | O(N)                 | O(N-i): l.pop(0):O(N) (см. выше)                  |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Экстремумы         |min(l)/max(l)| O(N)                 | Поиск работает за O(N)                            |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Обращение          | l.reverse() | O(N)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Итерирование       | for v in l: | O(N)                 |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Сортировка         | l.sort()    | O(N Log N)           |                                                   |
+--------------------+-------------+----------------------+---------------------------------------------------+
| Перемножение       | k*l         | O(k N)               | 5*l будет за O(N), len(l)*l будет O(N**2)         |
+--------------------+-------------+----------------------+---------------------------------------------------+

У разработчиков типа данных list Python было много вариантов каким сделать его во время реализации. Каждый выбор повлиял на то, как быстро список мог выполнять операции. Одно из решений было сделать список оптимальным для частых операций.

Индексирование и присваивание
-----------------------------

Две частые операции - индексирование и присваивание на позицию индекса. В списках Python значения присваиваются и извлекаются из определенных известных мест памяти. Независимо от того, насколько велик список, индексный поиск и присвоение занимают постоянное количество времени и, таким образом их трудоемкость **O(1)**.

Pop, Shift, Delete
------------------
Извлечение элемента(pop) из списка Python по умолчанию выполняется с конца, но, передавая индекс, вы можете получить элемент из определенной позиции. Когда pop вызывается с конца, операция имеет сложность **O(1)** , а вызов pop из любого места - **O(n)**. Откуда такая разница?

Когда элемент берется из середины списка Python, все остальные элементы в списке сдвигаются на одну позицию ближе к началу. Это суровая плата за возможность брать индекс за **O(1)**, что является более частой операцией.

По тем же причинам вставка в индекс - **O(N)**; каждый последующий элемент должен быть сдвинут на одну позицию ближе к концу, чтобы разместить новый элемент. Неудивительно, что удаление ведет себя таким же образом.

Итерирование
------------
Итерирование выполняется за **O(N)**, потому что для итерации по N элементам требуется N шагов. Это также объясняет, почему оператор in, max, min в Python является **O(N)**: чтобы определить, находится ли элемент в списке, мы должны перебирать каждый элемент.


Срезы
-----
Чтобы получить доступ к фрагменту [a: b] списка, мы должны перебрать каждый элемент между индексами a и b. Таким образом, доступ к срезу - **O(k)**, где k - размер среза. Удаление среза **O(N)** по той же причине, что удаление одного элемента - **O(N)**: N последующих элементов должны быть смещены в сторону начала списка.

Умножение на int
----------------
Чтобы понять умножение списка на целое k, вспомним, что конкатенация выполняется за **O(M)**, где M - длина добавленного списка. Из этого следует, что умножение списка равно **O(N k)**, так как умножение k-размера списка N раз потребует времени **k (N-1)**.

Разворот списка
---------------
Разворот списка - это **O(N)**, так как мы должны переместить каждый элемент.

Упражнение №4
+++++++++++++

Допишите в следующем коде участок функции, где repeat_count раз повторяется взятие операции pop по индексу pop_position.
Сделайте, чтобы если pop_position == None, то брался pop() без указания индекса. Допишите код получения массивов values1, values2, values3. Покажите преподавателю получившиеся графики.

.. code-block:: python

    import matplotlib.pyplot as plt
    import time

    def get_pop_time(size, repeat_count, pop_position=None):
        '''
        size - размер списка из нулей на котором будем тестировать скорость операции pop
        repeat_count - количество повторений для усреднения
        pop_position - позиция с которой делаем pop
        '''
        l = [0] * size
        start_time = time.time()
        #
        # code here
        #
        end_time = time.time()
        return (end_time - start_time) / repeat_count

    repeat_count = 1000
    # code here
    values1 = [get_pop_time(...) for size in range(10, 1000)]
    values2 = [get_pop_time(...) for size in range(10, 1000)]
    values3 = [get_pop_time(...) for size in range(10, 1000)]

    plt.plot(values1, label='Pop no args')
    plt.plot(values2, label='Pop start list')
    plt.plot(values3, label='Pop end list')
    plt.ylabel('pop time')
    ax = plt.subplot(111)
    ax.legend()
    plt.show()


Упражнение №5
+++++++++++++

CONS -  Consensus and Profile.

Finding a Most Likely Common Ancestor

Матрица - это прямоугольная таблица значений, разделенная на строки и столбцы. Матрица m × n имеет m строк и n столбцов. Для матрицы A мы пишем Ai, j, чтобы указать значение, найденное на пересечении строки i и столбца j.

Скажем, у нас есть коллекция цепочек ДНК, имеющих одинаковую длину n. Их матрица профиля представляет собой матрицу P размером 4 × n, в которой P1, j представляет число раз, когда «A» встречается в j-й позиции одной из строк, P2, j представляет количество раз, когда C встречается в j-й позиции и так далее (см. ниже).

Консенсусная строка c - это строка длиной n, сформированная из нашей коллекции путем взятия наиболее распространенного символа в каждой позиции; следовательно, j-й символ c соответствует символу, имеющему максимальное значение в j-м столбце матрицы профиля. Конечно, может быть более одного наиболее распространенного символа, что приводит к множеству возможных согласованных строк.
Строки ДНК

           A T C C A G C T
	   
           G G G C A A C T
	   
           A T G G A T C T
	   
           A A G C A A C C
	   
           T T G G A A C T
	   
           A T G C C A T T
	   
           A T G G C A C T

Профиль 

           A 5 1 0 0 5 5 0 0
	   
           C 0 0 1 4 2 0 6 1
	   
           G 1 1 6 3 0 1 0 0
	   
           T 1 5 0 0 0 1 1 6
	   

Консенсус 

A T G C A A C T

Входные данные: Коллекция не более 10 строк ДНК одинаковой длины (не более 1 кбит / с) в формате FASTA.


Выходные данные: согласованная строка и матрица профиля для коллекции. (Если существует несколько возможных согласованных строк, вы можете вернуть любую из них.)


Пример входных данных

ATCCAGCT

GGGCAACT

ATGGATCT

AAGCAACC

TTGGAACT

ATGCCATT

ATGGCACT


Пример выходных данных к этим входным



ATGCAACT

A: 5 1 0 0 5 5 0 0

C: 0 0 1 4 2 0 6 1

G: 1 1 6 3 0 1 0 0

T: 1 5 0 0 0 1 1 6



Упражнение №6
+++++++++++++

PROT Translating RNA into Protein


20 часто встречающихся аминокислот сокращены с использованием 20 букв английского алфавита (все буквы, кроме B, J, O, U, X и Z). Белковые струны построены из этих 20 символов. Отныне термин «генетическая нить» будет включать белковые нити, а также нити ДНК и РНК.

Таблица кодонов РНК определяет подробности, касающиеся кодирования конкретных кодонов в алфавит аминокислот.

Дано: строка РНК s, соответствующая цепи мРНК (длиной не более 10 т.п.н.).

Возврат: белковая строка, закодированная s.

Образец набора данных

AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA

Пример вывода

MAMAPRTEINSTRING

Указание: это задание лучше всего делать с помощью словарей. Так как словари мы ещё не изучали, используйте двумерный список.

Таблица с указанием трансляции отдельных кодонов РНК в аминокислоты с целью создания белка.


+--------------+-------------------------+--------------+------------------------+
| Кодон        | Аминокислота            | Кодон        | Аминокислота           |
+==============+=========================+==============+========================+
|        UUU   |          F              |       UCA    |          S             |
+--------------+-------------------------+--------------+------------------------+
|        CUU   |          L              |       CCA    |          P             |
+--------------+-------------------------+--------------+------------------------+
|        AUU   |          I              |       ACA    |          T             | 
+--------------+-------------------------+--------------+------------------------+
|        GUU   |          V              |       GCA    |          A             |
+--------------+-------------------------+--------------+------------------------+
|        UUC   |          F              |       UCG    |          S             |
+--------------+-------------------------+--------------+------------------------+
|        CUC   |          L              |       CCG    |          P             | 
+--------------+-------------------------+--------------+------------------------+
|        AUC   |          I              |       ACG    |          T             |
+--------------+-------------------------+--------------+------------------------+
|        GUC   |          V              |       GCG    |          A             |
+--------------+-------------------------+--------------+------------------------+
|        UUA   |          L              |       UAU    |          Y             | 
+--------------+-------------------------+--------------+------------------------+
|        CUA   |          L              |       CAU    |          H             |
+--------------+-------------------------+--------------+------------------------+
|        AUA   |          I              |       AAU    |          N             |
+--------------+-------------------------+--------------+------------------------+
|        GUA   |          V              |       GAU    |          D             | 
+--------------+-------------------------+--------------+------------------------+
|        UUG   |          L              |       UAC    |          Y             |
+--------------+-------------------------+--------------+------------------------+
|        CUG   |          L              |       CAC    |          H             |
+--------------+-------------------------+--------------+------------------------+
|        AUG   |          M              |       AAC    |          N             | 
+--------------+-------------------------+--------------+------------------------+
|        GUG   |          V              |       GAC    |          D             |
+--------------+-------------------------+--------------+------------------------+
|        UCU   |          S              |       UAA    |          Stop          |
+--------------+-------------------------+--------------+------------------------+
|        CCU   |          P              |       CAA    |          Q             | 
+--------------+-------------------------+--------------+------------------------+
|        ACU   |          T              |       AAA    |          K             |
+--------------+-------------------------+--------------+------------------------+
|        GCU   |          A              |       GAA    |          E             |
+--------------+-------------------------+--------------+------------------------+
|        UCC   |          S              |       UAG    |          Stop          | 
+--------------+-------------------------+--------------+------------------------+
|        CCC   |          P              |       CAG    |          Q             |
+--------------+-------------------------+--------------+------------------------+
|        ACC   |          T              |       AAG    |          K             |
+--------------+-------------------------+--------------+------------------------+
|        GCC   |          A              |       GAG    |          E             | 
+--------------+-------------------------+--------------+------------------------+
|        UGU   |          C              |       UGA    |          Stop          |
+--------------+-------------------------+--------------+------------------------+
|        CGU   |          R              |       CGA    |          R             |
+--------------+-------------------------+--------------+------------------------+
|        AGU   |          S              |       AGA    |          R             | 
+--------------+-------------------------+--------------+------------------------+
|        GGU   |          G              |       GGA    |          G             |
+--------------+-------------------------+--------------+------------------------+
|        UGC   |          C              |       UGG    |          W             |
+--------------+-------------------------+--------------+------------------------+
|        CGC   |          R              |       CGG    |          R             | 
+--------------+-------------------------+--------------+------------------------+
|        AGC   |          S              |       AGG    |          R             |
+--------------+-------------------------+--------------+------------------------+
|        GGC   |          G              |       GGG    |          G             |
+--------------+-------------------------+--------------+------------------------+



В википедии есть https://en.wikipedia.org/wiki/Genetic_code#RNA_codon_table . 


Упражнение №7
+++++++++++++

Напишите к данной программе, играющей в крестики-нолики, набор функций, которые сделают игру искусственного интеллекта безупречной.

Функция проверки, нельзя ли завершить игру победой.

Функции проверки для первого хода - если центральная не занята, то занять её, если занята, то занять случайную угловую.

Функция проверки, не может ли враг на следующем ходе завершить игру победой.

Функция проверки, можно ли создать противнику безвыходную ситуацию

1) если нельзя, то походить просто на одну из выгодных позиций.

2) если и это невозможно, походить на первую попавшуюся клетку.


Создание противнику безвыходной ситуации достигается созданием определенной комбинации ваших меток, при которой, как бы враг ни походил, вы всегда можете выиграть партию. Эти комбинации - заполнены 3 угловые точки, причем между 2-мя парами из них должны быть пустые клетки; заполнены 2 угловые и центральная, и соблюдается то же правило.


Вот код программы, которую нужно дописать. 




.. code-block:: python
    
    # -*- coding: utf-8 -*-

    X = "X"
    O = "O"

    board = list(range(0,9))

    def draw_board(board):
        print ("-" * 13)
        for i in range(3):
            print ("|", board[0+i*3], "|", board[1+i*3], "|", board[2+i*3], "|")
            print ("-" * 13)

    def take_input(player_token):
        valid = False
        while not valid:
            player_answer = input("Куда поставим " + player_token+"? ")
            try:
                player_answer = int(player_answer)
            except:
                print ("Некорректный ввод. Вы уверены, что ввели число?")
                continue
            if player_answer >= 0 and player_answer <= 8:
                if (str(board[player_answer]) not in "XO"):
                    board[player_answer] = player_token
                    valid = True
                else:
                    print ("Эта клеточка уже занята")
            else:
                print ("Некорректный ввод. Введите число от 0 до 8 чтобы походить.")


    # Процедура проверки победы какого-либо игрока

    def check_win(board):
        win_coord = ((0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6))
        for each in win_coord:
            if board[each[0]] == board[each[1]] == board[each[2]]:
                return board[each[0]]
        return False

    def ask_yes_no(question):
        respone = None
        while respone not in ("y","n"):
            respone = input(question).lower()
        return respone

    def pieces():
        go_first = ask_yes_no("Хочешь оставить за собой первый ход? (y/n): ")
        if go_first == "y":
            print("Ну что ж, даю тебе фору, играй крестикаи")
            human = X
            computer = O
        else:
            print("Твоя удаль тебя погубит... Буду начинать я.")
            human = O
            computer = X
        return computer,human

    def computer_move(player_token):
        valid = False
        BEST_MOVES=(4,0,2,6,8,1,3,5,7)
        print("Я выберу поле номер", end = " ")
        for player_answer in BEST_MOVES:
            if player_answer >= 0 and player_answer <= 8:
                if (str(board[player_answer]) not in "XO"):
                    board[player_answer] = player_token
                    print(player_answer)
                    break
    

    def next_turn(turn):
        if turn==X:
            return O
        else:
            return X

    # Главная функция программы, вызывающая все остальные

    def main(board):
        counter = 0
        win = False
        go_begin = ask_yes_no("Хочешь сыграть с компьютером или человеком (y/n): ")
        if go_begin == "y":
            print("Ну что ж, попробуй с компьютером")
            human = X
            computer = O
            computer, human = pieces()
            draw_board(board)
            turn = X
            while not check_win(board):
                if turn == human:
                    take_input(human)
                    counter += 1
                else:
                    computer_move(computer)
                    counter += 1
                draw_board(board)
                turn=next_turn(turn)
                tmp = check_win(board)
                if tmp:
                    print (tmp, "выиграл!")
                    win = True
                    break
                if counter == 9:
                    print ("Ничья!")
                    break
            return 1

        while not win:
            draw_board(board)
            if counter % 2 == 0:
                take_input("X")
            else:
                take_input("O")
            counter += 1
            if counter > 4:
                tmp = check_win(board)
                if tmp:
                    print (tmp, "выиграл!")
                    win = True
                    break
            if counter == 9:
                print ("Ничья!")
                break
        draw_board(board)
        return 2

    main(board)





 




