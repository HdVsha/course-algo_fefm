Матрицы.
########





:date: 2018-10-29 09:00
:summary: Матрицы, вывод данных, функции и параметры.
:status: published 

.. default-role:: code




Указатели, разыменование и взятие адреса.
=========================================


Начнем со следующей задачи. Предположим, в программе имеются 3 целые переменные x, y, z. Задача состоит в том, чтобы в одном месте программы выбрать одну из них, а в другом месте — присвоить выбранной переменной значение 1. Самое простое решение этой задачи таково. Мы заводим еще одну целую переменную, например t, и договариваемся о том, что она может иметь
значения от 1 до 3, причем ее значению 1 соответствует выбор x, значению 2 — y и 3 — z. В том месте программы, где нужно
выбирать одну из трех переменных, мы присваиваем t соответствующее значение; например, выбор переменной y будет выглядеть как «t=2;». Ну а в том месте, где выбранной переменной нужно присвоить 1, будет стоять следующий фрагмент:


.. code-block:: c

  switch(t) 
  { 
     case 1: x = 1; break;
     case 2: y = 1; break; 
     case 3: z = 1; 
  }


Конструкция switch-case — это удобная и простая замена длинной if-else конструкции, но это решение при всей своей простоте имеет ряд недостатков. Отметим два из них. Первый состоит в том, что указанная конструкция усложняется с ростом числа переменных, из которых мы хотим выбрать одну. Второй связан с тем, что нам нужно помнить, какое значение специальной переменной какую переменную означает. 

Для устранения этих недостатков и было изобретено понятие указателя. По-прежнему нужна дополнительная переменная, но теперь она имеет не целый тип, а некоторый специальный тип, который называется «тип указателя на целую переменную» (если мы хотим выбирать одну из целых переменных; если же нам нужно выбрать одну из вещественных переменных, нужен уже другой тип — тип указателя на вещественную переменную). Переменная-указатель объявляется почти так же, как и обычная переменная, но с добавлением символа «\*» перед именем переменной. Итак, специальная переменная (называемая указателем) заводится так:

.. code-block:: c

  int *t;


В этом определении \* относится к t, а не к int. Это означает, что если я хочу в одной декларации определить несколько указателей, \* должна ставиться перед каждым именем:

.. code-block:: c

  int *p, *q;


Как и любую переменную, указатель можно инициализировать при объявлении. Теперь, чтобы выбрать одну из целых переменных (а этот способ позволяет выбирать любую из целых переменных, определенных в программе), например x, нужно написать:

.. code-block:: c

  t = &x;


& - эта операция здесь называется взятие адреса. Переменная t, являющаяся указателем, приобретает значение, равное адресу х. 
В том же месте, где нужно присвоить выбранной переменной некоторое значение, например, 1, нужно написать:

.. code-block:: c

  *t = 1;


\* - эта операция здесь называется разыменование указателя. Если переменная-указатель выбирает некоторую другую переменную, будем говорить, что указатель указывает на выбираемую переменную. Переменная x, значение которой хранится по адресу, который равен значению указателя t, приобретает таким образом значение 1 с помощью разыменования указателя. 

В C++ также имеется некоторый специальный тип указателя «неизвестно на что». Такие указатели определяются с ключевым словом void:

.. code-block:: c

  void *p;


Такому указателю можно присвоить любой указатель (т. е. указатель на любой тип), но пользоваться им непосредственно нельзя — сначала нужно явно привести его к типу указателя на конкретный тип, написав перед ним (тип \*) 

Указатели, как и переменные других типов, можно присваивать друг другу, передавать в процедуры и функции в качестве параметров, возвращать в качестве результатов и сравнивать на равенство или отсутствие равенства. Равными считаются указатели, выбирающие одну и ту же переменную, т. е. такие, в которых хранится один и тот же адрес. Присваивание указателей и присваивание переменных, на которые они указывают — совсем не одно и то же. 


Пусть у нас есть 2 указателя p и q, каждый из которых указывает на свою переменную (предположим, что эти переменные, а следовательно, и указатели на них имеют одинаковый тип). После «p=q;» оба указателя начнут указывать на одну и ту же переменную (на которую раньше указывал только q); при этом значения обоих переменных не изменятся. Если же выполняется оператор «\*p=\*q;», то содержимое указателей не меняется, они по-прежнему указывают на те же переменные, что и раньше, но содержимое той переменной, на которую указывает q, записывается в ту переменную, на которую указывает p.

Уместно в связи с указателями сделать одно предупреждение. Если в программе имеется функция, возвращающая указатель, то нельзя из этой функции возвращать указатель на локальную переменную. Это связано с тем, что после выхода из функции все ее локальные переменные исчезают, и память, которую они занимали, освобождается. Таким образом, возвращенный из функции указатель будет указывать на освобожденную память; такие указатели называются висячими. Использование висячих указателей приводит к неверным результатам работы программы или к ее аварийной остановке.





Создание двумерного динамического массива в С++ и выделение памяти.
===================================================================

Обычные локальные переменные возникают в момент начала работы подпрограммы, живут пока она работает и исчезают по окончании ее работы. Однако иногда требуется в подпрограмме завести переменную, которая сохранилась бы и при выходе из подпрограммы. Если число таких переменных известно заранее (в момент компиляции программы), можно воспользоваться статическими переменными. Часто это не так, и в этом случае можно воспользоваться механизмом динамических переменных.


Для работы вычислительного процесса, начиная с самого первого отведенного ему такта процессорного времени, нужна оперативная память. 
Вычислительный процесс может явным образом попросить у операционной системы дополнительную память. При этом динимическая память
является ресурсом операционной системой и выделяется по явному запросу процесса. Выделенная память называется "куча" или HEAP.

Любая динамическая переменная хранится в этой особой области памяти, называемой кучей. Особенность этой области памяти в том, что, в отличие от стека, где хранятся обычные локальные переменные и где уничтожать их можно только в порядке, обратном порядку их создания, в куче можно уничтожать переменные ио свобождать занимаемую ими память в любом порядке. Платой за такое удобство является то, что выделение и освобождение памяти в куче происходит намного медленнее, чем в стеке. 

Для того, чтобы завести динамическую переменную, нужно написать  new  тип. Этот оператор заводит динамическую переменную указанного типа и возвращает указатель на нее. Если p — переменная типа int\*, то после выполнения оператора p = new int; указатель p будет указывать на вновь созданную динамическую переменную целого типа. Динамические переменные не имеют имен, и доступ к ним возможен только через указатели на них. Если в результате ошибок в программе возникают динамические переменные, на которые никакой указатель не указывает (т. е. до которых невозможно добраться), это явление называется утечкой памяти, а сами недоступные динамические переменные называются мусором.

Еще одно отличие динамических переменных от обычных локальных состоит в том, что если они перестали использоваться, их надо удалять вручную вызовом операции delete, параметром которой является указатель на удаляемую переменную. 


Контроль за выделением и освобождением динамической памяти — дело рук программиста. Компилятор снимает с себя ответственность за то,
что память выделена, но не освобождена, или же не выделена к необходимому моменту.

В связи с динамическими переменными, хотелось бы сказать пару слов и о динамических массивах. Если нужно завести динамический массив, это делается так:

указатель_на_элемент = new тип_элемента[число_элементов]; 

Такой фрагмент присвоит указателю адрес первого элемента массива. Удаляются динамические массивы так: 

delete [] указатель_на_первый_элемент_удаляемого_массива; 

Динамический массив хорош тем, что число его элементов может быть любым выражением, возвращающим целое число. Здесь нет того ограничения, как для обычных массивов, что размер массива должен быть известен на момент компиляции. Здесь надо еще заметить, что в C++ нельзя менять размер массива на ходу. Если нам нужно расширить наш динамический массив, нужно явно завести массив большего размера, переписать в него элементы старого массива и наконец так же явно уничтожить старый массив. 


Правда, в стандартной библиотеке C++ имеется шаблонный класс vector, который позволяет менять размер, но внутри него это реализовано так же, как обсуждалось выше. Это, в частности, означает, что если у Вас был указатель на какой-то элемент, после добавления в vector новых элементов этот указатель может перестать указывать на правильный элемент (т. е. он по-прежнему будет указывать на элемент старого массива, который будет уничтожен в связи с переездом массива на другое место в памяти).


Пример создания двумерного массива, и считывания его из файла.


.. code-block:: c

  #include <iostream>
  #include <algorithm>
  #include <ctime>
  #include <iomanip>
  using namespace std;

    int main()
   {   
        ifstream  fin("out.txt");
     int N, M;       fin >> N >> M;      // ввод размеров двумерного массива
    // динамическое создание двумерного массива вещественных чисел 
    float **ptrArray = new float* [N]; // N строк в массиве
    for (int count = 0; count < N; count++)
        ptrArray[count] = new float [M]; // и M столбцов
        // заполнение массива 
    for (int count_row = 0; count_row < N; count_row++) 
        for (int count_column = 0; count_column < M; count_column++) 
            fin >> ptrArray[count_row][count_column]; //заполнение массива числами из файла 
    // вывод массива 
    for (int count_row = 0; count_row < N; count_row++) 
    {
        for (int count_column = 0; count_column < M; count_column++) 
            cout << setw(4) << setprecision(2) << ptrArray[count_row][count_column] << "   ";
        cout << endl;
    }
    // удаление двумерного динамического массива
    for (int count = 0; count < N; count++) 
        delete []ptrArray[count];
     delete [] ptrArray;
     fin.close();   
     return 0;
    }


Для управления вводом-выводом в C++ используются:

•	флаги форматированного ввода-вывода;

•	манипуляторы форматирования.

Флаги позволяют установить параметры ввода-вывода, которые будут действовать во всех последующих операторах ввода-вывода до тех пор, 
пока не будут отменены. 
Манипуляторы вставляются в операторы cin(cout) и устанавливают параметры текущего оператора ввода-вывода.



Использование флагов.
=====================


Для установки флага вывода используется конструкция языка C++: cout.setf(ios::flag)
Для снятия флага конструкция:  cout.unsetf(ios::flag)
Здесь flag — имя конкретного флага.

Выравнивание по правой границе:

.. code-block:: c

  int r= — 25;
  cout.setf(ios::right);
  cout.width(15);
  cout << "r= " << r << endl;


Выравнивание по левой границе (по умолчанию):

.. code-block:: c

  double r=—25.45;
  cout.setf(ios::left);
  cout.width(50);
  cout << "r= " << r << endl;

  

Вывод логических величин в текстовом виде:

.. code-block:: c

  bool a=true;
  cout << a << endl;
  cout.setf(ios::boolalpha);
  cout << a << endl;


Вывод величин в десятичной системе счисления (по умолчанию):

.. code-block:: c

  int r=—25;
  cout << "r= " << r << endl;


  
В восьмеричной системе счисления (для этого нужно снять флаг вывод в десятичной):

.. code-block:: c

  int p=23;
  cout.unsetf(ios::dec);
  cout.setf(ios::oct);
  cout << "p= " << p << endl;


В шестнадцатеричной системе счисления (снять флаг вывод в десятичной):

.. code-block:: c

  int p=23;
  cout.unsetf(ios::dec);
  cout.setf(ios::hex);
  cout << "p= " << p << endl;

  

Выводить индикатор основания системы счисления:

.. code-block:: c

  int r=—25;
  cout.unsetf(ios::dec);
  cout.setf(ios::hex|ios::showbase);
  cout << "p= " << p << endl;

  

Использовать прописные буквы в шестнадцатеричных цифрах:

.. code-block:: c

  int p=29;
  cout.unsetf(ios::dec);
  cout.setf(ios::hex|ios::uppercase);
  cout << "p= " << p << endl;



Выводить знак + для положительных чисел:

.. code-block:: c

  int p=29;
  cout.setf(ios::showpos);
  cout << "p= " << p << endl;


Экспоненциальная форма вывода вещественных чисел:

.. code-block:: c

  double p=146.673;
  cout.setf(ios::scientific);
  cout << "p= " << p << endl;




Фиксированная форма вывода вещественных чисел (по умолчанию):

.. code-block:: c

  double p=146.673;
  cout.setf(ios::fixed);
  cout << "p= " << p << endl;
 


Использование манипуляторов форматирования.
===========================================

Манипуляторы встраиваются непосредственно в операторы ввода-вывода. С одним из них (endl) вы уже знакомы. 
В таблице ниже приведены основные манипуляторы форматирования. Для корректного их использования необходимо 
подключить библиотеку iomanip с помощью оператора #include <iomanip>


===================  ==================================================================================================   
Манипулятор          Описание  
setw(n)              Определяет ширину поля вывода в n символов                     
setprecision(n)      Определяет количество цифр (n-1) в дробной части числа                         
left                 Выравнивание по левой границе (по умолчанию)                        
right                Выравнивание по правой границе 
boolalpha            Вывод логических величин в текстовом виде 
noboolalpha          Вывод логических величин в числовом виде
dec                  Вывод величин в десятичной системе счисления (по умолчанию)
oct                  Вывод величин в восьмеричной системе счисления (для этого нужно снять флаг вывод в десятичной)
hex                  Вывод величин в шестнадцатеричной системе счисления (для этого нужно снять флаг вывод в десятичной)
showbase             Выводить индикатор основания системы счисления
noshowbase           Не выводить индикатор основания системы счисления
uppercase            Использовать прописные буквы в шестнадцатеричных цифрах
nouppercase          Использовать строчные буквы в шестнадцатеричных цифрах
showpos              Выводить знак + для положительных чисел
noshowpos            Не выводить знак + для положительных чисел
scientific           Экспоненциальная форма вывода вещественных чисел
fixed                Фиксированная форма вывода вещественных чисел (по умолчанию)
setfill(c)           Установить символ c как заполнитель
===================  ==================================================================================================




Другиe способы управления шириной поля вывода с помощью операторов.
===================================================================

•	cout.width(n) — устанавливает ширину поля вывода — n позиций;

•	cout.presicion(m) — определяет m цифр в дробной части числа;

Рассмотренные возможности форматированного ввода-вывода могут быть использованы и при обработке текстовых файлов.


Ошибки при работе с динамической памятью.
=========================================

Ошибка сегментации (Segmentation fault).
========================================


Ошибка сегментации (англ. Segmentation fault, сокр. segfault) — ошибка программного обеспечения, возникающая при
попытке обращения к недоступным для записи участкам памяти либо при попытке изменения памяти запрещённым способом. 
Если процесс попытается использовать "чужую" память, обратившись по некоторому случайному адресу, операционная система
аварийно завершит процесс с выводом предупреждения. 


.. code-block:: c

  #include <iostream>
  using namespace std;

  void foo(int *pointer)
   {
        *pointer = 0; //потенциальный Segmentation fault
    }

   int main()
   {
        int *p;
        *NULL = 10; //совсем очевидный Segmentation fault
        *p = 10; // достаточно очевидный Segmentation fault
        foo(NULL); //скрытый Segmentation fault
        
        return 0;
   }



Пример ошибки сегментации при попытке записать в область памяти, предназначенную только для чтения: 



.. code-block:: c

  int main() {
     const char *p = "hello world";
    *(char *)p = 'H';
   }


Чаще всего ошибка сегментации происходит потому, что указатель или нулевой, или указывает на произвольный участок
памяти (возможно, потому что не был инициализирован), или указывает на удаленный участок памяти.
Ошибка сегментации может возникнуть при использовании массивов, если случайно указать в качестве размера
массива неинициализированную переменную.


Утечка памяти (Memory leak).
============================


Утечка памяти (англ. memory leak) — процесс неконтролируемого уменьшения объёма свободной оперативной памяти компьютера,
связанный с ошибками в работающих программах, вовремя не освобождающих ненужные уже участки памяти, или с ошибками системных
служб контроля памяти. Если процесс попросил у ОС память, а затем про нее забыл и более не использует, это называется утечкой памяти.

Утечки памяти не являются критической ошибкой и в небольшом масштабе допустимы, если процесс работает очень недолго
(секунды). Однако при разработке сколько-нибудь масштабируемого и выполняющегося продолжительное время приложения, 
допущение даже маленьких утечек памяти — серьезная ошибка.



.. code-block:: c

  #include <iostream>
  using namespace std;

  void swap_arrays(int *A, int *B, size_t N)
  {
        int * tmp = new int [N]; //временный массив
        for(size_t i = 0; i < N; i++)
                tmp [i] = A[i];
        for(size_t i = 0; i < N; i++)
                A[i] = B[i];
        for(size_t i = 0; i < N; i++)
                B[i] = tmp [i];  
        }    //выходя из функции, забыли освободить память временного массива

   int main()
   {
        int A[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  int B[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        swap_arrays(A, B, 10); //функция swap_arrays() имеет утечку памяти
        return 0;
   }


Рассмотрим пример:


.. code-block:: c

  char *p;
  for( int i = 0; i < 5; i++ ) {
    p = new char[100];
   }
  delete [] p;


В этом примере с помощью new создается объект в динамической памяти. Вызов оператора new происходит 5 раз, 
причём каждый следующий раз адрес нового объекта перезаписывает значение, хранящееся в указателе p. 
Оператор delete выполняет удаление объекта, созданного на последней итерации цикла. Однако первые 4 объекта
остаются в динамической памяти, и одновременно в программе не остаётся переменных, которые бы хранили адреса 
этих объектов. Т.е. после завершения цикла невозможно ни получить доступ к первым 4 объектам, ни удалить их.

В случае с двухмерными массивами сценарий удаления выглядит следующим образом:


.. code-block:: c

  for (int i = 0; i < row_count; ++i) // где row_count кол-во элементов в массиве
    delete[] ptr[i];
  delete[] ptr;


Если "забыть" про цикл или подставить значение row_count меньшее чем при выделении памяти или не удалить ptr, 
то память не будет освобождена.

Утечки памяти приводят к тому, что потребление памяти программой неконтролируемо возрастает, в результате рано или
поздно вступают в действие архитектурные ограничения среды исполнения (операционной системы, виртуальной машины),
и тогда новое выделение памяти становится невозможным. В этой ситуации в программе, которая запрашивает память,
обычно происходит аварийная остановка. Это может по стечению обстоятельств произойти и совсем с другой программой
после того, как программа, подверженная утечкам, исчерпает всю память.

Как избежать ошибок работы с динамической памятью?

Во-первых, быть аккуратным и внимательным.

Во-вторых, если память выделена на одном уровне, освобождение должно быть совершено на том же уровне.
Например, если функция выделила память, она же должна ее освободить перед выходом. 

В-третьих, существуют специальные программные средства, которые позволяют искать утечки памяти, например 
Valgrind или AddressSanitizer.


new.
====

Операция new предназначена для создания объекта.


.. code-block:: c

  int *p = new int; //выделить память для одного int
  int *pp = new int [10]; //выделить память для массива размера 10.


Время жизни объекта, созданного с помощью new, не ограничивается областью видимости, в которой он был создан. 
Операция new возвращает указатель на созданный объект. Если объект является массивом, возвращается указатель 
на начальный элемент массива. Например, обе операции new int и new int[1] возвратят int\* , а типом
new int[i][10] будет int(\*)[10]. Если описывается тип массива, все размерности, кроме первой, должны быть
выражениями-константами с положительным значением. Первая размерность массива может задаваться произвольным выражением.


delete.
=======

Операция delete уничтожает объект, созданный с помощью new. 

.. code-block:: c

  delete p; //для удаления одного объекта
  delete[] pp; //для удаления динамического массива


Операндом delete должен быть указатель, который возвращает new. Эффект применения операции delete к указателю, который
не получен в результате операции new, считается неопределенным и обычно приводит к опасным последствиям. Однако гарантируется,
что удаление по указателю с нулевым значением безопасно.

Результат попытки доступа к удаленному объекту неопределен, а удаление объекта может изменить его значение. 
Более того, если выражение, задающее объект, является изменяемым адресом, его значение после удаления неопределено.

Результат удаления массива с помощью простого обращения delete не определен, так же как и удаление одиночного объекта 
с помощью delete [].

Статический двумерный массив — это массив одномерных массивов (строк), последовательно расположенных в памяти.

int A[10][20];

Обращение к элементу с индексами 1 и 2 двумерного массива A выглядит так: A[1][2].

Если статический двумерный массив нужно передать в функцию, то в нее передается только указатель на начальный элемент массива.
В соответствующем формальном параметре обязательно должен быть указан размер правого измерения, то есть длина строки массива.
Размер левого измерения указывать не обязательно.

Например, функция, получающая двумерный массив целых размерностью 10×10:


.. code-block:: c

  void func1(int x[][10])
     {
    /* … */
     }


Размер правого измерения необходим компилятору для того, чтобы внутри функции правильно вычислить адрес элемента массива,
так как для этого компилятор должен знать длину строки массива.



Массивы указателей.
===================


Как и объекты любых других типов, указатели могут быть собраны в массив.
Объявим одномерный массив из 10 указателей на объекты типа int:

.. code-block:: c

  int *A[10];


Для присвоения, например, адреса переменной var третьему элементу массива указателей, необходимо написать: A[2] = &var;
В результате этой операции, \*A[2] принимает то же значение, что и var.
Для передачи массива указателей в функцию используется тот же метод, что и для любого другого массива: 
имя массива без индекса записывается как формальный параметр функции. Например, функция может принять массив A в качестве аргумента:


.. code-block:: c

  void print_ptr_array(int *A[])
   {
        for(int i = 0; i < 10; i++)   cout << *A[i];
    }


Необходимо помнить, что A — это не указатель на целые, а указатель на массив указателей на целые. 
Поэтому параметр A нужно объявить как массив указателей на целые. Нельзя объявить A просто как указатель на целые,
потому что он представляет собой указатель на указатель.

Ту же функцию допустимо описать так:


.. code-block:: c

  void print_ptr_array(int **A)
   {
        for(int i = 0; i < 10; i++)   cout << *A[i];
   }


Динамические двумерные массивы в языке Си имеют сложный способ представления в памяти компьютера. 
Рассмотрим одномерный массив из 10 указателей на объекты int:
 

.. code-block:: c

  int *A[10];


A представляет собой указатель на указатель на int. Кроме того, массив указателей может быть не статическим, а динамическим:   


.. code-block:: c

  int **A;
  

Следующий шаг сделать очень просто — по указателям, хранящимся в массиве A могут лежать не по одному значению, 
а по одномерному динамическому массиву.


Передача динамических двумерных массивов в функцию.
===================================================


Динамические массивы передаются в функции по-другому, передается указатель на начало массива указателей, а длина строки
и количество строк вообще нигде не фигурируют. Контроль за границами массивов лежит полностью на программисте, поэтому,
вероятно, стоит передавать в функцию отдельными параметрами размеры массива — количество строк и столбцов.
Тип size_t - базовый беззнаковый целочисленный тип языка С/С++. Является типом результата, возвращаемого оператором sizeof. 
Размер типа выбирается таким образом, чтобы в него можно было записать максимальный размер теоретически возможного массива любого типа.

.. code-block:: c

  #include <iostream>
  #include <iomanip>
  #define MATRIX_HEIGHT 4
  #define MATRIX_WIDTH 5
  using namespace std;

   void dynamic_array_print(int **A, size_t N, size_t M)
   {
        for(int i = 0; i < N; i++) {
                for(int j = 0; j < M; j++) {
                       cout << setw(4)  <<  A[i][j];
                }
                cout << endl;
        }
     }

     //     Возвращает указатель на двумерный динамический массив
   int ** dynamic_array_alloc(size_t N, size_t M)
   {
        int **A = new  int * [N];
        for(int i = 0; i < N; i++) {
                A[i] = new  int  [M];
        }
        return A;
   }

   void dynamic_array_free(int **A, size_t N)
   {
        for(int i = 0; i < N; i++) {
              delete [] A[i];
        }
        delete [] A;
   }

   void dynamic_array_test(size_t N, size_t M)
   {
        int **A = dynamic_array_alloc(N, M);
        int x = 1;
        for(int i = 0; i < N; i++) {
                for(int j = 0; j < M; j++) {
                        A[i][j] = x;
                        x += 1;
                }
        }
        dynamic_array_print(A, N, M);
        /*исследование памяти*/
       cout <<  "Pointers to lines: " << "\n"  ;
        for(int **p = A; p < A + 3; p++)
                cout <<  (long int)*p;
        cout <<  "\n Direct memory access (dangerous!!!):\n";
        for(int *p = (int*)*A; p < (int*)*A + 25; p++)
                cout  <<   *p;
        dynamic_array_free(A, N);
   }

   int main()
   {
        dynamic_array_test(MATRIX_HEIGHT, MATRIX_WIDTH);
        return 0;
   }

  

Выделение памяти под динамический массив.
=========================================


Как видно из примера, создание такой сложной структуры как двумерный динамический массив требует множества системных 
вызовов по выделению памяти:


.. code-block:: c

  int **A = new  int * [N];
        for(int i = 0; i < N; i++) {
                A[i] = new  int  [M];
        }

  
При таком выделении памяти нельзя просто взять, и освободить память по адресу A, т.к. будет возникать утечка памяти. 

Правильное очищение таково:



.. code-block:: c

  for(int i = 0; i < N; i++) {
              delete [] A[i];
        }
        delete [] A;


Прототипы функций.
==================


Определение функции содержит как заголовок, так и тело функции.
Благодаря принципу раздельной компиляции, на самом этапе компиляции не требуется тело функции — достаточно только заголовка.

Прототипом функции в языке Си или C++ называется объявление функции, не содержащее тела функции, но указывающее:

•	имя функции,

•	количество аргументов (арность),

•	типы аргументов,

•	возвращаемый тип данных.

В то время как определение функции описывает, что именно делает функция, прототип функции — это описание её интерфейса.


.. code-block:: c

  double new_style(int a, double *x); /* прототип функции */


Обратите внимание на точку с запятой после закрывающей круглой скобки. Она значит, что тела функции тут не предполагается.
В прототипе имена аргументов являются необязательными, тем не менее, необходимо указывать тип вместе со всеми модификаторами
(например, если это указатель или константный аргумент):


.. code-block:: c

  double alt_style(int, double *); /* альтернативная форма прототипа */
  

На этапе компоновки тело функции всё-таки понадобится, иначе программу не удастся собрать.
Протипы функций модуля (отдельной единицы трансляции программы) выделяют в заголовочный файл .h.
Прототип при компиляции должен находиться выше по тексту, чем место использования функции, поэтому 
подключение (include) заголовочных файлов происходит в самом начале файла .cpp, использующего данный модуль.
Исходные данные функция должена получать из своих параметров. Список параметров в заголовке функции называется 
список формальных параметров.

Параметр функции — это принятый функцией аргумент, значение, переданное из вызывающего кода.

Различают:

•	фактический параметр — что именно передали в функцию при её вызове;

•	формальный параметр — указываемый при объявлении и определении функции.

Пример функции с одним параметром:


.. code-block:: c

  // Объявление функции.
   // int a - формальный параметр (имя параметра может отсутствовать).
   int my_function(int a);

   // Определение функции.
   // int b - формальный параметр (имя параметра может не совпадать с указанным при объявлении функции)
   int my_function(int b)
  {
   return b + 1;
   }

   int main()
   {
        int c = 0;
        my_function(c); // Вызов функции. c - фактический параметр.
        return 0;
   }

  
Часто в функциях используют аргументы по умолчанию. Для этого необходимо при объявлении прототипа данной функции
проинициализировать её параметры какими-то значениями, эти значения и будут использоваться в функции по умолчанию.
Аргументы по умолчанию должны быть заданы в прототипе функции.  

Если в функции несколько параметров, то параметры, которые опускаются, должны находиться правее остальных. 


.. code-block:: c

  void repch(char ch = '-', int k = 60) 
  { 
     for(int i = 0; i < k; ++i) 
           cout << ch; 
  } 
  repch();        //--выводится 60 минусов
  repch('+');        //--выводится 60 плюсов
  repch('=',52);        //--выводится 52 равно


Передача параметра по значению.
===============================



Параметры в С++ передаются по значению: вызывающая функция копирует в память, доступную вызываемой функции (сегмент стека), 
непосредственное фактическое значение. Изменение копии переменной, соответственно, оригинал не затрагивает!


Упражнение №1.
==============

.. code-block:: c

  void bad_incrementor(int x)
   {
        x++;
        std::cout << "x changed: " << x << std::endl;
   }


Вызвать функцию bad_incrementor(), которая изменяет формальный параметр, и убедиться в том, что фактический параметр неизменен.


Передача параметра по адресу.
=============================

Чтобы изменить переменную изнутри функции, можно передавать ей не значение, а адрес переменной, подлежащей изменению. 
При вызове такой функции приходится использовать операцию взятия адреса. Например: g(&x).

Передача параметра по адресу является частным случаем передачи по значению: передаваемым значением является адрес,
по которому можно найти другое значение — значение переменной x.



Упражнение №2.
==============


Описать функцию good_incrementor() в соответствии с прототипом. Она должна увеличивать значение переменной x на 1.



.. code-block:: c

  void good_incrementor(int *x);

   int main()
   {
        int x = 1;
        std::cout << "x initial: " << x << std::endl;
        good_incrementor(&x);
        std::cout << "x changed: " << x << std::endl;
        return 0;
   }



Не забывайте, что в теле функции x — это указатель, который при обращении нужно разыменовывать.




Упражнение №3.
==============


1.	Напишите функцию, которая принимает на вход числа M, N, K, выделяет память под матрицу размером MxN типа double,
и NxK типа int, MxK типа double, используя new[].

2.	Инициализирует элементы первой матрицы по правилу xij= i + j.

3.	Инициализирует элементы второй матрицы по правилу xij= 1 если i == j, 0 если i != j.

4.	Записывает в третью матрицу результат умножения двух и печатает результат.

5.	Транспонирует третью матрицу и печатает результат.

6.	Возводит третью матрицу в степень X и печатает результат.

7.	Освобождает выделенную память.



Упражнение №4.
==============


Выделите память под треугольную матрицу и заполните её, как треугольник Паскаля.



Метод Жордана-Гаусса.
=====================


Дана система n линейных алгебраических уравнений (СЛАУ) с m неизвестными. Требуется решить эту систему:
определить, сколько решений она имеет (ни одного, одно или бесконечно много), а если она имеет хотя бы одно решение,
то найти любое из них.

Алгоритм заключается в последовательном исключении переменных из каждого уравнения до тех пор, пока в
каждом уравнении не останется только по одной переменной. Если n=m, то можно говорить, что алгоритм
Гаусса-Жордана стремится привести матрицу A системы к единичной матрице — ведь после того как матрица
стала единичной, решение системы очевидно — решение единственно и задаётся получившимися коэффициентами bj.

При этом алгоритм основывается на двух простых эквивалентных преобразованиях системы: во-первых, можно 
обменивать два уравнения, а во-вторых, любое уравнение можно заменить линейной комбинацией этой строки
(с ненулевым коэффициентом) и других строк (с произвольными коэффициентами).

На первом шаге алгоритм Гаусса-Жордана делит первую строку на коэффициент a11. Затем алгоритм прибавляет
первую строку к остальным строкам с такими коэффициентами, чтобы их коэффициенты в первом столбце обращались
в нули — для этого, очевидно, при прибавлении первой строки к i-ой надо домножать её на –ai1. При каждой операции
с матрицей A (деление на число, прибавление к одной строке другой) соответствующие операции производятся и с
вектором b ; в некотором смысле, он ведёт себя, как если бы он был m+1-ым столбцом матрицы A.

В итоге, по окончании первого шага первый столбец матрицы A станет единичным (т.е. будет содержать единицу
в первой строке и нули в остальных).

Аналогично производится второй шаг алгоритма, только теперь рассматривается второй столбец и вторая строка: 
сначала вторая строка делится на a22, а затем отнимается от всех остальных строк с такими коэффициентами, 
чтобы обнулять второй столбец матрицы A. И так далее, пока мы не обработаем все строки или все столбцы
матрицы A. Если n=m, то по построению матрица A получится единичной, что нам и требовалось.

Поиск опорного элемента (pivoting). 

Разумеется, описанная выше схема неполна. Она работает только в том случае, если на каждом i-ом шаге элемент
aii отличен от нуля — иначе мы просто не сможем добиться обнуления остальных коэффициентов в текущем столбце 
путём прибавления к ним i-ой строки.  Чтобы сделать алгоритм работающим в таких случаях, как раз и существует
процесс выбора опорного элемента (на английском языке это называется одним словом "pivoting"). Он заключается в
том, что производится перестановка строк и/или столбцов матрицы, чтобы в нужном элементе aii оказалось ненулевое число.

Но какую же именно строку следует выбирать для обмена? И правда ли, что поиск опорного элемента надо делать
только тогда, когда текущий элемент aii  нулевой?

Общего ответа на этот вопрос не существует. Есть разнообразные эвристики, однако самой эффективной из них 
(по соотношению простоты и отдачи) является такая эвристика: в качестве опорного элемента следует брать 
наибольший по модулю элемент, причём производить поиск опорного элемента и обмен с ним надо всегда, а не 
только когда это необходимо (т.е. не только тогда, когда aii =0).

Иными словами, перед выполнением i-ой фазы алгоритма Гаусса-Жордана с эвристикой partial pivoting 
необходимо найти в i -ом столбце среди элементов с индексами от i до n максимальный по модулю, и обменять
строку с этим элементом с i -ой строкой. Эта эвристика позволит решить СЛАУ, даже если по ходу решения будет 
случаться так, что элемент aii = 0. Во-вторых, что весьма немаловажно, эта эвристика улучшает численную
устойчивость алгоритма Гаусса-Жордана.

Без этой эвристики, даже если система такова, что на каждой i-ой фазе aii не равен 0 — алгоритм Гаусса-Жордана 
отработает, но в итоге накапливающаяся погрешность может оказаться огромной даже для матриц размера около 20.

Добиться двукратного ускорения алгоритма можно, рассмотрев другую его версию, более классическую, когда алгоритм 
разбивается на фазы прямого и обратного хода.

Можно приводить матрицу не к диагональному виду, а к треугольному виду — когда все элементы строго ниже главной 
диагонали равны нулю.
Система с треугольной матрицей решается тривиально — сначала из последнего уравнения сразу находится
значение последней переменной, затем найденное значение подставляется в предпоследнее уравнение и находится
значение предпоследней переменной, и так далее. Этот процесс и называется обратным ходом алгоритма Гаусса.

Прямой ход алгоритма Гаусса — это алгоритм, аналогичный описанному выше алгоритму Гаусса-Жордана, за одним исключением:
текущая переменная исключается не из всех уравнений, а только из уравнений после текущего.
В результате этого действительно получается не диагональная, а треугольная матрица. Разница в том, что 
прямой ход работает быстрее алгоритма Гаусса-Жордана — поскольку в среднем он делает в два раза меньше
прибавлений одного уравнения к другому. 

Напишем функцию, которая использует это ускорение:


.. code-block:: c

   #include <iostream>
   #include <cmath>
   using namespace std;
   // Вывод системы уравнений
   void sysout(double **a, double *y, int n)
  {
    for (int i = 0; i < n; i++)
   {
      for (int j = 0; j < n; j++)
    {
      cout << a[i][j] << "*x" << j;
      if (j < n - 1)
        cout << " + ";
    }
    cout << " = " << y[i] << endl;
    }
    return;
    }

   double * gauss(double **a, double *y, int n)
   {
  double *x, max;
  int k, index;
  const double eps = 0.00001;  // точность
  x = new double[n];
  k = 0;
  while (k < n)
  {
    // Поиск строки с максимальным a[i][k]
    max = abs(a[k][k]);
    index = k;
    for (int i = k + 1; i < n; i++)
    {
      if (abs(a[i][k]) > max)
      {
        max = abs(a[i][k]);
        index = i;
      }
    }
    // Перестановка строк
    if (max < eps)
    {
      // нет ненулевых диагональных элементов
      cout << "Решение получить невозможно из-за нулевого столбца ";
      cout << index << " матрицы A" << endl;
      return 0;
    }
    for (int j = 0; j < n; j++)
    {
      double temp = a[k][j];
      a[k][j] = a[index][j];
      a[index][j] = temp;
    }
    double temp = y[k];
    y[k] = y[index];
    y[index] = temp;
    // Нормализация уравнений
    for (int i = k; i < n; i++)
    {
      double temp = a[i][k];
      if (abs(temp) < eps) continue; // для нулевого коэффициента пропустить
      for (int j = 0; j < n; j++)
        a[i][j] = a[i][j] / temp;
      y[i] = y[i] / temp;
      if (i == k)  continue; // уравнение не вычитать само из себя
      for (int j = 0; j < n; j++)
        a[i][j] = a[i][j] - a[k][j];
      y[i] = y[i] - y[k];
    }
    k++;
  }
  // обратная подстановка
  for (k = n - 1; k >= 0; k--)
  {
    x[k] = y[k];
    for (int i = 0; i < k; i++)
      y[i] = y[i] - a[i][k] * x[k];
  }
  return x;
   }
   
   int main()
  {
  double **a, *y, *x;
  int n;

  cout << "Введите количество уравнений: " << endl;
  cin >> n;
  a = new double*[n];
  y = new double[n];
  for (int i = 0; i < n; i++)
  {
    a[i] = new double[n];
    for (int j = 0; j < n; j++)
    {
      cout << "a[" << i << "][" << j << "]= ";
      cin >> a[i][j];
    }
  }
  for (int i = 0; i < n; i++)
  {
    cout << "y[" << i << "]= ";
    cin >> y[i];
  }
  sysout(a, y, n);
  x = gauss(a, y, n);
  for (int i = 0; i < n; i++)
    cout << "x[" << i << "]=" << x[i] << endl;

  for(int i = 0; i < n; i++) {
              delete [] a[i];
        }
        delete [] a;

  delete [] y;
  delete [] x;
  return 0;
   }



Упражнение №5.
==============


Скопируйте и проверьте работу реализации алгоритма Гаусса-Жордана.


Упражнение №6.
==============

Используйте этот алгоритм для вычисления определителя, ранга матрицы и обратной матрицы. Попробуйте применить это
всё к матрице Гильберта:

H[i][j] = 1/( i + j - 1) ;  i, j = 1,2,…, n.

При правильной реализации применение метода Гаусса к матрице Гильберта будет давать неправильный ответ.
Это связано с тем, что метод Гаусса плохо работает с матрицами, у которых очень большое число обусловленности,
которое показывает, как сильно может зависеть решение системы уравнений от погрешности условий.


Упражнение №7.
==============

Улучшите эту программу так, чтобы она в случае несовместной системы уравнений выдавала ответ “система уравнений несовместна“. 



Упражнение №8.
==============

Улучшите эту программу так, чтобы она в случае бесконечного множества решений выдавала ответ в виде векторов 
линейной оболочки множества решений, а если решений нет – выдавала бы ответ, что решений нет. 


Упражнение №9.
===============


Напишите функции, которые делают стандартные операции над векторами: 
скалярное произведение, векторное произведение, проекция на другой вектор, сложение векторов.



Упражнение №10.
===============


Напишите функции, которые вычисляют:

1)	Расстояние от точки до прямой, точка задаётся координатами, прямая задаётся точкой и направляющим вектором;

2)	Расстояние от точки до плоскости (плоскость задаётся точкой и нормалью);

3)	Нормаль к плоскости по трём точкам;

4)	Угол между прямыми, между прямой и плоскостью, между плоскостями;

5)	 Линию пересечения двух плоскостей и проверку на параллельность;

6)	Расстояние между скрещивающимися прямыми, точку пересечения пересекающихся прямых и проверку на параллельность – одна функция;

7)	Базис линейной оболочки данных векторов;

8)	Собственные числа и векторы данного линейного оператора.


Упражнение №11.
===============

Напишите функции, которые реализуют все стандартные геометрические преобразования
(на вход получают параметры преобразования и радиус-вектор точки пространства, который надо преобразовать). 

Теоретическая справка ниже.  


Геометрические преобразования. 
==============================


Геометрические преобразования имеют большое значение в геометрии. С помощью геометрических преобразований определяются
такие важные геометрические понятия, как равенство и подобие фигур. Благодаря геометрическим преобразованиям, многие
разрозненные факты геометрии укладываются в стройную теорию.

Введем определение центральной симметрии. 

Преобразование пространства, при котором каждая точка пространства отображается на точку, симметричную ей относительно точки , 
называется центральной симметрией пространства относительно точки . При этом точка отображается на себя
и называется центром симметрии. Примерами центральной симметрии являются: автомобильное колесо, окружность,
куб, шар, снежинка, цветок и тд.

Движения в пространстве. 

Симметрия относительно плоскости (зеркальная симметрия):

Преобразование пространства, при котором сохраняются расстояния между любыми двумя точками, называется движением пространства. 
Свойства: при движении в пространстве прямые переходят в прямые, полупрямые – в полупрямые, отрезки – в отрезки,
плоскости – в плоскости; сохраняются углы между полупрямыми.  Две фигуры называются равными, если они совмещаются движением.

В качестве примера движения пространства на данном этапе изучения стереометрии можно привести
преобразование центральной симметрии, доказав координатным способом, что при этой симметрии
сохраняются расстояния между точками. 

Введем понятие симметрии относительно плоскости: 

Преобразование пространства, при котором каждая точка пространства отображается на точку,
симметричную ей относительно плоскости , называется симметрией пространства относительно плоскости . 
Плоскость называется плоскостью симметрии. 

Параллельный перенос: 

Параллельным переносом на вектор называется такое преобразование пространства, при котором любая точка 
отображается на такую точку , что выполняется векторное равенство . Это перенос (движение) всех точек
пространства в одном и том же направлении, на одно и то же расстояние.

Если плоскость (прямая) не параллельна вектору переноса, то при переносе на этот вектор она отображается 
на параллельную ей плоскость (прямую).

Осевая симметрия — это симметрия относительно проведённой прямой (оси).

Подобие: 

Преобразования фигуры в фигуру называется преобразования подобия, если при этом преобразовании
расстояние между точками изменяется в одно и тоже число раз. То есть преобразование, которое сохраняет форму фигуры,
но изменяет их размеры.

Гомотетия: 

Гомотетия — это преобразование подобия. Это преобразование, в котором получаются подобные фигуры. 
Чтобы гомотетия была определена, должен быть задан центр гомотетии и коэффициент. В отличие от гомотетии, 
геометрические преобразования — центральная симметрия, осевая симметрия, поворот, параллельный перенос
являются движением, т.к. в них фигура отображается в фигуру, равную данной.

Гомотетичные фигуры подобны, но подобные фигуры не всегда гомотетичны (в гомотетии важно расположение фигур). 
В орнаментах (на рисунке фракталы) можно видеть бесконечное множество подобных фигур, но обычно они не гомотетичны,
т.к. у них невозможно определить центр гомотетии.

