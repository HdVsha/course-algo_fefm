Представление графов и алгоритмы, основанные на поиске в глубину.
#################################################################

:date: 2019-04-02
:summary: Представление графов и алгоритмы, основанные на поиске в глубину.
:status: published

.. default-role:: code

.. contents:: Содержание


Введение
========

Данная работа посвящена изучению возможностей библиотеки NetworkX для визуального представления графов, различных форм представления графов и алгоритма поиска в глубину (DFS), на основе которого рассмотрено несколько базовых алгоритмов.

Библиотека NetworkX
===================

Подключение библиотеки:

.. code-block:: python

	import networkx as nx

NetworkX предназначена для изучения структуры, динамики и функционирования сложных сетей.
Она позволяет создавать и хранить графы в стандартных и нестандартных форматах, генерировать много 
типов случайных и классических графов, анализировать их структуру, строить сетевые модели и создавать
новые алгоритмы.

Библиотека NetworkX относится к *свободному программному обеспечению*, поэтому она может быть распространена и 
изменена согласно лицензии BSD.

Обзор библиотеки NetworkX на русском языке: `https://habrahabr.ru/post/125898/`_

.. _`https://habrahabr.ru/post/125898/`: https://habrahabr.ru/post/125898/

При использовании библиотеки обращайтесь к её актуальной онлайн-документации_. Там же можно найти учебник_ и примеры_!

.. _онлайн-документации: https://networkx.github.io/documentation/latest/
.. _учебник: https://networkx.github.io/documentation/latest/tutorial.html
.. _примеры: https://networkx.github.io/documentation/latest/auto_examples/index.html

Классы графов
-------------
NetworkX содержит четыре класса графов:

* Graph — граф без кратных рёбер (петли допустимы)
* DiGraph — ориентированный граф без кратных рёбер (петли допустимы)
* MultiGraph — граф с кратными рёбрами (в том числе с кратными петлями)
* MultiDiGraph — ориентированный граф с кратными рёбрами (в том числе с кратными петлями)

Внутреннее представление графов реализовано в виде списков смежности (словарь словарей словарей).
Однако во избежании появления несогласованности, все операции с графами должны производится
с использованием API функций библиотеки.

Вершины и рёбра
---------------

Вершиной может быть любой неизменяемый тип с вычислимой функцией `hash()`.
Например, прекрасно подойдут:

* str
* int
* float
* кортеж из строк и чисел
* frozenset (неизменяемое множество)

Каждой вершине можно добавлять и удалять свойства произвольного типа (см. раздел Attributes_).

Рёбра представляют собой связь двух вершин и чаще вершины имеют привязанные к ним данные — свойства рёбер.
Для указания веса ребра, используйте свойство **weight**.

.. _Attributes: https://networkx.github.io/documentation/latest/reference/functions.html#attributes 

Создание графа
--------------

Графы могут быть созданы тремя основными способами:

* явное добавление узлов и рёбер

.. code-block:: python

	G = nx.Graph()                                    # создаём экземпляр графа
	G.add_edge(1, 2)                                  # ребро добавляется сразу со своими вершинами
	G.add_edge(2, 3)                                  # стандартный вес ребра weight=1
	G.add_edge(3, 4, weight = 0.9)                    # можно задать weight сразу при создании ребра
	G.add_node(5)                                     # изолированный узел можно добавить отдельно
	G.add_node(6, x = 1.5, y = -5.0, data = ['any'])  # и сразу задать ему любые свойства

* генераторами графов — алгоритмами порождения стандартных сетевых топологий

.. code-block:: python

	G = nx.complete_graph(10)    # полносвязный граф с 10 вершинами
	G = nx.path_graph(10)        # 10 узлов, расположенных "в линеечку"
	G = nx.cycle_graph(10)       # 10 узлов, связанных кольцом
	G = nx.star_graph(5)         # звезда с 1 узлом в середине и 5 узлами-лучами
	G = nx.balanced_tree(2, 3)   # сбалансированное двоичное дерево высоты 3
	G = nx.empty_graph(10)       # граф с 10 вершинами без рёбер

* импорт данных графа из некоторого формата (обычно из файла)

.. code-block:: python

	d = {0: {1: {'weight': 10}, 2: {'weight': 20}},
	     1: {0: {'weight': 10}, 3: {'weight': 30}},
	     2: {0: {'weight': 20}},
	     3: {1: {'weight': 30}}}
	G = nx.Graph(d)
	dd = nx.to_dict_of_dicts(G) # d == dd

Визуализация графа
------------------

Визуализация графов — нетривиальная задача! Существует много полноценных библиотек,
предназначенных именно для этого:  Cytoscape, Gephi, Graphviz или PGF/TikZ для LaTeX.
Для их использования можно экспортировать граф из NetworkX в формат GraphML.

Однако, есть и самый простой способ визуализации, встроенный в саму библиотеку NetworkX,
при подключении библиотеки `matplotlib.pyplot`.

.. code-block:: python

	nx.draw(G)           # отобразить граф при помощи Matplotlib
	nx.draw_circular(G)  # Использовать расположение circular layout
	nx.draw_random(G)    # Использовать расположение random layout
	nx.draw_spectral(G)  # Использовать расположение spectral layout
	nx.draw_spring(G)    # Использовать расположение spring layout
	nx.draw_shell(G)     # Использовать расположение shell layout
	nx.draw_graphviz(G)  # Использовать graphviz для расположения вершин


Пример визуализации графа №1
++++++++++++++++++++++++++++

.. code-block:: python

	import matplotlib.pyplot as plt
	import networkx as nx

	G=nx.path_graph(8)
	nx.draw(G)
	plt.savefig("simple_path.png") # сохранить как png файл
	plt.show() # вывести на экран

Пример визуализации графа №2
++++++++++++++++++++++++++++

Пример добавления этикеток на вершины и подкрашивания рёбер:

.. code-block:: python

	"""
	Отрисовка графа через matplotlib, с разными цветами.

	"""
	__author__ = """Aric Hagberg (hagberg@lanl.gov)"""

	import matplotlib.pyplot as plt
	import networkx as nx

	G=nx.cubical_graph()
	pos=nx.spring_layout(G) # позиции всех вершин

	# вершины
	nx.draw_networkx_nodes(G, pos,
		               nodelist=[0,1,2,3], # список вершин
		               node_color='r',     # красный цвет
		               node_size=500,      # размер
		           alpha=0.8)              # прозрачность
	nx.draw_networkx_nodes(G, pos,
		               nodelist=[4,5,6,7],
		               node_color='b',
		               node_size=500,
		           alpha=0.8)

	# рёбра
	nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5) # все рёбра
	nx.draw_networkx_edges(G, pos,
		               edgelist=[(0,1),(1,2),(2,3),(3,0)],
		               width=8, alpha=0.5, edge_color='r')   # красные рёбра
	nx.draw_networkx_edges(G, pos,
		               edgelist=[(4,5),(5,6),(6,7),(7,4)],
		               width=8, alpha=0.5, edge_color='b')   # синие рёбра

	# добавим математические названия вершин
	labels={}
	labels[0]=r'$a$'
	labels[1]=r'$b$'
	labels[2]=r'$c$'
	labels[3]=r'$d$'
	labels[4]=r'$\alpha$'
	labels[5]=r'$\beta$'
	labels[6]=r'$\gamma$'
	labels[7]=r'$\delta$'
	nx.draw_networkx_labels(G, pos, labels, font_size=16)

	plt.axis('off')
	plt.savefig("labels_and_colors.png") # сохранить как png картинку
	plt.show() # вывести на экран


Пример визуализации графа №3
++++++++++++++++++++++++++++

Ещё один пример добавления этикеток на вершины и подкрашивания рёбер:

.. code-block:: python

	"""
	Пример использования Graph как взешенного.
	"""
	__author__ = """Aric Hagberg (hagberg@lanl.gov)"""
	
    import matplotlib.pyplot as plt
	import networkx as nx

	G = nx.Graph()
	
	#   добавляем рёбра и вершины

	G.add_edge('a', 'b', weight=0.6)
	G.add_edge('a', 'c', weight=0.2)
	G.add_edge('c', 'd', weight=0.1)
	G.add_edge('c', 'e', weight=0.7)
	G.add_edge('c', 'f', weight=0.9)
	G.add_edge('a', 'd', weight=0.3)

	elarge = [(u,v) for (u,v,d) in G.edges(data=True) if d['weight'] >0.5]  # "тяжёлые"
	esmall = [(u,v) for (u,v,d) in G.edges(data=True) if d['weight'] <=0.5] # "лёгкие"

	pos = nx.spring_layout(G) # позиции всех вершин

	# вершины
	nx.draw_networkx_nodes(G, pos, node_size=700)

	# рёбра
	nx.draw_networkx_edges(G, pos, edgelist=elarge,
	                width=6)                                   # "тяжёлые"
	nx.draw_networkx_edges(G, pos, edgelist=esmall,
	       width=6, alpha=0.5, edge_color='b', style='dashed') # "лёгкие"

	# метки
	nx.draw_networkx_labels(G,pos,font_size=20,font_family='sans-serif')

	plt.axis('off')
	plt.savefig("weighted_graph.png") # сохранить как png картинку
	plt.show() # вывести на экран


Существует два способа представления графа, в виде списков смежности и в виде матрицы смежности. Оба способа подходят для представления ориентированных и неориентированных графов.


Представление графов матрицами смежности.
=========================================



Этот способ является удобным для представления плотных графов, в которых количество рёбер `(|E|)` примерно равно количеству вершин в квадрате `(|V|^2)`. 

В данном представлении мы заполняем матрицу размером `|V| x |V|` следущим образом: 

A[i][j] = 1 (Если существует ребро из i в j)

A[i][j] = 0 (Иначе)

Этот способ является удобным для представления плотных графов, в которых количество рёбер `(|E|)` примерно равно количеству вершин в квадрате `(|V|^2)`. 

Данный способ подходит для ориентированных и неориентированных графов. Для неориентированных графов матрица A является симметричной
(то есть A[i][j] == A[j][i], т.к. если существует ребро между i и j, то оно является и ребром из i в j, и ребром из j в i). Благодаря этому свойству можно сократить почти в два раза использование памяти, храня элементы только в верхней части матрицы, над главной диагональю)


Понятно что с помощью данного способа представления, можно быстро проверить есть ли ребро между вершинами v и u, просто посмотрев в ячейку A[v][u].


С другой стороны этот способ очень громоздкий, так как требует `O (|V|^2)` памяти для хранения матрицы.


.. image:: {filename}/images/matrix_graph.png



Пример реализации графа на следующем рисунке:


.. image:: {filename}/images/primergraph.png






.. code-block:: python

	a, b, c, d, e, f, g, h = range(8)
	# a b c d e f g h
	N =  [[0,1,1,1,1,1,0,0], # a
	  [0,0,1,0,1,0,0,0], # b
	  [0,0,0,1,0,0,0,0], # c
	  [0,0,0,0,1,0,0,0], # d
	  [0,0,0,0,0,1,0,0], # e
	  [0,0,1,0,0,0,1,1], # f
	  [0,0,0,0,0,1,0,1], # g
	  [0,0,0,0,0,1,1,0]] # h


Для проверки вхождения вершины b в список смежности для данной вершины a нужно проверить истинность N[a][b]. Чтобы найти степень вершины, достаточно использовать функцию sum:


.. code-block:: python

	>>> N[a][b]
	1
	>>> sum(N[f])
	3


Разреженные матрицы нередко представляются в виде словарей, ключом в которых является кортеж координат, а значением - значение ненулевого элемента матрицы. Например

.. code-block:: python

	matrix = {(0, 0):3, (0, 2):-2, (0, 3):11, (1, 1):9, (2, 1):7, (3, 3):5}


Расширение матрицы смежности для использования весов тривиально: вместо сохранения логических значений, сохраняйте значения весов. В случае с ребром (u, v) N[u][v] будет весом ребра w(u,v) вместо True. Часто в практических целях несуществующим ребрам присваиваются бесконечные веса. (Это гарантирует, что они не будут включены, например, в кратчайшие пути, т. к. мы ищем путь по существующим ребрам). Не всегда очевидно, как представить бесконечность, но совершенно точно есть несколько разных вариантов.


Один из них состоит в том, чтобы использовать некорректное для веса значение, такое как None или -1, если известно, что все веса неотрицательны. Возможно, в ряде случаев полезно использовать действительно большие числа. Для целых весов можно применить sys.maxint, хотя это значение и не обязательно самое большое (длинные целые могут быть больше). Есть и значение, введенное для отражения бесконечности: inf. Оно недоступно в Python напрямую по имени и выражается как float('inf')(гарантируется, что это работает для Python 2.6 и старше. В ранних версиях подобные специальные значения были платформо-зависимы, хотя float('inf') или float('Inf') должны сработать на большинстве платформ).

Листинг ниже показывает, как выглядит матрица весов, реализованная вложенными списками. Использованы те же веса, что и в листинге выше.


.. code-block:: python

	a, b, c, d, e, f, g, h = range(8)
	_ = float('inf')
	  # a b c d e f g h
	W = [[0,2,1,3,9,4,_,_], # a
 	  [_,0,4,_,3,_,_,_], # b
	  [_,_,0,8,_,_,_,_], # c
	  [_,_,_,0,7,_,_,_], # d
	  [_,_,_,_,0,5,_,_], # e
	  [_,_,2,_,_,0,2,2], # f
	  [_,_,_,_,_,1,0,6], # g
	  [_,_,_,_,_,9,8,0]] # h


Бесконечное значение обозначено как подчеркивание (_), потому что это коротко и визуально различимо. Естественно, можно использовать любое имя, которое вы предпочтете. Обратите внимание, что значения на диагонали по-прежнему равны нулю, потому что даже без учета петель, веса часто интерпретируются как расстояния, а расстояние от вершины до самой себя равно нулю.


Конечно, матрицы весов дают возможность очень просто получить веса ребер, но, к примеру, проверка смежности и определение степени вершины, или обход всех смежных вершин делаются иначе. Здесь нужно использовать бесконечное значение, примерно так (для большей наглядности определим inf = float('inf')):



.. code-block:: python

	>>> W[a][b] < inf # смежность
	True
	>>> W[c][e] < inf # смежность
	False
	>>> sum(1 for w in W[a] if w < inf) - 1 # степень
	5


Обратите внимание, что из полученной степени вычитается 1, потому что мы не считаем значения на диагонали. Сложность вычисления степени тут О(n), в то время как в другом представлении и смежность, и степень вершины можно определить за константное время. Так что вы всегда должны понимать, как именно вы собираетесь использовать ваш граф и выбирать для него соответствующее представление.




Списки смежности.
=================


Данный способ представления больше подходит для разреженных графов, то есть графов у которых количество рёбер гораздо меньше чем количество вершин в квадрате `(|E| << |V|^2)`.

В данном представлении используется массив Adj содержащий `|V|` списков. В каждом списке Adj[v] содержатся все вершины u, так что между v и u есть ребро. Память требуемая для представления равна `O (|E| + |V|)` что является лучшим показателем чем матрица смежности для разреженных графов.

Главный недостаток этого способа представления в том, что нет быстрого способа проверить существует ли ребро (u, v). 


.. image:: {filename}/images/spisok_graph.png



Рассмотрим теперь граф на следующем рисунке:


.. image:: {filename}/images/primergraph.png




Пример его реализации с использованием множеств: 


.. code-block:: python

	a, b, c, d, e, f, g, h = range(8)
	N = [
 	 {b, c, d, e, f}, # a
 	 {c, e}, # b
 	 {d}, # c
 	 {e}, # d
 	 {f}, # e
 	 {c, g, h}, # f
 	 {f, h}, # g
 	 {f, g} # h
	]
	
	
В таком представлении удобно проверять принадлежность и вычислять степень вершины:


.. code-block:: python

	>>> b in N[a]  # смежная?
	True
	>>> len(N[f])  # степень
	3

Позволяет выиграть время, если требуется в основном проверять эти две вещи, но значительно медленнее работает по сравнению
с просто списком списков, если нужно обходить вершины.


Пример реализации с использованием списка списков: 



.. code-block:: python

	a, b, c, d, e, f, g, h = range(8)
	N = [
 	 [b, c, d, e, f], # a
 	 [c, e], # b
	 [d], # c
	 [e], # d
	 [f], # e
	 [c, g, h], # f
	 [f, h], # g
	 [f, g] # h
	]


Можно поспорить, что это представление на самом деле — набор массивов смежности, а не классические списки смежности, т.к. тип список в Python в действительности является динамическим массивом. Если хотите, вы можете реализовать тип связанного списка и использовать его вместо типа list из Python. Это может сделать дешевле в плане производительности произвольные вставки в список, но вам, вероятно, и не понадобится такая операция, потому что с тем же успехом можно добавлять новые вершины к концу списка. 

Преимущество использования встроенного list в том, что он представляет собой очень быструю и хорошо отлаженную структуру (в отличие от любых структур списков, которые можно реализовать на чистом Python).


При работе с графами постоянно всплывает идея о том, что лучшее представление зависит от того, что именно нужно сделать с графом. Например, используя списки (или массивы) смежности можно сохранить накладные расходы небольшими и обеспечить эффективный обход N(v) для любой вершины v. Однако, проверка, являются ли u и v смежными, потребует времени О(N(v)), что может стать проблемой при высокой плотности графа (т.е. при большом числе ребер). В этих случаях на помощь придут множества смежности. 

Известно, что удаление объектов из середины list в Python довольно затратно. Удаление с конца при этом происходит за константное время. Если вы не заботитесь о порядке вершин, то можете удалять случайную вершину за константное время перезаписывая ее той, что находится в конце списка смежности, и вызывая затем метод pop.


Небольшой вариацией на тему этого представления можно назвать сортированные списки смежных вершин. Если списки нечасто меняются, их можно держать отсортированными и использовать бисекцию для проверки смежности вершины, что приведет к немного меньшим накладным расходам (в плане использования памяти и времени итерации), но увеличит сложность проверки до О(log2(k)), где k — количество смежных с данной вершин. (Это все равно очень маленькое значение. На практике, впрочем, использование встроенного типа set доставляет гораздо меньше хлопот).


Еще одна небольшая доработка заключается в использовании словарей вместо множеств или списков. Смежные вершины могут быть ключам словаря, а в качестве значения можно использовать любые дополнительные данные, например, вес ребра. Как это выглядит можно увидеть в листинге ниже (веса выбраны случайно).

Пример реализации с использованием списка словарей:  


.. code-block:: python

	a, b, c, d, e, f, g, h = range(8)
	N = [
 	 {b:2, c:1, d:3, e:9, f:4},# a
 	 {c:4, e:3}, # b
 	 {d:8}, # c
 	 {e:7}, # d
 	 {f:5}, # e
 	 {c:2, g:2, h:2}, # f
 	 {f:1, h:6}, # g
 	 {f:9, g:8} # h
	]


Словарь смежности можно использовать точно так же как и другие представления, с учетом дополнительной информации о весах:


.. code-block:: python

	>>> b in N[a] # смежность
	True
	>>> len(N[f]) # степень
	3
	>>> N[a][b]  # вес (a, b)
	2


До этого момента сущность, хранящая структуры смежности — списки, множества или словари — была списком, индексированным номерами вершин. Более гибкий вариант (позволяющий использовать произвольные, хэшируемые, имена вершин) строится на базе словаря в качестве основной структуры (такие словари со списками смежности Гвидо ван Россум использовал в своей статье «Python Patterns — Implementing Graphs», выложенной по адресу https://www.python.org/doc/essays/graphs/ ). Листинг ниже показывает пример словаря, содержащего множества смежности. Заметьте, что вершины в нем обозначены символами.


.. code-block:: python

	N = {
 	 'a': set('bcdef'),
 	 'b': set('ce'),
 	 'c': set('d'),
 	 'd': set('e'),
 	 'e': set('f'),
	 'f': set('cgh'),
	 'g': set('fh'),
	 'h': set('fg')
	}





Алгоритм DFS.
=============


Обход в глубину (поиск в глубину, англ. Depth-First Search, DFS) — один из основных методов обхода графа, часто используемый для проверки связности, поиска цикла и компонент сильной связности и для топологической сортировки. 

Общая идея алгоритма состоит в следующем: для каждой не пройденной вершины необходимо найти все не пройденные смежные вершины и повторить поиск для них.


Пошаговое представление:

1. Выбираем любую вершину из еще не пройденных, обозначим ее как u.

2. Запускаем процедуру dfs(u). 

3. Помечаем вершину u как пройденную. 

4. Для каждой не пройденной смежной с u вершиной (назовем ее v) запускаем dfs(v).

5. Повторяем шаги 1 и 2, пока все вершины не окажутся пройденными.


Зачастую, простой информации "были/не были в вершине" не хватает для конкретных целей.

Поэтому в процессе алгоритма вершинам задают некоторые цвета:

если вершина белая, значит, мы в ней еще не были, вершина не пройдена;

серая — вершина проходится в текущей процедуре dfs;

черная — вершина пройдена, все итерации dfs от нее завершены.

Такие "метки" в основном используются при поиске цикла.

Примеры псевдокода реализации на Python.


.. code-block:: python

	def doDfs(G[n]: Graph): # функция принимает граф G с количеством вершин n и выполняет обход в глубину во всем графе 
            visited = array[n, false]  # создаём массив посещённых вершины длины n, заполненный false изначально
          
            def dfs(u: int):   
      		visited[u] = true
      		for v: (u, v) in G:        
         		if not visited[v]:               
            		   dfs(v)
            for i in range(1, n):             
      		if not visited[i]:                    
         		dfs(i)
	
	#  вариант с цветами
	
	def doDfs(G[n]: Graph): // функция принимает граф G с количеством вершин n и выполняет обход в глубину во всем графе 
            color = array[n, white]
                   
            def dfs(u: int):
                color[u] = gray           
                for v: (u, v) in G:                   
                    if color[v] == white:
                        dfs(v)
                color[u] = black   
                   	   
            for i in range(1, n):
	       if color[i] == white:                
                   dfs(i)
		   
	
 

Выделение компонент связности с помощью DFS.
============================================


Алгоритм обхода в глубину позволяет решать множество различных задач. Например, реализуем при помощи алгоритма обхода в глубину подсчет числа компонент связности в неориентированном графе.


Для этого будем обходить все вершины графа и проверять, была ли очередная вершина посещена ранее. Если не была – то это означает, что найдена новая компонента связности, для выделения всей компоненты связности необходимо запустить DFS от этой вершины.


.. code-block:: python

	Visited = [False] * n

	def DFS(start):
    		Visited[start] = True
    		for v in V[start]:
        		if not Visited[v]:
            		DFS(v)

	ncomp = 0
	for i in range(n): 
    		if not Visited(i):
        		ncomp += 1
        		DFS(i)



Проверка цикла в ориентированном графе с помощью DFS.
=====================================================


Цикл в ориентированном графе можно обнаружить по наличию ребра, ведущего из текущей вершины в вершину, которая в настоящий момент находится в стадии обработки, то есть алгоритм DFS зашел в такую вершину, но еще не вышел из нее. 


В таком алгоритме DFS будем красить вершины в три цвета. 

Цветом 0 («белый») будем обозначать еще непосещенные вершины. 

Цветом 1 («серый») будем обозначать вершины в процессе обработки.

Цветом 2 («черный») будем обозначать уже обработанные вершины. Вершина красится в цвет 1 при заходе в эту вершину и в цвет 2 – при выходе. Цикл в графе существует, если алгоритм DFS обнаруживает ребро, конец которого покрашен в цвет 1.


.. code-block:: python

	Color = [0] * n
	CycleFound = False

	def DFS(start):
    		Color[start] = 1
    		for u in V[start]:
        		if Color[u] == 0:
            			DFS(v)
			elif Color[u] == 1:
			 	CycleFound = True
		Color[start] = 2

	for i in range(n):
		if Color[i] == 0:
			DFS(i)
	






Дерево обхода в глубину.
========================

Рассмотрим подграф предшествования обхода в глубину Gp=(V,Ep), где Ep={(p[u],u):u∈V, p[u]≠NIL}, где в свою очередь p[u] — вершина, от которой был вызван dfs(u)  (для вершин, от которых dfs был вызван нерекурсивно это значение соответственно равно NIL). 

Подграф предшествования поиска в глубину образует лес обхода в глубину, который состоит из нескольких деревьев обхода в глубину. С помощью полученного леса можно классифицировать ребра графа G, который мы обходим в глубину.

1. Ребрами дерева назовем те ребра из G, которые вошли в Gp.

2. Ребра (u,v), соединяющие вершину u с её предком v в дереве обхода в глубину назовем обратными ребрами (для неориентированного графа предок должен быть не родителем, так как иначе ребро будет являться ребром дерева).

3. Ребра (u,v), не являющиеся ребрами дерева и соединяющие вершину u с её потомком v в дереве обхода в глубину назовем прямыми ребрами (в неориентированном графе нет разницы между прямыми и обратными ребрами, поэтому все такие ребра считаются обратными).

4. Все остальные ребра назовем перекрестными ребрами — такие ребра могут соединять вершины одного и того же дерева обхода в глубину, когда ни одна из вершин не является предком другой, или соединять вершины в разных деревьях.


Алгоритм dfs можно модифицировать так, что он будет классифицировать встречающиеся при работе ребра. Ключевая идея состоит в том, что каждое ребро (u,v) можно классифицировать при помощи цвета вершины v при первом его исследовании, а именно:

1. Белый цвет вершины v по определению dfs говорит о том, что это ребро дерева.

2. Серый цвет в силу того, что серые вершины всегда образуют нисходящий путь в каком-либо из деревьев dfs и встреченная вершина v лежит на нем выше вершины u, определяет обратное ребро (для неориентированного графа необходимо проверить условие v≠p[u]).

3. Черный цвет, соответственно, указывает на прямое или перекрестное ребро.


На рисунке: 

1. Синий цвет - обратные рёбра. 

2. Зелёный цвет - прямые рёбра. 

3. Красный цвет - перекрёстные рёбра. 


.. image:: {filename}/images/671px-Colors.png





Топологическая сортировка.
==========================

Дан ориентированный граф с n вершинами и m рёбрами. Требуется перенумеровать его вершины таким образом, чтобы каждое рёбро вело из вершины с меньшим номером в вершину с большим.

Иными словами, требуется найти перестановку вершин (топологический порядок), соответствующую порядку, задаваемому всеми рёбрами графа.

Топологическая сортировка может быть не единственной (например, если граф — пустой; или если есть три такие вершины a, b, c, что из a есть пути в b и в c, но ни из b в c, ни из c в b добраться нельзя).


Топологической сортировки может не существовать вовсе — если граф содержит циклы (поскольку при этом возникает противоречие: есть путь и из одной вершины в другую, и наоборот).


Распространённая задача на топологическую сортировку — следующая. Есть n переменных, значения которых нам неизвестны. Известно лишь про некоторые пары переменных, что одна переменная меньше другой. Требуется проверить, не противоречивы ли эти неравенства, и если нет, выдать переменные в порядке их возрастания (если решений несколько — выдать любое). Легко заметить, что это в точности и есть задача о поиске топологической сортировки в графе из n вершин.


Алгоритм решения. 


Для решения воспользуемся обходом в глубину.


Предположим, что граф ацикличен, т.е. решение существует. Что делает обход в глубину? При запуске из какой-то вершины v он пытается запуститься вдоль всех рёбер, исходящих из v. Вдоль тех рёбер, концы которых уже были посещены ранее, он не проходит, а вдоль всех остальных — проходит и вызывает себя от их концов.


Таким образом, к моменту выхода из вызова dfs(v) все вершины, достижимые из v как непосредственно (по одному ребру), так и косвенно (по пути) — все такие вершины уже посещены обходом. Следовательно, если мы будем в момент выхода из dfs(v) добавлять нашу вершину в начало некоего списка, то в конце концов в этом списке получится топологическая сортировка.


Эти объяснения можно представить и в несколько ином свете, с помощью понятия "времени выхода" обхода в глубину. Время выхода для каждой вершины v — это момент времени, в который закончил работать вызов dfs(v) обхода в глубину от неё (времена выхода можно занумеровать от 1 до n). Легко понять, что при обходе в глубину время выхода из какой-либо вершины v всегда больше, чем время выхода из всех вершин, достижимых из неё (т.к. они были посещены либо до вызова dfs(v), либо во время него). Таким образом, искомая топологическая сортировка — это сортировка в порядке убывания времён выхода.




Пример реализации топологической сортировки.
============================================


Запускаем обход в глубину, и когда вершина обработана, заносим ее в стек. По окончании обхода в глубину вершины достаются из стека. Новые номера присваиваются в порядке вытаскивания из стека.

Цвет: во время обхода в глубину используется 3 цвета. Изначально все вершины белые. Когда вершина обнаружена, красим ее в серый цвет. Когда просмотрен список всех смежных с ней вершин, красим ее в черный цвет.

Проще рассмотреть данный алгоритм на примере:


Имеем бесконтурный ориентированный граф.

Изначально все вершины белые, а стек пуст.

Начнем обход в глубину с вершины номер 1.



.. image:: {filename}/images/tps1.PNG


Переходим к вершине номер 1. Красим ее в серый цвет.


.. image:: {filename}/images/tps2.PNG


Существует ребро из вершины номер 1 в вершину номер 4. Переходим к вершине номер 4 и красим ее в серый цвет.

.. image:: {filename}/images/tps3.PNG


Существует ребро из вершины номер 4 в вершину номер 2. Переходим к вершине номер 2 и красим ее в серый цвет.
 


.. image:: {filename}/images/tps4.PNG
 


 
Из вершины номер 2 нет рёбер, идущих не в черные вершины. Возвращаемся к вершине номер 4. 
Красим вершину номер 2 в черный цвет и кладем ее в стек.
 
 
.. image:: {filename}/images/tps5.PNG
  
  
Существует ребро из вершины номер 4 в вершину номер 3. Переходим к вершине номер 3 и красим ее в серый цвет.
  
  
.. image:: {filename}/images/tps6.PNG



Из вершины номер 3 нет рёбер, идущих не в черные вершины. Возвращаемся к вершине номер 4. 
Красим вершину номер 3 в черный цвет и кладем ее в стек.


.. image:: {filename}/images/tps7.PNG


Из вершины номер 4 нет рёбер, идущих не в черные вершины. Возвращаемся к вершине номер 1. Красим вершину номер 4 в черный цвет и кладем ее в стек.


.. image:: {filename}/images/tps8.PNG
  
 
 
Из вершины номер 1 нет рёбер, идущих не в черные вершины. Красим её в черный цвет и кладем в стек. Обход точек закончен.
 
 
 .. image:: {filename}/images/tps9.PNG
 

По очереди достаем все вершины из стека и присваиваем им номера 1, 2, 3, 4 соответсвенно. Алгоритм топологической сортировки завершен. Граф отсортирован.


Классическая функция топологической сортировки обходом в глубину выглядит так:


.. code-block:: python

	#Color — массив, в котором хранятся цвета вершин (0 — белый, 1 — серый, 2 — черный).
	#Edges — массив списков смежных вершин.
	#Numbers — массив, в котором сохраняются новые номера вершин.
	#Stack — стек, в котором складываются вершины после их обработки.
	#Cycle — принимает значение true, если в графе найден цикл.
	Edges = {'a':['c'], 'c':['b'], 'd':['c', 'b', 't'], 'b':[], 't':[]}
	def topologicSortDFS2(Edges):
    		Stack=[]
    		Color=dict()
    		for i in Edges.keys():
        		Color[i]=0
    	
		def topological_sort():
        	
			def dfs(v):
	#Если вершина серая, то мы обнаружили цикл. 
	#Заканчиваем поиск в глубину.
            			if Color[v] == 1: return True
            			if Color[v] == 2: return False   #Если вершина черная, то заканчиваем ее обработку.
            			Color[v] = 1                     #Красим вершину в серый цвет.
	#Обрабатываем список смежных с ней вершин.
            			for i in range(len(Edges[v])):
                			if dfs(Edges[v][i]): return True
            			Stack.append(v)                  #Кладем вершину в стек.
            			Color[v] = 2                     #Красим вершину в черный цвет.
            			return False;
        
	#Вызывается обход в глубину от всех вершин. 
	#Заканчиваем работу алгоритма, если обнаружен цикл.
        		for i in Edges.keys():
            			Cycle = dfs(i)
            			if Cycle: 
                			print("!!!имеется цикл!!!")
                			exit()
                
	#Заносим в массив новые номера вершин.    
        		Stack.reverse()
        		return Stack
    		return topological_sort()



Гамильтонов цикл.
=================

Гамильтоновым путем называется путь, проходящий через каждую вершину ровно один раз. Гамильтоновым циклом называется цикл, проходящий через каждую вершину ровно один раз. Гамильтоновым графом называется граф, в котором есть гамильтонов цикл.


Построение гамильтонова цикла — сложная задача, в настоящее время неизвестно эффективного алгоритма его решения. Более того, скорее всего такого алгоритма (решающего  задачу за сложность, являющуюся многочленом от числа вершин в графе n) скорее всего просто не существует, но это одна из нерешенных на сей момент проблема теории сложности алгоритмов.


Можно придумать переборное решение, сложность которого будет порядка O(n!). Например, если перенумеровать вершины в графе, то номера вершин в порядке следования их в гамильтоновом цикле образуют некоторую перестановку чисел от 1 до n. Можно перебрать все n!  возможных перестановок и для каждой из них проверить, что данная перестановка соответствует циклу на графе, то есть каждые два соседних элемента в перестановке, а также первый и последний элемент перестановки соединены ребром.


Для перебора перестановок можно использовать ранее разобранный алгоритм перебора с возвратом. Запишем этот алгоритм так, чтобы исключить заведомо неподходящие варианты, а именно, к уже построенной части пути будем добавлять только те вершины, которые соединены ребром с последней вершиной в пути (и не были посещены ранее), добавив новую вершину к пути рекурсивно запускаем алгоритм из новой вершины.


Во многом этот алгоритм напоминает алгоритм поиска в глубину, но главное его отличие заключается в том, что если из какой-то вершины не удается продолжить путь дальше (то есть были рассмотрены все ребра и все возможные продолжения привели в тупик), то алгоритм возвращается в предыдущую вершину, при этом покинутая вершина «перекрашивается», то есть с нее снимается отметка о том, что эта вершина была посещена ранее. При этом алгоритм может вернуться в эту вершину еще раз, уже по другому пути (и даже обязан это сделать, если в графе существует гамильтонов путь, так как гамильтонов путь проходит через все вершины).


Пусть n — число вершин в графе, вершины пронумерованы числами от 0 до n-1. Граф задан матрицей смежности A. В глобальной переменной Path будет храниться список вершин, входящих в путь.  Функция hamilton принимает в качестве параметра номер вершины, добавляемой к пути и возвращает значение true, если удалось построить гамильтонов путь и false, если не удалось. Причем если путь построить удалось, то построенный путь будет храниться в списке Path.


.. code-block:: python

	Visited = [False] * n
	Path = []
	def hamilton(curr): 
    		Path.append(curr)
    		if len(Path) == n:
        		if A[Path[0]][Path[-1]] == 1:
            			return True 
        		else: 
            			Path.pop() 
            			return False 
    		Visited[curr] = True

    		for next in range(n): 

        		if A[curr][next] == 1 and not Visited[next]: 
            			if hamilton(next): 
                			return True 
   		Visited[curr] = False 
    		Path.pop()

    		return False



Функция Hamilton прежде всего добавляет вершину curr в конец списка Path. При этом если длина списка стала равна n, то есть все вершины включены в путь Path, проверяется, что первая и последняя вершина в пути соединены ребром (это не требуется при помощи гамильтонова пути), если это так — то алгоритм возвращает True (цикл найден), в противном случае из списка Path удаляется последний элемент и алгоритм возвращает False (цикл не найден).

Если же длина списка меньше n, то вершина curr отмечется, как посещенная и осуществляется перебор дальнейших продолжений. Последовательно перебираются все оставшиеся вершины next и если вершина next соединена ребром с curr и вершина next не была посещена, то алгоритм рекурсивно запускается из вершины next, пытаясь сделать продолжение пути в вершину next. При этом если рекурсивный вызов из вершины next вернет True, то есть удалось построить цикл, то алгоритм сразу же возвращает True, при этом из списка Path ничего не удаляется, поэтому Path будет хранить полный гамильтонов цикл. Если же ни одно из продолжений не получилось, то осуществляется «откат» вершины curr — она помечается, как непосещенная, удаляется из конца списка Path и управление передается назад, на последнюю вершину в списке Path.


Пример оптимизаций алгоритма поиска гамильтонова пути в большом графе можно прочитать в цикле статей:

https://habr.com/ru/post/160077/

https://habr.com/ru/post/160167/ 

https://habr.com/ru/post/229597/ 



Проверка на двудольность с помощью DFS.
=======================================


Граф называется двудольным, если его вершины можно разбить на два множества так, что концы каждого ребра принадлежат разным множествам. Иными словами, можно покрасить вершины графа в два цвета так, что концы каждого ребра покрашены в разный цвет.


Решить эту задачу можно с помощью DFS - граф двудольный тогда и только тогда, когда все его циклы чётные.


Рассмотрим код стандартного алгоритма:

.. code-block:: python

	visited = [False] * n
	prev = [None] * n

	def dfs(start, visited, prev, g):
    		visited[start] = True
    		for u in g[start]:
        		if not visited[u]:
            			prev[u] = start 
            			dfs(u)

	dfs(start, visited, prev, g)



Чтобы проверить граф на двудольность, надо модифицировать алгоритм DFS так, что он будет проверять граф на двудольность и строить покраску графа в два цвета (если он двудольный). Для этого заменим список Visited на список Color, в котором будем хранить значение 0 для непосещенных вершин, а для посещенных вершин будем гранить значение 1 или 2 – ее цвет.


Алгоритм DFS для каждого ребра будет проверять цвет конечной вершины этого ребра. Если вершина не была посещена, то она красится в цвет, неравный цвету текущей вершины. Если же вершина была посещена, то ребро либо пропускается, если его концы – разноцветные, а если его концы одного цвета, то делается пометка, что граф не является двудольным (переменной IsBipartite присваивается значение False, по ее значению можно судить о том, является ли граф двудольный).



Поиск мостов с помощью DFS.
===========================


Мостом называется ребро, при удалении которого граф распадается на две компоненты связности.

Алгоритм поиска в глубину позволяет найти все мосты в связном графе за один DFS, то есть за сложность О(n).

Подвесим граф за какую-то вершину, запустим из этой вершины DFS. DFS построит дерево обхода графа, при этом будут найдены обратные рёбра - рёбра, которые идут из текущей вершины в вершину, которая находится в настоящий момент в стадии обработки. Каждой вершине u сопоставим значение h(u) — её глубина в дереве обхода.

Кроме этого, каждой вершине сопоставим значение функции f(u) , где f(u) - это минимальное значение h(v) для всех вершин v, которые достижимы из вершины u в дереве обхода, а также достижимы при помощи прохода по одному обратному ребру из любого потомка u  в дереве обхода.

Тогда ребро uv будет мостом, если f(v) > h(u).

Значения  h(u) и f(u) можно считать одним DFS.

Пример параметров, передаваемых в рекурсивную функцию:

u - текущая вершина

parent - родитель, чтобы не проходить по ребру в обратном направлении (эта реализация не работает на графе с кратными ребрами).

curr_h - текущая глубина

g - списки смежности графа

h - массив значений глубины для вершин

f - массив значения целевой функции для вершин



Задача.
=======

1. Считать и отобразить граф городов;
2. Представить его разными способами - список смежности, матрица смежности, используя обычные средства Питон.
3. Построить и отобразить остовное дерево методом обхода в глубину (DFS);

Указание.

Выбираем произвольно вершину V0, а затем следуем по ребру е01 в узел Vi , потом следуем по ребру e12 в узел V2, соседний с V1 . Вобщем случае, после посещения узла Vi следуем по ребру eij в узел Vj, если Vj ранее еще не был посещен. Далее применяем рекурсивно этот процесс к Vj и выбираем ребро ejk в узел Vk. Если вершина Vj уже была посещена, то возвращаемся в Vi и выбираем другое ребро. Если все ребра, инцидентные Vi, уже выбраны и нельзя найти ни одной новой вершины, то возвращаемся из Vj в предыдущую вершину, за которой идет Vi, и проверяем ей инцидентные ребра.

4. Написать функцию, осуществляющую топологическую сортировку вершин;
5. Найти все мосты в графе городов. 

**Дополнительно:**

1. Проверить эйлеровость графа и отобразить эйлеров цикл
2. Найти и отобразить гамильтонов цикл в графе или вывести сообщение, что граф не гамильтонов


Галерея визуализированных графов.
---------------------------------

На официальном сайте NetworkX есть целая `галерея визуализированных графов`_.

.. _`галерея визуализированных графов`: https://networkx.github.io/documentation/stable/auto_examples/index.html



Пример файла с входными данными для задач данной работы
-------------------------------------------------------

.. code-block:: text

	Апельсиновый Мандариновый 100
	Мандариновый Ананасовый 200
	Мандариновый Папайя 300
	Мандариновый Кивиновый 400
	Кивиновый Ананасовый 500
	Яблочный Грушевый 100
	Яблочный Вишнёвый 200
	Вишнёвый Сливовый 300
	Грушевый Сливовый 400
	Вишнёвый Черешневый 500
	Кивиновый Фейхоа 600
	Сливовый Алычовый 600
	Алычовый Терновый 700
	Мандариновый Персиковый 1000
	Персиковый Абрикосовый 300
	Абрикосовый Сливовый 400
	Абрикосовый Алычовый 200
	Земляничный Клубничный 100
	Клубничный Брусничный 200
