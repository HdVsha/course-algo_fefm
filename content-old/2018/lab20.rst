Работа со строками, Z-функция и КМП.
####################################

:date: 2019-02-26 08:00
:summary: Работа со строками, Z-функция и КМП.
:status: published 

.. default-role:: code




Z-функция
=========

Материал позаимствован с сайта `e-maxx.ru <https://e-maxx.ru/algo/z_function>`_.

Определение
-----------

Здесь и далее строки индексируются с нуля, т.е. первый символ строки имеет номер `0`. Также, здесь и далее `s[i \ldots j]` обозначает подстроку строки `s` от `i`-го символа до `j`-го **включительно**.

Пусть дана строка `s` длины `n`. Тогда `Z(s)` - это массив длины `n`, `i`-ый элемент которого равен наибольшему числу символов, начиная с позиции `i`, совпадающих с первыми символами строки `s`.

Иными словами, `z[i]` — это длина наибольшего общего префикса строки `s` и её `i`-го суффикса.

Первый элемент `Z`-функции, `z[0]`, обычно считают неопределённым. В данной статье мы будем считать, что он равен нулю (хотя ни в алгоритме, ни в приведённой реализации это ничего не меняет).

Далее будет привиден алгоритм вычисления `Z`-функции за время `O(n)`, а также различные применения этого алгоритма.

Итак, определение можно сформулировать так.

Z-функция (англ. Z-function) от строки S и позиции x — это длина максимального префикса подстроки, начинающейся с позиции x в строке S, который одновременно является и префиксом всей строки S. Более формально, 

  .. math::

      Z[i](s)=maxk∣s[i…i+k]=s[0…k]. 



Значение Z-функции от первой позиции не определено, поэтому его обычно приравнивают к нулю или к длине строки.

Примеры
-------

Приведём для примера подсчитанную `Z`-функцию для нескольких строк:

- "aaaaa"::

    z[0] = 0,
    z[1] = 4,
    z[2] = 3,
    z[3] = 2,
    z[4] = 1.

- "aaabaab"::

    z[0] = 0,
    z[1] = 2,
    z[2] = 1,
    z[3] = 0,
    z[4] = 2,
    z[5] = 1,
    z[6] = 0.

- "abacaba"::

    z[0] = 0,
    z[1] = 0,
    z[2] = 1,
    z[3] = 0,
    z[4] = 3,
    z[5] = 0,
    z[6] = 1.

Тривиальный алгоритм
--------------------

Формальное определение можно представить в виде следующей элементарной реализации за `O(n^2)`:

.. code-block:: python

    def z_func(s, n):
        z = [0] * n
        for i in range(1, n):
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
        return z

Мы просто для каждой позиции `i` перебираем ответ для неё `z[i]`, начиная с нуля, и до тех пор, пока мы не обнаружим несовпадение или не дойдём до конца строки.

Разумеется, эта реализация слишком неэффективна, перейдём теперь к построению эффективного алгоритма.

Эффективный алгоритм вычисления Z-функции
-----------------------------------------

Чтобы получить эффективный алгоритм, будем вычислять значения `z[i]` по очереди — от `i=1` до `n-1`, и при этом постараемся при вычислении очередного значения `z[i]` максимально использовать уже вычисленные значения.

Назовём для краткости подстроку, совпадающую с префиксом строки `s`, **отрезком совпадения**. Например, значение искомой Z-функции `z[i]` — это длина длиннейшего отрезок совпадения, начинающийся в позиции `i` (и заканчиваться он будет в позиции `i + z[i] - 1`).

Для этого будем поддерживать **координаты** `[l;r]` **самого правого отрезка совпадения**, т.е. из всех обнаруженных отрезков будем хранить тот, который оканчивается правее всего. В некотором смысле, индекс `r` — это такая граница, до которой наша строка уже была просканирована алгоритмом, а всё остальное — пока ещё не известно.

Тогда если текущий индекс, для которого мы хотим посчитать очередное значение `Z`-функции, — это `i`, мы имеем один из двух вариантов:

- `i > r` — т.е. текущая позиция лежит **за пределами** того, что мы уже успели обработать.

  Тогда будем искать `z[i]` **тривиальным алгоритмом**, т.е. просто пробуя значения `z[i]=0`, `z[i]=1`, и т.д. Заметим, что в итоге, если `z[i]` окажется `> 0`, то мы будем обязаны обновить координаты самого правого отрезка `[l; r]` — т.к. `i + z[i] - 1` гарантированно окажется больше `r`.

- `i <= r` — т.е. текущая позиция лежит внутри отрезка совпадения `[l; r]`.

  Тогда мы можем использовать уже подсчитанные **предыдущие** значения `Z`-функции, чтобы проинициализировать значение `z[i]` не нулём, а каким-то возможно бОльшим числом.
  
  
  .. image:: {filename}/images/Z-func.png
  
  

  Для этого заметим, что подстроки `s[l ... r]` и `s[0 ... r-l]` **совпадают**. Это означает, что в качестве начального приближения для `z[i]` можно взять соответствующее ему значение из отрезка `s[0 ... r-l]`, а именно, значение `z[i-l]`.

  Однако значение `z[i-l]` могло оказаться слишком большим: таким, что при применении его к позиции `i` оно "вылезет" за пределы границы `r`. Этого допустить нельзя, т.к. про символы правее `r` мы ничего не знаем, и они могут отличаться от требуемых.

  Приведём пример такой ситуации, на примере строки **"aaaabaa"**.

  Когда мы дойдём до последней позиции `(i=6)`, текущим самым правым отрезком будет `[5;6]`. Позиции `6` с учётом этого отрезка будет соответствовать позиция `6-5=1`, ответ в которой равен `z[1] = 3`. Очевидно, что таким значением инициализировать `z[6]` нельзя, оно совершенно некорректно. Максимум, каким значением мы могли проинициализировать — это `1`, поскольку это наибольшее значение, которое не вылезает за пределы отрезка `[l;r]`.

  Таким образом, в качестве **начального приближения** для `z[i]` безопасно брать только такое выражение:

  .. math::

      z_0[i] = \min (r-i+1, z[i-l]).

  Проинициализировав `z[i]` таким значением `z_0[i]`, мы снова дальше действуем **тривиальным алгоритмом** — потому что после границы `r`, вообще говоря, могло обнаружиться продолжение отрезка совпадение, предугадать которое одними лишь предыдущими значениями `Z`-функции мы не можем.

Таким образом, весь алгоритм представляет из себя два случая, которые фактически различаются только **начальным значением** `z[i]`: в первом случае оно полагается равным нулю, а во втором — определяется по предыдущим значениям по указанной формуле. После этого обе ветки алгоритма сводятся к выполнению **тривиального алгоритма**, стартующего сразу с указанного начального значения.

Алгоритм получился весьма простым. Несмотря на то, что при каждом `i` в нём так или иначе выполняется тривиальный алгоритм — мы достигли существенного прогресса, получив алгоритм, работающий за линейное время (действительно, на каждый символ мы "посмотрим", т.е. сравним его с каким-либо предыдущим всего один раз).

Этот алгоритм работает за O(n), так как каждая позиция пробегается не более двух раз: при попадании в диапазон от left до right и при высчитывании Z-функции простым циклом.



Упражнение №1: `Z`-функция
++++++++++++++++++++++++++

Напишите `Z`-функцию. Пусть заголовком ее будет :code:`def z_func(s, n):`

Решение.

.. code-block:: python

    def z_func(s, n):
        z = [0] * n
        l = 0; r = 0
        for i in range(1, n): 
            if (i<=r):
                z[i] = min(r-i+1, z[i-l])  \text{если первое меньше, то далее тривиальный алгоритм, иначе уже посчитано}
            while i + z[i] < n and s[z[i]] == s[i + z[i]]: \text{тривиальный алгоритм}
                z[i] += 1
            if (i+z[i]-1 > r):  \text{сохраняем самый правый отрезок совпадения}
                l = i
                r = i + z[i] - 1
        return z


Упражнение №2: Поиск подстроки
++++++++++++++++++++++++++++++

Пусть даны две строки. Найти все вхождения второй строки в первую.

Указание.

Во избежание путаницы, назовём одну строку текстом t, другую — образцом p. Таким образом, задача заключается в том, чтобы найти все вхождения образца p в текст t.

Для решения этой задачи образуем строку s = p + \# + t, т.е. к образцу припишем текст через символ-разделитель (который не встречается нигде в самих строках).

Посчитаем для полученной строки Z-функцию. Тогда для любого i в отрезке [0; length(t)-1] по соответствующему значению z[i + length(p) + 1] можно понять, входит ли образец p в текст t, начиная с позиции i: если это значение Z-функции равно length(p), то да, входит, иначе — нет.

Таким образом, асимптотика решения получилась O (length(t) + length(p)). Потребление памяти имеет ту же асимптотику.


Упражнение №3: Количество разных подстрок
+++++++++++++++++++++++++++++++++++++++++

Найти число всех различных подстрок входящих в данную.

Указание.

Дана строка s длины n. Требуется посчитать количество её различных подстрок.

Будем решать эту задачу итеративно. А именно, научимся, зная текущее количество различных подстрок, пересчитывать это количество при добавлении в конец одного символа.

Итак, пусть k — текущее количество различных подстрок строки s, и мы добавляем в конец символ c. Очевидно, в результате могли появиться некоторые новые подстроки, оканчивавшиеся на этом новом символе c (а именно, все подстроки, оканчивающиеся на этом символе, но не встречавшиеся раньше).

Возьмём строку t=s+c и инвертируем её (запишем символы в обратном порядке). Наша задача — посчитать, сколько у строки t таких префиксов, которые не встречаются в ней более нигде. Но если мы посчитаем для строки t Z-функцию и найдём её максимальное значение z_{\rm max}, то, очевидно, в строке t встречается (не в начале) её префикс длины z_{\rm max}, но не большей длины. Понятно, префиксы меньшей длины уже точно встречаются в ней.

Итак, мы получили, что число новых подстрок, появляющихся при дописывании символа c, равно len - z_{\rm max}, где len — текущая длина строки после приписывания символа c.

Следовательно, асимптотика решения для строки длины n составляет O (n^2).

Стоит заметить, что совершенно аналогично можно пересчитывать за O (n) количество различных подстрок и при дописывании символа в начало, а также при удалении символа с конца или с начала.


Упражнение №4: Период строки (сжатие строк)
+++++++++++++++++++++++++++++++++++++++++++

Для данной строки `s` найти строку `p` минимальной длины, такую что `s` можно предстваить как конкатенацию одной или нескольких копий `p`.

Указание.
Для решения посчитаем Z-функцию строки s, и найдём первую позицию i такую, что i + z[i] = n, и при этом n делится на i. Тогда строку s можно сжать до строки длины i.


Префикс-функция. Алгоритм Кнута-Морриса-Пратта
==============================================

Материал частично позаимствован с сайта `тоже e-maxx.ru <https://e-maxx.ru/algo/prefix_function>`_.

Префикс-функция. Определение
----------------------------

Пусть дана строка `s` длины `n`. Тогда `pi(s)` - это массив длины `n`, `i`-ый элемент которого (`pi[i]`) определяется следующим образом: это длина наибольшего собственного суффикса подстроки `s[0 ... i]`, совпадающего с её префиксом (собственный суффикс — значит не совпадающий со всей строкой). В частности, значение `pi[0]` полагается равным нулю.

Примечение: вообще говоря, в теории множеств собственным считается **не пустое** подмножество, не совпдающее с самим множеством. В данной статье, для простоты суффикс и префикс нулевой длины также считаются собственными.

Математически определение префикс-функции можно записать следующим образом:

.. math::

    \pi[i] = \max_{k=0 \ldots i} \{ k : s[0 \ldots k - 1] = s[i - k + 1 \ldots i]\}.

Например, для строки **"abcabcd"** префикс-функция равна: `[0, 0, 0, 1, 2, 3, 0]`, что означает::

    у строки "a" нет нетривиального префикса, совпадающего с суффиксом;
    у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;
    у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;
    у строки "abca" префикс длины 1 совпадает с суффиксом;
    у строки "abcab" префикс длины 2 совпадает с суффиксом;
    у строки "abcabc" префикс длины 3 совпадает с суффиксом;
    у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.

Другой пример — для строки **"aabaaab"** она равна: `[0, 1, 0, 1, 2, 2, 3]`.

Тривиальный алгоритм
--------------------

Непосредственно следуя определению, можно написать такой алгоритм вычисления префикс-функции:

.. code-block:: python

    def prefix_func(s, n):
        pi = [0] * n
        for i in range(n):
            for k in range(1, i + 1):
                equal = True
                for j in range(k):
                    if s[j] != s[i - k  + 1 + j]:
                        equal = False
                        break
                if equal:
                    pi[i] = k
        return pi

Как нетрудно заметить, работать он будет за `O(n^3)`, что слишком медленно.

Эффективный алгоритм
--------------------

Для удобства будем обозначать подстроки строки `s` следующим образом: пусть `p^k` - префикс `s` длины `k`, `s^k_i` - подстрока длины `k` заканчивающаяся символом с номером `i`. Напомним, что первый символ строки имеет номер `0`.

Будем вычислять `pi[i]` последовательно, начиная с `pi[1]`.  

`pi[0]` очевидно `= 0`. Постараемся на `i` шаге получить решение, используя уже известную информацию, т.е. предыдущие значения `pi`.

Во-первых заметим, что `pi[i]` превосходит `pi[i - 1]` не более чем на 1. Действительно, в противном случае, если бы pi[i+1] > pi[i] + 1, то рассмотрим этот суффикс, оканчивающийся в позиции i+1 и имеющий длину pi[i+1] — удалив из него последний символ, мы получим суффикс, оканчивающийся в позиции i и имеющий длину pi[i+1]-1, что лучше pi[i], т.е. пришли к противоречию. Иллюстрация этого противоречия (в этом примере pi[i-1] должно быть равно 3) в схеме (для `pi[i] = 4`):

.. math::

     \underbrace{ \overbrace{s_0 \ s_1 \ s_2}^{\pi[i-1]}\ \overbrace{s_3}^{s_3 = s_i }}_{\pi[i] = 4} \ldots \underbrace{ \overbrace{s_{i-3} \ s_{i-2} \ s_{i-1}}^{\pi[i-1] >= 3}\ \overbrace{s_i}^{s_3 = s_i} }_{\pi[i] = 4}

Будем рассматривать убывающую последовательность 

.. math::

    `\{k_j\}: p^{k_j} = s^{k_j}_{i - 1}, i > k_j, k_j > k_{j + 1}, j = 0, 1, ...`,
 

т.е. собственные суффиксы строки `p^i`, являющиеся одновременно ее префиксами, упорядоченные по убыванию длины. Очевидно, что первый из них, для которого выполнено `s[k_j] = s[i]` 

.. math::

    `s[k_j] = s[i]`
 

даст нам 

.. math::

    `\pi[i] = k_j + 1`. 



Осталось только понять, как можно быстро перебрать такие `k_j`. Иллюстрация, в предположении что 

.. math::

    `k_{j+1} = 2`




.. math::

    \overbrace{\overbrace{s_0 \ s_1}^{k_{j+1}} \ s_2 \ldots s_{k_j-1}}^{k_j}\ s_{k_j} \ldots \overbrace{s_{i-k_{j-1}} \ldots \overbrace{s_{i-2} \ s_{i-1}}^{k_{j+1}}}^{k_j}\ s_i

    \ldots

    s_{k_j} = s_i \Rightarrow \pi[i] = k_j + 1, \text{переходим к следующему i}

    s_{k_{j+1}} = s_i \Rightarrow \pi[i] = k_{j+1} + 1, \text{переходим к следующему i}

    \ldots


По определению префикс-функции, очевидно, что  

.. math::

    `k_0 = pi[i - 1]`.\text{ Пусть мы теперь знаем  }
    `k_j`
    \text{, найдем}



.. math::

    `k_{j+1}`. `p^{k_j} = s^{k_j}_{i - 1}`, значит, `p^{k_{j+1}} = s^{k_{j+1}}_{k_j - 1}`, 
    \text{причем} 
    `p^{k_{j+1}}` \text{максимален из всех таких собственных префиксов строки} 
    `p^{k_j}`. \text{Значит, }
    `k_{j+1} = \pi[k_j - 1]`. 

 

Иллюстрация, в предположении что 

.. math::

    `k_{j+1} = 2`


.. math::

     \overbrace{\underbrace{s_0 \ s_1}_{k_{j+1}} \ s_2 \ldots \underbrace{s_{k_j-1} s_{k_j-1}}_{k_{j+1} = \pi[k_j - 1]}}^{k_j}\ s_{k_j} \ldots \overbrace{s_{i-k_j} \ldots \underbrace{s_{i-2} \ s_{i-1}}_{k_{j+1}}}^{k_j}\ s_i


Ясно, что последовательность `k_j` заканчивается первым получившимся нулем. Если при этом условие 

.. math::

    `s[k_j] = s[i]`

 


так и не было удовлетворено, то очередное `pi[i] = 0`.


Итак, `pi[0] = 0`, далее, на каждом шагу алгоритма будем вычислять последовательность `k_j`. Если для очередного `k_j` выполнено `s[k_j] = s[i]`, то 

.. math::

    `\pi[i] = k_j + 1`, 



переходим к следующему `i`. Если перебрали все `k_j` вплоть до нуля и совпадения нет, то `\pi[i] = 0`. Заметим, что дойдя до нуля совпадение тоже нужно проверить, в этом случае можно получить 

.. math::

     `\pi[i] = 0 + 1 = 1`.


Этот алгоритм был разработан Кнутом (Knuth) и Праттом (Pratt) и независимо от них Моррисом (Morris) в 1977 г. (как основной элемент для алгоритма поиска подстроки в строке). Легко видеть, что алгоритм имеет сложность `O(n)`: действительно, сложность шага, на котором префикс-функция возрастает, т.е. `pi[i] = pi[i - 1] + 1` есть `O(1)`, сложность шага на котором функция убывает есть 


.. math::

     `O(pi[i] - pi[i - 1])`.



Т.е. общая сложность есть 


.. math::

     `O(\sum_i| \pi[i] - \pi[i - 1]|)`. 





Сумма положительных приростов префикс-функции не превышает `n`. А сумма отрицательных изменений не может превысить сумму положительных (иначе мы уйдем в минус). Значит сумма модулей изменений функции не превысит `2n`, значит общая сложность `O(n)`.

Как нетрудно заметить, этот алгоритм является **онлайновым**, т.е. он обрабатывает данные по ходу поступления — можно, например, считывать строку по одному символу и сразу обрабатывать этот символ, находя ответ для очередной позиции. Алгоритм требует хранения самой строки и предыдущих вычисленных значений префикс-функции, однако, как нетрудно заметить, если нам заранее известно максимальное значение, которое может принимать префикс-функция на всей строке, то достаточно будет хранить лишь на единицу большее количество первых символов строки и значений префикс-функции.


Поиск подстроки в строке. Алгоритм Кнута-Морриса-Пратта
-------------------------------------------------------


Эта задача является классическим применением префикс-функции (и, собственно, она и была открыта в связи с этим).

Дан текст `t` и строка `s`, требуется найти и вывести позиции всех вхождений строки `s` в текст `t`.

Обозначим для удобства через `n` длину строки `s`, а через `m` — длину текста `t`.

Образуем строку `s + \# + t`, где символ `\#` — это разделитель, который не должен нигде более встречаться. Посчитаем для этой строки префикс-функцию. Теперь рассмотрим её значения, кроме первых `n+1` (которые, как видно, относятся к строке `s` и разделителю). По определению, значение `pi[i]` показывает наидлиннейшую длину подстроки, оканчивающейся в позиции `i` и совпадающего с префиксом. Но в нашем случае это `pi[i]` — фактически длина наибольшего блока совпадения со строкой `s` и оканчивающегося в позиции `i`. Больше, чем `n`, эта длина быть не может, за счёт разделителя. А вот равенство `pi[i] = n` (там, где оно достигается), означает, что в позиции `i` оканчивается искомое вхождение строки `s` (только не надо забывать, что все позиции отсчитываются в склеенной строке `s+\#+t`).

Таким образом, если в какой-то позиции `i` оказалось `pi[i] = n`, то в позиции `i - (n + 1) - n + 1 = i - 2n` строки `t` начинается очередное вхождение строки `s` в строку `t`.

Как уже упоминалось при описании алгоритма вычисления префикс-функции, если известно, что значения префикс-функции не будут превышать некоторой величины, то достаточно хранить не всю строку и префикс-функцию, а только её начало. В нашем случае это означает, что нужно хранить в памяти лишь строку `s + \#` и значение префикс-функции на ней, а потом уже считывать по одному символу строку `t` и пересчитывать текущее значение префикс-функции.

Итак, алгоритм Кнута-Морриса-Пратта решает эту задачу за `O(n+m)` времени и `O(n)` памяти.

Алгоритм из упражнения 2 решает эту задачу за `O(n+m)` времени и `O(n + m)` памяти, то есть менее оптимально. 


Упражнение №5: Префикс-функция
++++++++++++++++++++++++++++++

Напишите префикс-функцию. Пусть заголовком ее будет :code:`def p_func(s, n):`

Указание.

Кратко запишем уже описанное выше.

Заметим, что p[i+1]⩽p[i]+1. Чтобы показать это, рассмотрим суффикс,оканчивающийся на позиции i+1 и имеющий длину p[i+1], удалив из него последний символ, мы получим суффикс, оканчивающийся на позиции i и имеющий длину p[i+1]−1, следовательно неравенство p[i+1]>p[i]+1 неверно.

Избавимся от явных сравнений строк. Пусть мы вычислили p[i], тогда, если s[i+1]=s[p[i]], то p[i+1]=p[i]+1. Если окажется, что s[i+1]≠s[p[i]], то нужно попытаться попробовать подстроку меньшей длины. Хотелось бы сразу перейти к такому бордеру наибольшей длины, для этого подберем такое k, что k=p[i]−1. Делаем это следующим образом. 

За исходное k необходимо взять p[i−1], что следует из первого пункта. В случае, когда символы s[k+1] и s[i] не совпадают, p[k] — следующее потенциальное наибольшее значение k, что видно из рисунка. Последнее утверждение верно, пока k>0, что позволит всегда найти его следующее значение. Если k=0, то p[i]=1 при s[i]=s[1] , иначе p[i]=0.


  .. image:: {filename}/images/Prefix.jpg


Приведём здесь итоговую схему алгоритма:

Считать значения префикс-функции p[i] будем по очереди: от i=1 к i=n-1 (значение p[0] просто присвоим равным нулю).

Для подсчёта текущего значения p[i] мы заводим переменную j, обозначающую длину текущего рассматриваемого образца. Изначально j = p[i-1].

Тестируем образец длины j, для чего сравниваем символы s[j] и s[i]. Если они совпадают — то полагаем p[i] = j+1 и переходим к следующему индексу i+1. Если же символы отличаются, то уменьшаем длину j, полагая её равной p[j-1], и повторяем этот шаг алгоритма с начала.
Если мы дошли до длины j=0 и так и не нашли совпадения, то останавливаем процесс перебора образцов и полагаем p[i] = 0 и переходим к следующему индексу i+1.



Упражнение №6: Поиск подстроки (Finding a Motif in DNA)
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

Задача SUBS.   http://rosalind.info/problems/subs/  .

Даны две строки s и t, t является подстрокой s, если t содержится в виде непрерывного набора символов в s (в результате t должно быть не длиннее s). Найти все вхождения второй строки в первую с помощью алгоритма Кнута-Морриса-Пратта.

Подстрока s может быть представлена как s [j: k], где j и k представляют начальную и конечную позиции подстроки в s; например, если s = "AUGCUUCAGAAAGGUCUUACG", то s [2: 5] = "UGCU".

Расположение подстроки s [j: k] является ее начальной позицией j; обратите внимание, что t будет иметь несколько местоположений в s, если оно встречается в качестве подстроки s более одного раза (см. пример ниже).

Дано: две цепочки ДНК s и t (каждая длиной не более 1 т.п.н.).

Вывести: все расположения t как подстроки s.

Пример входных данных 

GATATATGCATATACTT

ATAT

Пример выходных данных

2 4 10


Указание.

Кратко опишем уже написанное выше.

Дана цепочка T и образец P. Требуется найти все позиции, начиная с которых P входит в T. 

Построим строку S=P#T, где # — любой символ, не входящий в алфавит P и T. Посчитаем на ней значение префикс-функции p. Благодаря разделительному символу #, выполняется ∀i:p[i]⩽len(P). Заметим, что по определению префикс-функции при i>len(P) и p[i]=len(P) подстроки длины P, начинающиеся с позиций 0 и i−len(P)+1, совпадают. Соберем все такие позиции i−len(P)+1 строки S, вычтем из каждой позиции len(P)+1, это и будет ответ. Другими словами, если в какой-то позиции i выполняется условие p[i]=len(P), то в этой позиции начинается очередное вхождение образца в цепочку.


  .. image:: {filename}/images/640px-Kmp_pict2.png


Предложенная реализация имеет оценку по памяти O(P+T). Оценки O(P) можно добиться за счет отказа от запоминания значений префикс-функции для позиций в S, меньших len(P)+1 (то есть до начала цепочки T). Это возможно, так как значение префикс-функции не может превысить длину образца, благодаря разделительному символу #.

Вместо префикс-функции в алгоритме Кнута-Морриса-Пратта можно использовать Z-функцию. 

Оценки времени работы и памяти при этом не изменятся.


Упражнение №7: Поиск подстроки онлайн
+++++++++++++++++++++++++++++++++++++

В первой строке ввода - число `n`, количество букв в паттерне.
Во второй строке - паттерн, строка которую нужно искать в тексте.
В каждой из последующих строк - символы текста, по одному в каждой строке. Необходимо вывести позиции вхождений паттерна в текст. Длина текста заранее не известна, он может быть очень большим.

Упражнение №9: Количество разных подстрок
+++++++++++++++++++++++++++++++++++++++++

Найти число всех различных подстрок входящих в данную с помощью префикс-функции.

Упражнение №10: Период строки
+++++++++++++++++++++++++++++

Для данной строки `s` найти строку `p` минимальной длины, такую что `s` можно предстваить как конкатенацию одной или 
нескольких копий `p`.Используйте префикс-функцию.



Упражнение №11: SSEQ
++++++++++++++++++++

Finding a Spliced Motif  http://rosalind.info/problems/sseq/ 

Подпоследовательность строки представляет собой набор символов, содержащихся в последовательности (хотя и не обязательно непрерывно) в строке (например, ACG является подпоследовательностью TATGCTAAGATC). Индексы подпоследовательности - это позиции в строке, в которых появляются символы подпоследовательности; таким образом, показатели ACG в TATGCTAAGATC можно представить как (2, 5, 9).

Поскольку подстрока может иметь несколько местоположений, подпоследовательность может иметь несколько наборов индексов, и один и тот же индекс может быть повторно использован в более чем одном появлении подпоследовательности; например, ACG является подпоследовательностью AACCGGTT в 8 разных направлениях.

Входные данные: две строки ДНК s и t (каждая длиной не более 1 т.п.н.) в формате FASTA.

Выходные: один набор символов индексов s, в котором символы t появляются как подпоследовательность s. Если существует несколько решений, вы можете вернуть любое.

Пример входных данных 


ACGTACGTGACG

GTA


Пример выходных данных 

3 8 10


